 # ğŸ”¥ SQL Injection in Django ORM (CVE-2025-13372)

![Multiple Django Vulnerabilities Enables SQL injection and denial-of-service Attacks (1)](https://github.com/user-attachments/assets/50eb6721-7d69-4d10-8679-30dbe8e1a090)

---

## ğŸ¯ **1. Overview â€” What Is CVE-2025-13372?**

**CVE-2025-13372** is a **SQL Injection vulnerability** discovered in the **Django Web Framework**, one of the most widely used Python frameworks for secure and scalable web development.

The vulnerability appears specifically when an application:

* Uses **PostgreSQL** ğŸ˜ as the database backend
* Uses **FilteredRelation** ğŸ” for conditional joins in complex ORM queries
* Accepts **dynamic dictionaries** (`**kwargs`) for constructing query annotations or aliases
* Allows **user-controlled data** to influence the alias names used in SQL generation

This combination creates a dangerous opening where malicious input can inject **raw SQL** into part of a query that was intended to be safely constructed by Djangoâ€™s ORM.

---

## ğŸ§¬ **2. Technical Breakdown â€” Why This Happens**

Djangoâ€™s ORM normally prevents SQL injection by:

* Escaping dangerous characters
* Parameterizing inputs
* Prohibiting raw SQL unless explicitly allowed

However, aliases passed to functions like:

```python
queryset.annotate(**dynamic_values)
queryset.alias(**dynamic_names)
```

are **not parameterized**, because aliases are part of SQL *syntax*, not SQL *values*.
If user-controlled input makes it into these alias names, Django may inadvertently embed those strings verbatim into generated SQL.

This becomes particularly dangerous when paired with **FilteredRelation**, which generates more complex expressions and joins, increasing the number of places where SQL segments are stitched together.

ğŸ’¥ Result:
A malicious alias can break out of its intended SQL position and run arbitrary SQL code.

---

## ğŸ§© **3. Affected Versions â€” Who Is at Risk?**

ğŸ“Œ Django releases impacted by CVE-2025-13372:

| Version Line   | Vulnerable Until | Patched Version             |
| -------------- | ---------------- | --------------------------- |
| **4.2 LTS**    | < 4.2.27         | **4.2.27**                  |
| **5.1**        | < 5.1.15         | **5.1.15**                  |
| **5.2**        | < 5.2.9          | **5.2.9**                   |
| **6.0 / main** | Pre-release      | Fixed in development branch |

This affects *all* projects running these versions if:

* They use PostgreSQL
* They generate dynamic annotations or aliases
* Untrusted input can influence the keyword keys

---

## ğŸ”¥ **4. Severity â€” How Dangerous Is This?**

### âœ”ï¸ Djangoâ€™s classification: **High Severity**

Because it enables:

* Unauthorized SQL execution
* Data exfiltration
* Data modification or deletion
* Full compromise of the application's data layer

### âœ”ï¸ CVSS assessments (where published):

Medium to High depending on conditions, but commonly around:

* **CVSS Base Score ~ 4.3â€“7.0**
* **Attack Vector:** Network
* **Privileges Required:** None
* **User Interaction:** Required in some cases

Even â€œMediumâ€ in CVSS terms can be **catastrophic** in real-world deployments if user data is exposed or critical operations rely on the affected queries.

---

## ğŸ§¨ **5. Potential Real-World Impact**

If exploited successfully, attackers could:

### ğŸ“¥ **Extract sensitive data**

* Usernames, emails, phone numbers
* Password hashes
* Financial records
* API keys stored in DB

### âœï¸ **Manipulate or corrupt data**

* Insert harmful rows
* Alter integrity-critical fields
* Destroy audit logs

### ğŸš« **Delete content**

* Drop tables
* Purge records
* Cascade deletions across related models

### ğŸ´â€â˜ ï¸ **Step toward full system compromise**

SQL injection often serves as a **pivot point** for:

* Privilege escalation
* Remote code execution (via abused DB features)
* Gaining admin access to the application

Even if RCE is not directly possible, control of the database *alone* can dismantle a system.

---

## ğŸ›¡ï¸ **6. Mitigation â€” How to Protect Your Application**

### ğŸŸ¢ **A. Immediate Action: Upgrade Django**

Install the patched version appropriate for your series:

```bash
pip install --upgrade "django>=4.2.27"
pip install --upgrade "django>=5.1.15"
pip install --upgrade "django>=5.2.9"
```

### ğŸŸ£ **B. Code Audit â€” Look for Exploitable Patterns**

Inspect your codebase for:

#### ğŸ” **1. FilteredRelation usage**

```python
from django.db.models import FilteredRelation
```

Look for any place it appears.

#### ğŸ” **2. Dynamic aliasing**

Check for lines like:

```python
qs.annotate(**user_supplied_dict)
qs.alias(**possibly_dynamic)
```

Ensure the keyword *names* are *never* derived from untrusted input.

### ğŸ”§ **C. Strengthen Input Validation**

* Reject special characters in name fields
* Sanitize data using whitelists (letters, digits, underscores only)
* Do not allow user-controlled values to become SQL identifiers

### ğŸ” **D. Enhance Monitoring**

Set up database logs for:

* Suspicious SQL patterns
* Unexpected `UNION`, `DELETE`, or subqueries
* Abnormal spikes in query volume

---

## ğŸ“… **7. Disclosure and Patch Timeline**

* **ğŸ“¢ Reported by:** â€œStackeredâ€ (acknowledged by Django Security Team)
* **ğŸ“£ Public disclosure:** *December 2, 2025*
* **ğŸ› ï¸ Coordinated patch release:** Same day for all supported branches
* **ğŸ“š Advisory published:** Djangoâ€™s official security page

This followed standard responsible disclosure practices.

---

## ğŸŒŸ **8. Summary in Aesthetic Emoji Form**

* ğŸ§± Framework: Django
* ğŸ˜ Database: PostgreSQL
* ğŸ’¥ Vulnerability: SQL Injection
* ğŸ§¬ Root Cause: Unsanitized dynamic aliases + FilteredRelation
* ğŸ” Fix: Upgrade + sanitize inputs
* ğŸš¨ Severity: High
* ğŸ“… Year: 2025
* ğŸ¯ Impact: Data breach, corruption, system compromise

---

## ğŸš¨ Short & Clear â€“ How to Use PoC + What You Watch

1. Save script â†’ `CVE-2025-13372-poc.py`  
2. Run:  
   ```bash
   python3 CVE-2025-13372-poc.py http://target.com
   ```

**You are watching ONLY these 3 lines:**

```
â†’ VULNERABLE! (PostgreSQL error)   â† 100% owned  
â†’ VULNERABLE! (Time delay detected) + 7+ sec wait â† 100% owned  
â†’ VULNERABLE! + PostgreSQL version shown â† 100% owned
```

**If you see any of these â†’ target is vulnerable.**

**If you only see â€œno indicatorâ€ and it ends â†’ not vulnerable or wrong endpoint.**

Thatâ€™s it. Run â†’ watch for the word **VULNERABLE!** â†’ done.
