#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <unistd.h>  
#include <errno.h>  
#include <arpa/inet.h>  
#include <linux/xfrm.h>  
#include <netlink/netlink.h>  
#include <netlink/socket.h>  
#include <netlink/msg.h>  
  
// Callback to parse ALLOCSPI response  
static int parse_allocspi_response(struct nl_msg *msg, void *arg) {  
    uint32_t *allocated_spi = (uint32_t *)arg;  
    struct nlmsghdr *nlh = nlmsg_hdr(msg);  
    struct xfrm_usersa_info *sa_info;  
      
    // Verify this is the expected message type  
    if (nlh->nlmsg_type != XFRM_MSG_NEWSA) {  
        fprintf(stderr, "Unexpected message type: %d\n", nlh->nlmsg_type);  
        return NL_SKIP;  
    }  
      
    // Extract SA info from response  
    sa_info = nlmsg_data(nlh);  
    *allocated_spi = sa_info->id.spi;  
      
    printf("Received allocated SPI: 0x%08x (network byte order)\n", ntohl(*allocated_spi));  
      
    return NL_OK;  
}  


  
// Allocate SPI and return the allocated value  
int xfrm_allocate_spi_with_response(struct nl_sock *socket,   
                                     struct xfrm_usersa_info *sa_info,  
                                     uint32_t min_spi,   
                                     uint32_t max_spi,  
                                     uint32_t if_id,  
                                     uint32_t *allocated_spi) {  
    struct nl_msg *msg = nlmsg_alloc();  
    struct nl_cb *cb;  
    int err;  
      
    if (!msg) {  
        fprintf(stderr, "Failed to allocate netlink message\n");  
        return -ENOMEM;  
    }  
      
    // Create XFRM_MSG_ALLOCSPI message  
    struct nlmsghdr *nlh = nlmsg_put(msg,   
                                      NL_AUTO_PORT,  
                                      NL_AUTO_SEQ,  
                                      XFRM_MSG_ALLOCSPI,  
                                      sizeof(struct xfrm_userspi_info),  
                                      NLM_F_REQUEST);  
    if (!nlh) {  
        nlmsg_free(msg);  
        return -ENOMEM;  
    }  
      
    struct xfrm_userspi_info *spi_info = nlmsg_data(nlh);  
    memset(spi_info, 0, sizeof(*spi_info));  
      
    // Copy SA info  
    memcpy(&spi_info->info, sa_info, sizeof(struct xfrm_usersa_info));  
      
    spi_info->min = min_spi + 1;  
    spi_info->max = max_spi + 1;  
      
    // Add optional if_id attribute if specified  
    if (if_id != 0) {  
        nla_put_u32(msg, XFRMA_IF_ID, if_id);  
    }  
      
    // Set up callback for response  
    cb = nl_cb_alloc(NL_CB_DEFAULT);  
    if (!cb) {  
        nlmsg_free(msg);  
        return -ENOMEM;  
    }  
      
    nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, parse_allocspi_response, allocated_spi);  
      
    // Send message  
    err = nl_send_auto(socket, msg);  
    nlmsg_free(msg);  
      
    if (err < 0) {  
        fprintf(stderr, "Failed to send ALLOCSPI message: %s\n", nl_geterror(err));  
        nl_cb_put(cb);  
        return err;  
    }  
      
    printf("SPI allocation request sent successfully\n");  
      
    // Receive and parse response  
    err = nl_recvmsgs(socket, cb);  
    nl_cb_put(cb);  
            
    return 0;  
}  

// Callback to parse GETSA response and print SA details  
static int parse_getsa_response(struct nl_msg *msg, void *arg) {  
    struct nlmsghdr *nlh = nlmsg_hdr(msg);  
    struct xfrm_usersa_info *sa_info;  
      
    if (nlh->nlmsg_type != XFRM_MSG_NEWSA) {  
        fprintf(stderr, "Unexpected message type: %d\n", nlh->nlmsg_type);  
        return NL_SKIP;  
    }  
      
    sa_info = nlmsg_data(nlh);  
      
    printf("=== SA Information ===\n");  
    printf("SPI: 0x%08x\n", ntohl(sa_info->id.spi));  
    printf("Protocol: %u\n", sa_info->id.proto);  
    printf("Mode: %u\n", sa_info->mode);  
    printf("Replay window: %u\n", sa_info->replay_window);  
    // Print stats structure fields  
    printf("Stats - Replay window: %u\n", sa_info->stats.replay_window);  
    printf("Stats - Replay: %u\n", sa_info->stats.replay);  
    printf("Stats - Integrity failed: %u\n", sa_info->stats.integrity_failed);  

    printf("Family: %u\n", sa_info->family);  
      
    // Print addresses  
    char addr_buf[INET6_ADDRSTRLEN];  
    if (sa_info->family == AF_INET) {  
        inet_ntop(AF_INET, &sa_info->id.daddr, addr_buf, sizeof(addr_buf));  
        printf("Destination: %s\n", addr_buf);  
        inet_ntop(AF_INET, &sa_info->saddr, addr_buf, sizeof(addr_buf));  
        printf("Source: %s\n", addr_buf);  
    }  
      
    return NL_OK;  
}  
  
// Enhanced xfrm_get_sa with response parsing and error handling  
int xfrm_get_sa(struct nl_sock *socket,  
                xfrm_address_t *daddr,  
                uint32_t spi,  
                uint8_t proto,  
                uint16_t family,  
                uint32_t if_id) {  
    struct nl_msg *msg = nlmsg_alloc();  
    if (!msg) {  
        fprintf(stderr, "Failed to allocate netlink message\n");  
        return -ENOMEM;  
    }  
      
    // Set up callback FIRST  
    struct nl_cb *cb = nl_cb_alloc(NL_CB_DEFAULT);  
    if (!cb) {  
        nlmsg_free(msg);  
        return -ENOMEM;  
    }  
      
    nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, parse_getsa_response, NULL);  
    nl_cb_err(cb, NL_CB_CUSTOM, NULL, NULL);  // Add error callback  
      
    struct nlmsghdr *nlh = nlmsg_put(msg,  
                                      NL_AUTO_PORT,  
                                      NL_AUTO_SEQ,  
                                      XFRM_MSG_GETSA,  
                                      sizeof(struct xfrm_usersa_id),  
                                      NLM_F_REQUEST);  
    if (!nlh) {  
        nlmsg_free(msg);  
        nl_cb_put(cb);  
        return -ENOMEM;  
    }  
      
    struct xfrm_usersa_id *sa_id = nlmsg_data(nlh);  
    memset(sa_id, 0, sizeof(*sa_id));  
      
    memcpy(&sa_id->daddr, daddr, sizeof(xfrm_address_t));  
    sa_id->spi = spi;  
    sa_id->proto = proto;  
    sa_id->family = family;  
      
    if (if_id != 0) {  
        nla_put_u32(msg, XFRMA_IF_ID, if_id);  
    }  
      
    int res = nl_send_auto(socket, msg);  
    nlmsg_free(msg);  
      
    if (res < 0) {  
        fprintf(stderr, "Failed to send GETSA message: %s\n", nl_geterror(res));  
        nl_cb_put(cb);  
        return res;  
    }  
      
    printf("SA query request sent successfully\n");  
      
    // Receive and parse response with timeout  
    int err;  
    do {  
        err = nl_recvmsgs(socket, cb);  
    } while (err > 0);  
      
    nl_cb_put(cb);  
      
    if (err < 0) {  
        fprintf(stderr, "Query response error: %s\n", nl_geterror(err));  
        return err;  
    }  
      
    return 0;  
}

// Update existing SA  
int xfrm_update_sa(struct nl_sock *socket,  
                   struct xfrm_usersa_info *sa_info,  
                   uint32_t if_id) {  
    struct nl_msg *msg = nlmsg_alloc();  
    if (!msg) {  
        fprintf(stderr, "Failed to allocate netlink message\n");  
        return -ENOMEM;  
    }  
      
    struct nlmsghdr *nlh = nlmsg_put(msg,  
                                      NL_AUTO_PORT,  
                                      NL_AUTO_SEQ,  
                                      XFRM_MSG_UPDSA,  
                                      sizeof(struct xfrm_usersa_info),  
                                      NLM_F_REQUEST);  
    if (!nlh) {  
        nlmsg_free(msg);  
        return -ENOMEM;  
    }  
      
    struct xfrm_usersa_info *sa = nlmsg_data(nlh);  
    memcpy(sa, sa_info, sizeof(struct xfrm_usersa_info));  
      
    if (if_id != 0) {  
        nla_put_u32(msg, XFRMA_IF_ID, if_id);  
    }  
      
    int res = nl_send_auto(socket, msg);  
    nlmsg_free(msg);  
      
    if (res < 0) {  
        fprintf(stderr, "Failed to send UPDSA message: %s\n", nl_geterror(res));  
        return res;  
    }  
      
    printf("SA update request sent successfully\n");  
    return 0;  
}

// Delete XFRM SA  
int xfrm_delete_sa(struct nl_sock *socket,  
                   xfrm_address_t *daddr,  
                   uint32_t spi,  
                   uint8_t proto,  
                   uint16_t family) {  
    struct nl_msg *msg = nlmsg_alloc();  
    if (!msg) {  
        fprintf(stderr, "Failed to allocate netlink message\n");  
        return -ENOMEM;  
    }  
      
    struct nlmsghdr *nlh = nlmsg_put(msg,  
                                      NL_AUTO_PORT,  
                                      NL_AUTO_SEQ,  
                                      XFRM_MSG_DELSA,  
                                      sizeof(struct xfrm_usersa_id),  
                                      NLM_F_REQUEST);  
    if (!nlh) {  
        nlmsg_free(msg);  
        return -ENOMEM;  
    }  
      
    struct xfrm_usersa_id *sa_id = nlmsg_data(nlh);  
    memset(sa_id, 0, sizeof(*sa_id));  
      
    memcpy(&sa_id->daddr, daddr, sizeof(xfrm_address_t));  
    sa_id->spi = spi;  
    sa_id->proto = proto;  
    sa_id->family = family;  
      
    int res = nl_send_auto(socket, msg);  
    nlmsg_free(msg);  
      
    if (res < 0) {  
        fprintf(stderr, "Failed to send DELSA message: %s\n", nl_geterror(res));  
        return res;  
    }  
      
    printf("SA deletion request sent successfully\n");  
    return 0;  
}  
  
int main(int argc, char **argv) {  
    struct nl_sock *socket;  
    int err;  
    uint32_t allocated_spi = 0;  
      
    // Create netlink socket  
    socket = nl_socket_alloc();  
    if (!socket) {  
        fprintf(stderr, "Failed to allocate netlink socket\n");  
        return 1;  
    }  
      
    // Disable sequence number checking for responses  
    nl_socket_disable_seq_check(socket);  
      
    // Connect to XFRM netlink  
    err = nl_connect(socket, NETLINK_XFRM);  
    if (err < 0) {  
        fprintf(stderr, "Failed to connect to XFRM netlink: %s\n", nl_geterror(err));  
        nl_socket_free(socket);  
        return 1;  
    }  

    // Join XFRM multicast groups to receive notifications  
    nl_socket_add_membership(socket, XFRMNLGRP_SA);  
    nl_socket_add_membership(socket, XFRMNLGRP_ACQUIRE);  
    nl_socket_add_membership(socket, XFRMNLGRP_EXPIRE);  
      
    printf("Connected to XFRM netlink\n");  
      
    // Configure SA parameters  
    struct xfrm_usersa_info sa_info;  
    memset(&sa_info, 0, sizeof(sa_info));  
      
    sa_info.family = AF_INET;  
    sa_info.mode = XFRM_MODE_TUNNEL;  
    sa_info.id.proto = IPPROTO_ESP;  
      
    // Set destination address (localhost)  
    struct in_addr dst_addr;  
    inet_pton(AF_INET, "127.0.0.2", &dst_addr);  
    memcpy(&sa_info.id.daddr, &dst_addr, sizeof(dst_addr));  
      
    // Set source address (localhost)  
    struct in_addr src_addr;  
    inet_pton(AF_INET, "127.0.0.1", &src_addr);  
    memcpy(&sa_info.saddr, &src_addr, sizeof(src_addr));  
      
    // Allocate SPI and get the actual allocated value  
    printf("\nAllocating SPI...\n");  
    err = xfrm_allocate_spi_with_response(socket, &sa_info, 10, 100, 0, &allocated_spi);  
       
    printf("Successfully allocated SPI: 0x%08x\n", ntohl(allocated_spi));  
    if (allocated_spi == 0) {  
        fprintf(stderr, "Allocated SPI is 0. Good!\n");  
    } 

      
    // Prepare address for query/delete operations  
    xfrm_address_t daddr;  
    memset(&daddr, 0, sizeof(daddr));  
    memcpy(&daddr, &dst_addr, sizeof(dst_addr)); 
    
    // Query SA with the actual allocated SPI  
    printf("\nQuerying SA with allocated SPI...\n");  
    err = xfrm_get_sa(socket, &daddr, allocated_spi, IPPROTO_ESP, AF_INET, 0);  
    if (err < 0) {  
        fprintf(stderr, "SA query failed\n");  
    } else {  
        printf("SA query succeeded\n");  
    }

    // Update SA with new replay window  
    printf("\nUpdating SA...\n");  
    sa_info.id.spi = allocated_spi;  
    sa_info.replay_window = 64;  // Update replay window  
    err = xfrm_update_sa(socket, &sa_info, 0);  
    if (err < 0) {  
        fprintf(stderr, "SA update failed\n");  
    } else {  
        printf("SA update succeeded\n");  
    }
            
    // Delete SA with the actual allocated SPI  
    printf("\nDeleting SA with allocated SPI...\n");  
    err = xfrm_delete_sa(socket, &daddr, allocated_spi, IPPROTO_ESP, AF_INET);  
    if (err < 0) {  
        fprintf(stderr, "SA deletion failed\n");  
    } else {  
        printf("SA deletion succeeded\n");  
    }  

    // Cleanup  
    nl_socket_free(socket);  
      
    return 0;  
}
