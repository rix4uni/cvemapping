#!/usr/bin/env python3
"""
jira_cve2025_22167_scanner.py
Safe scanner for CVE-2025-22167 (Jira Path Traversal - arbitrary write).
- Non-intrusive: only queries server info endpoints & headers.
- Outputs CSV and JSON reports.
"""

import requests
import concurrent.futures
import argparse
import csv
import json
import re
from urllib.parse import urljoin

# --- Configuration ---
TIMEOUT = 10
WORKERS = 12

# Vulnerable ranges (introduced in 9.12.0, 10.3.0 and present through 11.0.0)
# Fixed versions (per Atlassian advisory) â€” treat as "safe if >= these".
# NOTE: update these numbers if Atlassian provides new fixed versions.
FIXED_THRESHOLDS = {
    "jira_software": "9.12.28",   # example fixed lower bound (check bulletin)
    "jira_service": "5.12.28"
}

VULN_INTRODUCED = [
    ("9.12.0", None),  # introduced in 9.12.0 onward for Jira Software
    ("10.3.0", None)   # introduced in 10.3.0 as well (service/other lines)
]

# --- Helpers ---
semver_re = re.compile(r"(\d+)\.(\d+)\.(\d+)")

def parse_version(s):
    if not s: 
        return None
    m = semver_re.search(s)
    if not m:
        # try fallback: numbers separated by dots maybe more components
        parts = re.findall(r"\d+", s)
        if len(parts) >= 3:
            return tuple(int(x) for x in parts[:3])
        return None
    return tuple(int(x) for x in m.groups())

def ver_cmp(a, b):
    """Return -1 if a<b, 0 if equal, 1 if a>b. a,b tuples or None."""
    if a is None or b is None:
        return None
    for x,y in zip(a,b):
        if x<y: return -1
        if x>y: return 1
    return 0

def is_potentially_vulnerable(version_tuple):
    """Based on advisory: vulnerable if version >=9.12.0 (and < fixed threshold).
       We'll check against fixed thresholds from config.
    """
    if version_tuple is None:
        return None
    # compare to fixed thresholds (use jira_software threshold)
    fixed = parse_version(FIXED_THRESHOLDS["jira_software"])
    if fixed is None:
        return None
    cmp_to_fixed = ver_cmp(version_tuple, fixed)
    # vulnerable if version < fixed && version >= 9.12.0
    introduced = parse_version("9.12.0")
    if ver_cmp(version_tuple, introduced) >= 0 and ver_cmp(version_tuple, fixed) < 0:
        return True
    # also check other introduced line 10.3.0 (if version >=10.3.0 and < fixed)
    intro2 = parse_version("10.3.0")
    if ver_cmp(version_tuple, intro2) >= 0 and ver_cmp(version_tuple, fixed) < 0:
        return True
    return False

# --- Scanning logic ---
def probe_target(base_url, session=None):
    result = {
        "target": base_url,
        "server_info_version": None,
        "server_header": None,
        "detected": False,
        "reason": [],
        "error": None
    }
    if session is None:
        session = requests.Session()
    try:
        session.headers.update({"User-Agent":"safe-jira-scanner/1.0"})
        # 1) Try REST API serverInfo (common in Jira)
        for candidate in ["/rest/api/2/serverInfo", "/rest/api/3/serverInfo", "/rest/api/latest/serverInfo"]:
            try:
                url = urljoin(base_url, candidate)
                r = session.get(url, timeout=TIMEOUT, allow_redirects=True, verify=True)
                if r.status_code == 200 and r.headers.get("Content-Type","").lower().startswith("application/json"):
                    try:
                        j = r.json()
                        v = j.get("version") or j.get("serverVersion")
                        if v:
                            result["server_info_version"] = v
                            result["reason"].append(f"serverInfo endpoint {candidate} returned version")
                            break
                    except Exception:
                        pass
            except requests.RequestException:
                pass

        # 2) Fallback: try to detect version from headers or HTML title
        if result["server_info_version"] is None:
            try:
                r = session.get(base_url, timeout=TIMEOUT, allow_redirects=True, verify=True)
                # headers
                server_hdr = r.headers.get("Server") or r.headers.get("X-Instance-Id") or r.headers.get("X-Atlassian-Token")
                if server_hdr:
                    result["server_header"] = server_hdr
                # look for version in HTML
                text = r.text[:2000]
                m = re.search(r"Jira(?:\s+)?(?:Server|Software)?\s*([\d\.]+)", text, re.I)
                if m:
                    result["server_info_version"] = m.group(1)
                    result["reason"].append("version found in HTML")
            except requests.RequestException:
                pass

        # 3) Analyze version (if found)
        ver_tuple = parse_version(result["server_info_version"]) if result["server_info_version"] else None
        result["potentially_vulnerable"] = is_potentially_vulnerable(ver_tuple)
        # If version missing, mark as unknown and recommend manual check
        if result["server_info_version"] is None:
            result["reason"].append("no version discovered via non-intrusive probes")
            result["potentially_vulnerable"] = None

    except Exception as e:
        result["error"] = str(e)
    return result

def run_many(targets, workers=WORKERS):
    out = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=workers) as ex:
        futs = {ex.submit(probe_target, t): t for t in targets}
        for fut in concurrent.futures.as_completed(futs):
            res = fut.result()
            out.append(res)
            print(f"[{res['target']}] version={res.get('server_info_version')} vuln={res.get('potentially_vulnerable')}")
    return out

# --- CLI / IO ---
def load_targets_from_file(path):
    with open(path, "r", encoding="utf-8") as f:
        lines = [l.strip() for l in f if l.strip() and not l.strip().startswith("#")]
    # normalize to include scheme if missing
    def norm(u):
        if u.startswith("http://") or u.startswith("https://"):
            return u
        return "https://" + u
    return [norm(x) for x in lines]

def save_csv(results, path):
    keys = ["target","server_info_version","server_header","potentially_vulnerable","reason","error"]
    with open(path, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=keys)
        writer.writeheader()
        for r in results:
            row = {k: r.get(k) for k in keys}
            row["reason"] = " | ".join(r.get("reason") or [])
            writer.writerow(row)

def save_json(results, path):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(results, f, indent=2, ensure_ascii=False)

def main():
    parser = argparse.ArgumentParser(description="Safe scanner to detect possible CVE-2025-22167-affected Jira instances (non-intrusive).")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--targets", help="file with newline-separated targets (host or URL).")
    group.add_argument("--url", help="single target URL (e.g. https://jira.example.com).")
    parser.add_argument("--out-csv", default="scan_report.csv")
    parser.add_argument("--out-json", default="scan_report.json")
    parser.add_argument("--workers", type=int, default=12)
    args = parser.parse_args()

    if args.targets:
        targets = load_targets_from_file(args.targets)
    else:
        targets = [args.url if args.url.startswith("http") else "https://" + args.url]

    results = run_many(targets, workers=args.workers)
    save_csv(results, args.out_csv)
    save_json(results, args.out_json)
    print(f"Saved CSV -> {args.out_csv}  JSON -> {args.out_json}")
    # Summary
    vuln = [r for r in results if r.get("potentially_vulnerable") is True]
    unknown = [r for r in results if r.get("potentially_vulnerable") is None]
    print("SUMMARY:")
    print(f"Total checked: {len(results)}  Potentially vulnerable: {len(vuln)}  Unknown (no version): {len(unknown)}")
    if vuln:
        print("Potentially vulnerable targets:")
        for v in vuln:
            print(" -", v["target"], "version=", v.get("server_info_version"))

if __name__ == "__main__":
    main()
