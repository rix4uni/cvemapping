// essiv_authenc_afalg_nb.c
// gcc -O0 -g -Wall essiv_authenc_afalg_nb.c -o essiv_authenc_afalg_nb
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/if_alg.h>
#include <linux/rtnetlink.h>
#include <poll.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef CRYPTO_AUTHENC_KEYA_PARAM
#define CRYPTO_AUTHENC_KEYA_PARAM 1
#endif

struct crypto_authenc_key_param {
    uint32_t enckeylen_be; // __be32
};

// authenc key format expected by crypto_authenc_extractkeys():
//   [ rtattr(type=CRYPTO_AUTHENC_KEYA_PARAM, payload=param(enckeylen)) ]
//   [ authkey bytes ... ]
//   [ enckey bytes  ... ]
static int set_authenc_key(int sockfd,
                           const uint8_t *auth_key, uint32_t auth_len,
                           const uint8_t *enc_key,  uint32_t enc_len)
{
    struct crypto_authenc_key_param param;
    param.enckeylen_be = htonl(enc_len);

    const size_t rta_payload_len = sizeof(param);
    const size_t rta_len   = RTA_LENGTH(rta_payload_len);
    const size_t rta_space = RTA_SPACE(rta_payload_len);

    const size_t blob_len = rta_space + auth_len + enc_len;

    uint8_t *blob = calloc(1, blob_len);
    if (!blob) return -1;

    struct rtattr *rta = (struct rtattr *)blob;
    rta->rta_type = CRYPTO_AUTHENC_KEYA_PARAM;
    rta->rta_len  = (unsigned short)rta_len;

    memcpy(RTA_DATA(rta), &param, sizeof(param));

    uint8_t *p = blob + rta_space;
    memcpy(p, auth_key, auth_len); p += auth_len;
    memcpy(p, enc_key,  enc_len);

    int rc = setsockopt(sockfd, SOL_ALG, ALG_SET_KEY, blob, blob_len);
    free(blob);
    return rc;
}

static void hexdump16(const char *label, const uint8_t *buf, size_t len)
{
    printf("%s (%zu):\n", label, len);
    for (size_t i = 0; i < len; i++) {
        printf("%02x%s", buf[i], ((i + 1) % 16) ? " " : "\n");
    }
    if (len % 16) printf("\n");
}

static int set_nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags < 0) return -1;
    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

int main(void)
{
    struct sockaddr_alg sa = {
        .salg_family = AF_ALG,
        .salg_type   = "aead",
        .salg_name   = "essiv(authenc(hmac(sha256),cbc(aes)),sha256)",
    };

    int tfmfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
    if (tfmfd < 0) { perror("socket"); return 1; }

    if (bind(tfmfd, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
        perror("bind");
        close(tfmfd);
        return 1;
    }
    printf("Bound to %s\n", sa.salg_name);

    uint8_t auth_key[32], enc_key[32];
    memset(auth_key, 0xAA, sizeof(auth_key));
    memset(enc_key,  0xBB, sizeof(enc_key));

    if (set_authenc_key(tfmfd, auth_key, sizeof(auth_key), enc_key, sizeof(enc_key)) < 0) {
        perror("ALG_SET_KEY");
        close(tfmfd);
        return 1;
    }
    puts("Key set OK");

    uint32_t authsize = 32;
    if (setsockopt(tfmfd, SOL_ALG, ALG_SET_AEAD_AUTHSIZE, &authsize, sizeof(authsize)) < 0) {
        perror("ALG_SET_AEAD_AUTHSIZE");
        close(tfmfd);
        return 1;
    }
    puts("Authsize set OK");

    int opfd = accept(tfmfd, NULL, 0);
    if (opfd < 0) { perror("accept"); close(tfmfd); return 1; }
    puts("Accepted op socket");

    if (set_nonblock(opfd) < 0) {
        perror("fcntl(O_NONBLOCK)");
        close(opfd);
        close(tfmfd);
        return 1;
    }

    const uint32_t ssize    = 8;
    const uint32_t ivsize   = 16;
    const uint32_t assoclen = ssize + ivsize; // 24

    uint8_t aad_and_pt[24 + 32];
    memset(aad_and_pt, 0, sizeof(aad_and_pt));

    uint64_t sector = 0x1122334455667788ULL;
    memcpy(aad_and_pt, &sector, sizeof(sector));         // AAD[0..7] = sector
    memset(aad_and_pt + assoclen, 0x42, 32);             // plaintext

    uint8_t iv[16] = {0};
    memcpy(iv, &sector, sizeof(sector));

    struct {
        uint32_t ivlen;
        uint8_t  iv[16];
    } alg_iv;
    memset(&alg_iv, 0, sizeof(alg_iv));
    alg_iv.ivlen = 16;
    memcpy(alg_iv.iv, iv, 16);

    struct msghdr msg;
    memset(&msg, 0, sizeof(msg));

    uint8_t cbuf[CMSG_SPACE(sizeof(uint32_t)) +
                 CMSG_SPACE(sizeof(alg_iv)) +
                 CMSG_SPACE(sizeof(uint32_t))];
    memset(cbuf, 0, sizeof(cbuf));

    msg.msg_control = cbuf;
    msg.msg_controllen = sizeof(cbuf);

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);

    cmsg->cmsg_level = SOL_ALG;
    cmsg->cmsg_type  = ALG_SET_OP;
    cmsg->cmsg_len   = CMSG_LEN(sizeof(uint32_t));
    *(uint32_t *)CMSG_DATA(cmsg) = ALG_OP_ENCRYPT;

    cmsg = CMSG_NXTHDR(&msg, cmsg);
    cmsg->cmsg_level = SOL_ALG;
    cmsg->cmsg_type  = ALG_SET_IV;
    cmsg->cmsg_len   = CMSG_LEN(sizeof(alg_iv));
    memcpy(CMSG_DATA(cmsg), &alg_iv, sizeof(alg_iv));

    cmsg = CMSG_NXTHDR(&msg, cmsg);
    cmsg->cmsg_level = SOL_ALG;
    cmsg->cmsg_type  = ALG_SET_AEAD_ASSOCLEN;
    cmsg->cmsg_len   = CMSG_LEN(sizeof(uint32_t));
    *(uint32_t *)CMSG_DATA(cmsg) = assoclen;

    struct iovec iov = {
        .iov_base = aad_and_pt,
        .iov_len  = sizeof(aad_and_pt),
    };
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    printf("sendmsg: assoclen=%u total=%zu (AAD=%u, PT=32)\n",
           assoclen, iov.iov_len, assoclen);

    // Non-blocking sendmsg: may return EAGAIN if kernel queues are full/hung.
    ssize_t s = sendmsg(opfd, &msg, 0);
    if (s < 0) {
        perror("sendmsg");
        printf("errno=%d\n", errno);
        close(opfd);
        close(tfmfd);
        return 1;
    }
    printf("sendmsg returned %zd\n", s);

    // Wait for output readiness with timeout
    struct pollfd pfd = { .fd = opfd, .events = POLLIN };
    int pr = poll(&pfd, 1, 3000); // 3s timeout
    if (pr < 0) {
        perror("poll");
        close(opfd);
        close(tfmfd);
        return 1;
    }
    if (pr == 0) {
        fprintf(stderr, "poll timeout: kernel didn't produce output (likely stuck in crypto path)\n");
        fprintf(stderr, "Tip: while it's stuck, check /proc/<pid>/stack or SysRq-w for blocked tasks.\n");
        close(opfd);
        close(tfmfd);
        return 2;
    }

    uint8_t out[512];
    ssize_t n = read(opfd, out, sizeof(out));
    if (n < 0) {
        perror("read");
        close(opfd);
        close(tfmfd);
        return 1;
    }
    printf("read %zd bytes\n", n);
    hexdump16("output (first 128 bytes max)", out, (size_t)((n < 128) ? n : 128));

    close(opfd);
    close(tfmfd);
    return 0;
}

