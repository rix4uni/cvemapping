#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Safe-check (heurístico) para possível exposição à CVE-2025-23419 (NGINX mTLS bypass via TLS session resumption).

O que ele faz (sem exploração):
- Tenta obter "Server: nginx/versão" via HEAD.
- Verifica se a versão do nginx (se exposta) parece vulnerável (antes de 1.26.3 / 1.27.4).
- Observa se o endpoint parece exigir mTLS (falha de handshake sem client cert, ou status típico de cert ausente).
- Testa se há indício de TLS session resumption (session_reused em reconexão).
- Tenta SNI/Host "aleatório" para inferir se existe algum vhost/default sem mTLS no mesmo IP:porta.

Saída padrão (1 linha):
- "POSSIVEL" ou "NAO_INDICADO"
"""

import argparse
import random
import socket
import ssl
import sys
from urllib.parse import urlparse

CERT_ERROR_STATUS = {400, 401, 403, 495, 496}  # 495/496 são comuns no nginx (não padrão) quando mTLS/cert falha.

def parse_nginx_version(server_header: str):
    if not server_header:
        return None
    s = server_header.strip().lower()
    # Exemplos: "nginx", "nginx/1.24.0", "nginx/1.26.2 (Ubuntu)"
    if "nginx" not in s:
        return None
    if "nginx/" not in s:
        return "unknown"
    try:
        part = s.split("nginx/", 1)[1].split()[0]
        # "1.26.2" etc
        nums = part.split(".")
        return tuple(int(x) for x in nums[:3])  # (major, minor, patch)
    except Exception:
        return "unknown"

def is_probably_vulnerable_nginx(ver):
    """
    Heurística baseada nas versões de fix publicadas:
    - Stable: >= 1.26.3 corrigido
    - Mainline: >= 1.27.4 corrigido
    """
    if ver is None:
        return None  # desconhecido
    if ver == "unknown":
        return None
    # ver como tuple (major, minor, patch)
    if len(ver) == 2:
        ver = (ver[0], ver[1], 0)
    major, minor, patch = ver
    if major != 1:
        return None  # fora do padrão esperado
    # Menor que 1.26.3 -> provável vulnerável
    if (minor, patch) < (26, 3):
        return True
    # Entre 1.27.0 e 1.27.3 -> provável vulnerável
    if minor == 27 and patch < 4:
        return True
    return False

def recv_http_response(sock, max_bytes=65536):
    data = b""
    try:
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            data += chunk
            if len(data) >= max_bytes:
                break
    except Exception:
        pass
    return data

def parse_status_and_headers(raw: bytes):
    """
    Retorna (status_code:int|None, headers:dict lower->value)
    """
    try:
        text = raw.decode("iso-8859-1", errors="replace")
        head = text.split("\r\n\r\n", 1)[0]
        lines = head.split("\r\n")
        if not lines:
            return None, {}
        status_line = lines[0]
        parts = status_line.split()
        status = int(parts[1]) if len(parts) >= 2 and parts[1].isdigit() else None
        headers = {}
        for ln in lines[1:]:
            if ":" in ln:
                k, v = ln.split(":", 1)
                headers[k.strip().lower()] = v.strip()
        return status, headers
    except Exception:
        return None, {}

def tls_head_request(host, port, path, sni, timeout, session=None):
    """
    Faz:
    - TCP connect
    - TLS handshake (sem client cert)
    - Envia HEAD
    Retorna dict com: ok, tls_version, session_reused, status, headers, error
    """
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    result = {
        "ok": False,
        "tls_version": None,
        "session_reused": None,
        "status": None,
        "headers": {},
        "error": None,
        "session": None,
    }

    try:
        with socket.create_connection((host, port), timeout=timeout) as tcp:
            with ctx.wrap_socket(tcp, server_hostname=sni, session=session) as ssock:
                result["tls_version"] = ssock.version()
                try:
                    result["session_reused"] = bool(getattr(ssock, "session_reused", False))
                except Exception:
                    result["session_reused"] = None

                # HEAD request
                req = (
                    f"HEAD {path} HTTP/1.1\r\n"
                    f"Host: {sni}\r\n"
                    f"User-Agent: cve-2025-23419-safecheck/1.0\r\n"
                    f"Connection: close\r\n\r\n"
                ).encode("ascii", "ignore")
                ssock.sendall(req)
                raw = recv_http_response(ssock)
                status, headers = parse_status_and_headers(raw)
                result["status"] = status
                result["headers"] = headers

                try:
                    result["session"] = ssock.session
                except Exception:
                    result["session"] = None

                result["ok"] = True
                return result

    except ssl.SSLError as e:
        result["error"] = f"ssl_error: {e.__class__.__name__}: {e}"
        return result
    except Exception as e:
        result["error"] = f"error: {e.__class__.__name__}: {e}"
        return result

def pick_path(parsed):
    return parsed.path if parsed.path else "/"

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("url", help="Ex: https://exemplo.com/alguma-coisa")
    ap.add_argument("--timeout", type=float, default=6.0)
    ap.add_argument("--verbose", action="store_true")
    ap.add_argument("--json", action="store_true", help="Imprime JSON simples (sem libs).")
    args = ap.parse_args()

    u = urlparse(args.url)
    if u.scheme not in ("https", ""):
        print("NAO_INDICADO")
        return 1

    host = u.hostname
    if not host:
        print("NAO_INDICADO")
        return 1

    port = u.port or 443
    path = pick_path(u)

    # 1) Requisição "normal" com SNI/Host do alvo
    r1 = tls_head_request(host, port, path, sni=host, timeout=args.timeout, session=None)

    # Heurística mTLS: handshake falhou OU status típico de cert ausente.
    mtls_required = False
    if not r1["ok"]:
        # Se falhou no TLS, pode ser mTLS exigido (ou outras razões). Vamos marcar como "possível mTLS".
        mtls_required = True
    else:
        if r1["status"] in CERT_ERROR_STATUS:
            mtls_required = True

    # 2) Tenta resumir sessão (indicativo de session resumption habilitado)
    resumption_supported = False
    if r1["ok"] and r1.get("session") is not None:
        r2 = tls_head_request(host, port, path, sni=host, timeout=args.timeout, session=r1["session"])
        if r2["ok"] and r2["session_reused"] is True:
            resumption_supported = True
    else:
        r2 = None

    # 3) Tenta “SNI/Host aleatório” pra inferir vhost/default sem mTLS no mesmo IP:porta
    rand_host = f"{random.randint(100000,999999)}.invalid"
    r3 = tls_head_request(host, port, "/", sni=rand_host, timeout=args.timeout, session=None)

    other_vhost_without_mtls_hint = False
    if r3["ok"]:
        # Se o "aleatório" respondeu sem cara de cert faltando, é um indício forte de vhost/default sem mTLS
        if r3["status"] is not None and r3["status"] not in CERT_ERROR_STATUS:
            other_vhost_without_mtls_hint = True

    # 4) Detecta nginx/version (se exposta)
    server_hdr = r1["headers"].get("server") if r1["ok"] else None
    nginx_ver = parse_nginx_version(server_hdr) if server_hdr else None
    nginx_prob_vuln = is_probably_vulnerable_nginx(nginx_ver)

    # Classificação conservadora:
    # - Para CVE fazer sentido: precisa de mTLS em algum vhost.
    # - Para cenário ficar “bom”: resumption + outro vhost sem mTLS no mesmo IP:porta.
    possible = False

    if mtls_required:
        # Se nginx vulnerável (ou desconhecido) E resumption ok (ou desconhecido), é "possível".
        if nginx_prob_vuln in (True, None):
            if resumption_supported or resumption_supported is False:
                # Se já achou indício de outro vhost sem mTLS, aumenta confiança.
                possible = True
            else:
                possible = True  # conservador: sem prova de resumption, mas ainda pode existir
    else:
        # Endpoint não aparenta exigir mTLS -> CVE pouco relevante para ESTE endpoint.
        possible = False

    # Saída
    out = {
        "url": args.url,
        "result": "POSSIVEL" if possible else "NAO_INDICADO",
        "nginx_server_header": server_hdr,
        "nginx_version": nginx_ver,
        "nginx_version_probably_vulnerable": nginx_prob_vuln,
        "mtls_required_hint": mtls_required,
        "tls_version": r1.get("tls_version"),
        "session_resumption_reused": (r2.get("session_reused") if r2 else None),
        "resumption_supported_hint": resumption_supported,
        "other_vhost_without_mtls_hint": other_vhost_without_mtls_hint,
        "errors": {
            "primary": r1.get("error"),
            "resumption": (r2.get("error") if r2 else None),
            "random_sni": r3.get("error"),
        }
    }

    if args.json:
        # JSON simples sem dependências
        def esc(x):
            return str(x).replace("\\", "\\\\").replace('"', '\\"')
        items = []
        for k, v in out.items():
            if isinstance(v, dict):
                sub = []
                for sk, sv in v.items():
                    sub.append(f'"{esc(sk)}":"{esc(sv)}"')
                items.append(f'"{esc(k)}":' + "{" + ",".join(sub) + "}")
            else:
                items.append(f'"{esc(k)}":"{esc(v)}"')
        print("{" + ",".join(items) + "}")
    else:
        if args.verbose:
            print(f"{out['result']}")
            print(f"  nginx_header: {out['nginx_server_header']}")
            print(f"  nginx_ver: {out['nginx_version']} (vuln? {out['nginx_version_probably_vulnerable']})")
            print(f"  mtls_hint: {out['mtls_required_hint']}")
            print(f"  tls: {out['tls_version']}")
            print(f"  resumption_reused: {out['session_resumption_reused']} (hint: {out['resumption_supported_hint']})")
            print(f"  other_vhost_no_mtls_hint: {out['other_vhost_without_mtls_hint']}")
            if out["errors"]["primary"]:
                print(f"  err_primary: {out['errors']['primary']}")
        else:
            print(out["result"])

    return 0 if possible else 1

if __name__ == "__main__":
    raise SystemExit(main())
