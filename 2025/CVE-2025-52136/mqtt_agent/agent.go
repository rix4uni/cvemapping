package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os/exec"
	"time"

	mqtt "github.com/eclipse/paho.mqtt.golang"
)

const (
	broker   = "tcp://127.0.0.1:1883"
	topicRx  = "rx/cmd"
	topicTx  = "tx/cmd"
	clientID = "system_agent_go"
)

type CommandResult struct {
	Command    string `json:"command"`
	ReturnCode int    `json:"returncode"`
	Stdout     string `json:"stdout"`
	Stderr     string `json:"stderr"`
	Timestamp  string `json:"timestamp"`
}

func main() {
	opts := mqtt.NewClientOptions()
	opts.AddBroker(broker)
	opts.SetClientID(clientID)
	opts.OnConnect = func(c mqtt.Client) {
		fmt.Println("[INFO] Connected to EMQX")
		if token := c.Subscribe(topicRx, 0, func(client mqtt.Client, msg mqtt.Message) {
			command := string(msg.Payload())
			fmt.Printf("[CMD] Received: %s\n", command)
			executeAndPublish(client, command)
		}); token.Wait() && token.Error() != nil {
			fmt.Printf("[ERROR] Subscribe error: %v\n", token.Error())
		} else {
			fmt.Printf("[INFO] Subscribed to topic %s\n", topicRx)
		}
	}

	client := mqtt.NewClient(opts)
	if token := client.Connect(); token.Wait() && token.Error() != nil {
		panic(token.Error())
	}

	select {}
}

func executeAndPublish(client mqtt.Client, command string) {
	cmd := exec.Command("bash", "-c", command)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Run()

	result := CommandResult{
		Command:    command,
		ReturnCode: cmd.ProcessState.ExitCode(),
		Stdout:     stdout.String(),
		Stderr:     stderr.String(),
		Timestamp:  time.Now().Format("2006-01-02 15:04:05"),
	}

	if err != nil {
		result.Stderr += fmt.Sprintf("\n[ERROR] %v", err)
	}

	data, _ := json.Marshal(result)
	token := client.Publish(topicTx, 0, false, data)
	token.Wait()

	fmt.Printf("[RESULT] Published to %s\n", topicTx)
}
