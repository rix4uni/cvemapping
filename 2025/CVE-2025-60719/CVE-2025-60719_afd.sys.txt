{'cve': 'CVE-2025-60719', 'date': 1763412331.5615878, 'change_count': 5, 'file': 'afd.sys', 'patch_store_uid': 'dd9c6721-2756-4ad6-92a0-850c704dd674', 'kb': 'KB5068861', 'confidence': 0.19}
--------------------------------------------------------------------
CVE-2025-60719 Report
--------------------------------------------------------------------

Component
--------------------------------------------------------------------
Windows Ancillary Function Driver for WinSock (afd.sys) – several
request-handling routines (AfdSocketTransferBegin / End, AfdBind,
AfdConnect and AfdGetInformation).


Vulnerability Class
--------------------------------------------------------------------
Untrusted pointer dereference (CWE-822) that can be triggered from
user-mode through crafted Winsock/AFD ioctl sequences, resulting in
local elevation of privilege.


Detailed Root Cause Analysis
--------------------------------------------------------------------
1.  All affected entry points retrieve structures that originate in
    user space (socket-address buffers, OPTION structs, IRP context or
    FILE_OBJECT pointers supplied through handles).

2.  In the pre-patch code these user controlled addresses are copied or
    dereferenced in kernel mode without first:
      • verifying the caller supplied length against the structure
        actually referenced; or
      • pinning / probing the pages; or
      • preventing the underlying endpoint from being “un-bound” while
        the pointers are being used.

3.  Example – AfdConnect (x86 paths omitted for brevity):
      a.  The user buffer is parsed:
          Src      = *(char **)(irp + 0x20) + 0xC;
          Size     = *(DWORD *)(irp + 0x10) – 0xC;
      b.  Kernel buffer ‘Pool2 + 0x60’ is initialised and the *pointer*
         from user land is blindly copied with
            memmove(Pool2 + 0x60, Src, Size);
      c.  Downstream helpers (e.g. AfdTdi_TA6toTA4_InPlace, 
         AfdSetupConnectDataBuffers) treat the embedded fields as
         trusted, leading to arbitrary kernel dereference when the
         caller supplies a fake pointer value inside the copied buffer.

4.  AfdBind, AfdSocketTransferBegin and AfdSocketTransferEnd follow the
    same pattern when building MDLs or when sending TDI requests – the
    endpoint can be unbound while the request is in-flight, turning the
    once-valid DeviceObject / FileObject pointers into attacker
    controlled memory.

5.  Because the code runs in kernel context, a crafted pointer can be
    used to gain read/write access to arbitrary kernel memory and thus
    to execute code at ring-0.

Structures / fields involved (64-bit offsets):
    ENDPOINT +0x18  Socket state flags
    ENDPOINT +0x28  FileObject pointer (user supplied handle path)
    IOCTL_IN   +0x00 AF_UNIX/SOCKADDR header copied via memmove()

A mismatch between the user supplied size and the real structure
results in the dereference of attacker chosen addresses.


Vulnerability Code Snippets
--------------------------------------------------------------------
```c
// AfdConnect – before patch
Pool2 = ExAllocatePool2(97, userLen+0x60, TAG);
memmove((void*)(Pool2+0x60), userPtr, userLen);
...
AfdTdi_TA6toTA4_InPlace(v58[2].Buffer, &v58[2]);   // uses data just
                                                  // copied from user
```
```c
// AfdBind – before patch
P = ExAllocatePool2(97, len, TAG);
memmove(P, userSockAddr+4, len);   // no probe / validation
```
```c
// AfdSocketTransferBegin – before patch
_DeviceObject = *(PDEVICE_OBJECT *)(Endpoint+0x28);
_FileObject   = *(PFILE_OBJECT   *)(Endpoint+0x18);
IofCallDriver(_DeviceObject, Irp); // possible stale / attacker ptr
```


Trigger Flow (Top-Down)
--------------------------------------------------------------------
1. User process obtains an AFD handle (AFD_CREATE).
2. Crafts an ioctl buffer that contains a fake kernel pointer in one of
   the embedded fields (e.g. sockaddr structure).
3. Sends the buffer with NtDeviceIoControlFile → reaches one of the
   vulnerable routines.
4. Kernel copies the buffer and later dereferences the embedded pointer
   while still running at IRQL <= APC_LEVEL.
5. Controlled kernel read/write → privilege escalation.


Attack Vector
--------------------------------------------------------------------
Local, authenticated user; no special privileges required other than
ability to open an AFD device handle (granted to normal users).


Patch Description
--------------------------------------------------------------------
The fix introduces defensive checks and state balancing:
1. Strict length / AF checks before copying user buffers.
2. KeGetCurrentIrql() + RtlEqualUnicodeString() guard to ensure only
   Bluetooth RFCOMM endpoints are handled by the fast-path.
3. Feature-flag gated call to AfdPreventUnbind() with a matching
   AfdReallowUnbind() in every exit path so the endpoint cannot be
   detached while pointers are in use.
4. Additional checks on ENDPOINT type, address family, socket state and
   MDL allocation success; immediate bailout with STATUS_INVALID_PARAM
   on failure.
5. Output / user buffers are now written through an explicit probe and
   volatile copy (RtlCopyVolatileMemory).


Security Impact
--------------------------------------------------------------------
Before the patch a local attacker could cause afd.sys to dereference an
attacker-controlled kernel pointer leading to arbitrary kernel memory
access and full elevation to SYSTEM.


Fix Effectiveness
--------------------------------------------------------------------
All dereferences are now protected by size/AF validation, IRQL checks,
proper probing of user addresses and by holding the unbind lock around
sensitive sections.  Each exit path re-enables unbind, eliminating the
leak.  No further untrusted pointer paths were observed in the updated
functions, so the vulnerability is considered fixed.
