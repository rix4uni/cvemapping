package main

import (
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"time"
)

const (
	certificateFile = "server.pem"
	privateKeyFile  = "server.key"
	serverHost      = "0.0.0.0"
	serverPort      = "443"
)

type loggingResponseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (lrw *loggingResponseWriter) WriteHeader(code int) {
	lrw.statusCode = code
	lrw.ResponseWriter.WriteHeader(code)
}

func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		lrw := &loggingResponseWriter{ResponseWriter: w, statusCode: http.StatusOK}
		
		next.ServeHTTP(lrw, r)
		
		duration := time.Since(start)
		log.Printf("%s %s %d %s", r.Method, r.URL.Path, lrw.statusCode, duration)
	})
}

func generateSelfSignedCertificate() error {
	if _, err := os.Stat(certificateFile); err == nil {
		if _, err := os.Stat(privateKeyFile); err == nil {
			return nil
		}
	}

	log.Println("Generating self-signed certificate...")
	
	cmd := exec.Command("openssl", "req", "-x509", "-newkey", "rsa:2048",
		"-keyout", privateKeyFile, "-out", certificateFile,
		"-days", "365", "-nodes", "-subj", "/CN=localhost")
	
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to generate certificate: %v", err)
	}
	
	return nil
}

func fileHandler(w http.ResponseWriter, r *http.Request) {
	requestedPath := r.URL.Path
	if requestedPath == "/" {
		requestedPath = "/index.html"
	}

	filePath := filepath.Clean("." + requestedPath)
	
	file, err := os.Open(filePath)
	if err != nil {
		if os.IsNotExist(err) {
			http.NotFound(w, r)
			return
		}
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}
	defer file.Close()

	info, err := file.Stat()
	if err != nil {
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	if info.IsDir() {
		http.NotFound(w, r)
		return
	}

	contentType := "application/octet-stream"
	switch filepath.Ext(filePath) {
	case ".html":
		contentType = "text/html"
	case ".css":
		contentType = "text/css"
	case ".js":
		contentType = "application/javascript"
	case ".png":
		contentType = "image/png"
	case ".jpg", ".jpeg":
		contentType = "image/jpeg"
	}

	w.Header().Set("Content-Type", contentType)
	
	if _, err := io.Copy(w, file); err != nil {
		log.Printf("Error writing response: %v", err)
	}
}

func main() {
	if err := generateSelfSignedCertificate(); err != nil {
		log.Fatalf("Certificate generation failed: %v", err)
	}

	cert, err := tls.LoadX509KeyPair(certificateFile, privateKeyFile)
	if err != nil {
		log.Fatalf("Failed to load certificate: %v", err)
	}

	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{cert},
		MinVersion:   tls.VersionTLS12,
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/", fileHandler)

	handler := loggingMiddleware(mux)

	server := &http.Server{
		Addr:      net.JoinHostPort(serverHost, serverPort),
		Handler:   handler,
		TLSConfig: tlsConfig,
	}

	log.Printf("Starting HTTPS server on %s:%s", serverHost, serverPort)
	
	if err := server.ListenAndServeTLS("", ""); err != nil && err != http.ErrServerClosed {
		log.Fatalf("Server error: %v", err)
	}
}
