#!/usr/bin/env python3
"""
Bulk Joomla detector + CVE-2022-27913 checker.

Reads targets from a file, detects whether each site runs Joomla (by scanning
HTML and headers), calls check_vulnerability(url) from joomla_version_detector,
and writes a timestamped results file.

Only scan sites you own or have explicit permission to test.
"""

import requests
import sys
import time
from urllib.parse import urlparse
from typing import List, Optional
from datetime import datetime

# Import the vulnerability check function from your other module.
# Ensure joomla_version_detector.check_vulnerability(url) exists and returns bool.
from joomla_version_detector import check_vulnerability


# ---------------- Utility functions ---------------- #

def load_urls(file_path: str) -> List[str]:
    """Read non-empty lines from file and return as a list of strings."""
    with open(file_path, "r", encoding="utf-8") as fh:
        return [line.strip() for line in fh if line.strip()]


def normalize_url(url: str) -> Optional[str]:
    """
    Ensure URL has a scheme (http/https). Return normalized URL or None if invalid.
    Examples:
      example.com     -> https://example.com
      http://foo      -> http://foo
    """
    if not url:
        return None

    url = url.strip()
    parsed = urlparse(url, scheme="https")
    # If netloc is empty but path contains the host (e.g., "example.com"), treat path as netloc
    if not parsed.netloc:
        parsed = urlparse("https://" + url, scheme="https")

    # Basic sanity check: require at least a hostname
    if not parsed.hostname:
        return None

    # Prefer https if user didn't give scheme
    scheme = parsed.scheme or "https"
    return f"{scheme}://{parsed.netloc}"  # drop path/query for base URL checks


def save_results(results: List[str], prefix: str = "Joomla_CVE-2022-27913") -> str:
    """Write results to a timestamped file and return the filename used."""
    timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    filename = f"{prefix}_{timestamp}.txt"
    with open(filename, "w", encoding="utf-8") as fh:
        for line in results:
            fh.write(line + "\n")
    return filename


# ---------------- Detection / processing ---------------- #

def detect_joomla(url: str, timeout: float = 10.0) -> Optional[str]:
    """
    Try to detect Joomla on the site. Returns a short detection message if Joomla is found,
    otherwise returns None.
    Uses HTML body checks and headers (non-exhaustive).
    """
    try:
        resp = requests.get(url, timeout=timeout)
    except requests.RequestException:
        return None

    body = resp.text or ""
    headers = {k.lower(): v for k, v in resp.headers.items()}

    # 1) Look for generator meta tag: <meta name="generator" content="Joomla! 3.10.2" />
    meta_marker = 'name="generator"'
    if meta_marker in body.lower() and "joomla" in body.lower():
        # attempt to extract version-like substring near the generator tag
        # keep it simple — we only need an indicator
        return "Joomla found in meta generator tag"

    # 2) Look for common Joomla strings in the HTML
    html_markers = ["powered by joomla", "joomla! cms", "content=\"joomla"]
    if any(marker in body.lower() for marker in html_markers):
        return "Joomla found in HTML content"

    # 3) Check headers for a Joomla indicator (rare)
    x_powered = headers.get("x-powered-by", "")
    if "joomla" in x_powered.lower():
        return "Joomla found in response headers"

    return None


def check_version_and_vulnerability(url: str) -> str:
    """
    For the provided (normalized) URL, detect Joomla and then use check_vulnerability()
    to decide if it is vulnerable. Returns a status string.
    """
    detect_msg = detect_joomla(url)
    if not detect_msg:
        return f"{url} - Not a Joomla site (no markers found)"

    # Joomla detected — now attempt version/vulnerability check (module function)
    try:
        vulnerable = check_vulnerability(url)
    except Exception as e:
        # If the checker raises, record the error rather than crashing
        return f"{url} - Joomla detected ({detect_msg}) - vulnerability check ERROR: {e}"

    if vulnerable:
        return f"{url} - Joomla detected ({detect_msg}), VULNERABLE to CVE-2022-27913"
    else:
        return f"{url} - Joomla detected ({detect_msg}), NOT vulnerable"


def process_targets(target_file: str, timeout: float = 10.0) -> List[str]:
    """
    Load targets, normalize them, process each, and return a list of result strings.
    """
    raw_urls = load_urls(target_file)
    results: List[str] = []

    print(f"Loaded {len(raw_urls)} targets from {target_file}\n")

    for idx, raw in enumerate(raw_urls, start=1):
        print(f"[{idx}/{len(raw_urls)}] Processing: {raw}")
        normalized = normalize_url(raw)
        if not normalized:
            msg = f"{raw} - INVALID URL (skipped)"
            print("  ->", msg)
            results.append(msg)
            continue

        # call detector + vulnerability checker
        try:
            result = check_version_and_vulnerability(normalized)
        except Exception as e:
            result = f"{normalized} - ERROR during processing: {e}"

        print("  ->", result)
        results.append(result)

        # polite delay to avoid hammering targets (adjust as needed)
        time.sleep(0.2)

    return results


# ---------------- Main ---------------- #

def main():
    # Allow specifying target file on command-line for convenience
    if len(sys.argv) >= 2:
        target_file = sys.argv[1]
    else:
        target_file = input("Enter path to targets file [default: targets.txt]: ").strip() or "targets.txt"

    try:
        results = process_targets(target_file)
    except FileNotFoundError:
        print(f"Targets file not found: {target_file}")
        sys.exit(1)
    except Exception as e:
        print(f"Fatal error: {e}")
        sys.exit(1)

    out_fname = save_results(results)
    print(f"\nResults written to: {out_fname}")


if __name__ == "__main__":
    print("WARNING: Only scan sites you own or have explicit permission to test.")
    main()
